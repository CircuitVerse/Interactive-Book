{
  "1": {
    "id": "1",
    "title": "N-Bit Parallel Adder & Subtractor",
    "content": "N-Bit Parallel Adder The Full Adder is capable of adding only two single digit binary number along with a carry input. But in practical we need to add binary numbers which are much longer than just one bit. To add two n-bit binary numbers we need to use the n-bit parallel adder. It uses a number of full adders in cascade. The carry output of the previous full adder is connected to carry input of the next full adder. 4 Bit Parallel Adder In the block diagram, A0 and B0 represent the LSB of the four bit words A and B. Hence Full Adder-0 is the lowest stage. Hence its Cin has been permanently made 0. The rest of the connections are exactly same as those of n-bit parallel adder is shown in fig. The four bit parallel adder is a very common logic circuit. Block Diagram N-Bit Parallel Subtractor The subtraction can be carried out by taking the 1’s or 2’s complement of the number to be subtracted. For example we can perform the subtraction (A-B) by adding either 1’s or 2’s complement of B to A. That means we can use a binary adder to perform the binary subtraction. 4 Bit Parallel Subtractor The number to be subtracted (B) is first passed through inverters to obtain its 1’s complement. The 4-bit adder then adds A and 2’s complement of B to produce the subtraction. S3 S2 S1 S0 represents the result of binary subtraction (A-B) and carry output Cout represents the polarity of the result. If A &gt; B then Cout = 0 and the result of binary form (A-B) then Cout = 1 and the result is in the 2’s complement form. Block Diagram 8 Bit Full Adder And Subtractor  ",
    "url": "http://localhost:4000/docs/Combinational/N-Bit%20Parallel%20Adder%20&%20Subtractor.html",
    "relUrl": "/docs/Combinational/N-Bit%20Parallel%20Adder%20&%20Subtractor.html"
  },
  "2": {
    "id": "2",
    "title": "Application of Shift Registers",
    "content": "In previous module, we discussed four types of shift registers. Based on the requirement, we can use one of those shift registers. Following are the applications of shift registers. Shift register is used as Parallel to serial converter, which converts the parallel data into serial data. It is utilized at the transmitter section after Analog to Digital Converter (ADC) block. Shift register is used as Serial to parallel converter, which converts the serial data into parallel data. It is utilized at the receiver section before Digital to Analog Converter (DAC) block. Shift register along with some additional gate(s) generate the sequence of zeros and ones. Hence, it is used as sequence generator. Shift registers are also used as counters. There are two types of counters based on the type of output from right most D flip-flop is connected to the serial input. Those are Ring counter and Johnson Ring counter. In this module, let us discuss about these two counters one by one. Ring Counter Johnson Ring Counter Ring Counter In previous module, we discussed the operation of Serial In - Parallel Out (SIPO) shift register. It accepts the data from outside in serial form and it requires ‘N’ clock pulses in order to shift ‘N’ bit data. Similarly, ‘N’ bit Ring counter performs the similar operation. But, the only difference is that the output of rightmost D flip-flop is given as input of leftmost D flip-flop instead of applying data from outside. Therefore, Ring counter produces a sequence of states (pattern of zeros and ones) and it repeats for every ‘N’ clock cycles. The block diagram of 3-bit Ring counter is shown in the following figure. The 3-bit Ring counter contains only a 3-bit SIPO shift register. The output of rightmost D flip-flop is connected to serial input of left most D flip-flop. Assume, initial status of the D flip-flops from leftmost to rightmost is Q2Q1Q0=001. Here, Q2 &amp; Q0 are MSB &amp; LSB respectively. We can understand the working of Ring counter from the following table. No of positive edge of Clock Serial Input = Q0 Q2(MSB) Q1 Q0(LSB) 0 - 0 0 1 1 1 1 0 0 2 0 0 1 0 3 0 0 0 1 The initial status of the D flip-flops in the absence of clock signal is Q2Q1Q0=001. This status repeats for every three positive edge transitions of clock signal. Therefore, the following operations take place for every positive edge of clock signal. Serial input of first D flip-flop gets the previous output of third flip-flop. So, the present output of first D flip-flop is equal to the previous output of third flip-flop. The previous outputs of first and second D flip-flops are right shifted by one bit. That means, the present outputs of second and third D flip-flops are equal to the previous outputs of first and second D flip-flops. Johnson Ring Counter The operation of Johnson Ring counter is similar to that of Ring counter. But, the only difference is that the complemented output of rightmost D flip-flop is given as input of leftmost D flip-flop instead of normal output. Therefore, ‘N’ bit Johnson Ring counter produces a sequence of states (pattern of zeros and ones) and it repeats for every ‘2N’ clock cycles. Johnson Ring counter is also called as Twisted Ring counter and switch tail Ring counter. The block diagram of 3-bit Johnson Ring counter is shown in the following figure. The 3-bit Johnson Ring counter also contains only a 3-bit SIPO shift register. The complemented output of rightmost D flip-flop is connected to serial input of left most D flip-flop. Assume, initially all the D flip-flops are cleared. So, Q2Q1Q0=000. Here, Q2 &amp; Q0 are MSB &amp; LSB respectively. We can understand the working of Johnson Ring counter from the following table. No of positive edge of Clock Serial Input = Q0 Q2(MSB) Q1 cQ0(LSB) 0 - 0 0 0 1 1 1 0 0 2 1 1 1 0 3 1 1 1 1 4 0 0 1 1 5 0 0 0 1 6 0 0 0 0 The initial status of the D flip-flops in the absence of clock signal is Q2Q1Q0=000. This status repeats for every six positive edge transitions of clock signal. Therefore, the following operations take place for every positive edge of clock signal. Serial input of first D flip-flop gets the previous complemented output of third flip-flop. So, the present output of first D flip-flop is equal to the previous complemented output of third flip-flop. The previous outputs of first and second D flip-flops are right shifted by one bit. That means, the present outputs of second and third D flip-flops are equal to the previous outputs of first and second D flip-flops.",
    "url": "http://localhost:4000/docs/application.html",
    "relUrl": "/docs/application.html"
  },
  "3": {
    "id": "3",
    "title": "Basic Applications",
    "content": "Basic Apllications Binary Flags Representing a Character Binary Flags The new Interactive Book for Digital logic design requires you to study binary binary and its uses. In computing, a flag is a type of signal usually used to indicate whether something is true or false. To save time and make your program less complicated, you might want to combine these flags and send several pieces of information in one go. Imagine you wanted to send a message to your friend to indicate which subjects had set homework on a particular day. If it was only one subject, you can just send the name of the subect - e.g. English - but if there is more than one, it gets more complicated. One way to do it is to give each subject a number: Serial no. Subject 1 English 2 Maths 4 Science 8 Computing 16 History 32 Geography 64 French 128 German You can send combinations of subjects by adding together the numbers and sending the total. Try it below: Enter the homework code and click the button. Code: This only works because of the numbers I’ve chosen - it’s a binary sequence, with each number being one of the binary column headings. This means that each total can only be made up from one combination of subjects. If they’d been numbered as 1 = English, 2 = Maths, 3 = Science, 4 = Computing, etc., then it wouldn’t work, because a code of 3 could represent English and Maths, or it could be Science on its own. To use this technique in your programming, you need to be familiar with bitwise logic Representing a Character The computer that we had when we were in the 80s - in common with a lot of personal computers at the time - allowed you to design your own text character. You could use this in a game - e.g. to make a “space invader” - or you could use the same technique to make your own font. I made my own font that looked like my handwriting! Characters were designed on an 8 x 8 grid, and created using eight numbers from 0-255. Each number was converted to binary and the resulting pattern of 0s and 1s was used to make a pattern of black and white dots on a single row. You can design a character in the same way by entering numbers from 0-255 in the boxes to the left of the grid. Each number is converted to binary and used to create the pattern of dots. 128 64 32 16 8 4 2 1 You can design a character in the same way by entering numbers from 0-255 in the boxes to the left of the grid. Each number is converted to binary and used to create the pattern of dots. Fonts on a modern computer would be made up of a lot more than 64 pixels, but the principle is the same. If you can’t see how the numbers are converted into the patterns of black and white blocks, try looking at the page on binary. If you can see the link between the number and the pattern, then think about how the web page works",
    "url": "http://localhost:4000/docs/application2.html",
    "relUrl": "/docs/application2.html"
  },
  "4": {
    "id": "4",
    "title": "Binary Numbers",
    "content": "Binary Numbers Introduction A Binary Number is made up of only 0s and 1s. Example: 110111 There is no 2, 3, 4, 5, 6, 7, 8 or 9 in Binary! How do we Count using Binary? It is just like counting in decimal except we reach 10 much sooner. Binary Explanation 0 We start at 0 1 Then 1 ??? But then there is no symbol for 2 … what do we do? Well how do we count in Decimal? Decimal Explanation 0 We start at 0 1 Then 1 2-8 Count 1,2,3,4,5,6,7,8 9 This is the last digit in Decimal 10 So we start back at 0 again, but add 1 on the left The same thing is done in binary ... Binary Explanation 0 We start at 0 1 Then 1 10 Now start back at 0 again, but add 1 on the left 11 1 more ??? But NOW what … ? What happens in Decimal? Decimal Explanation 99 When we run out of digits, we … 100 … start back at 0 again, but add 1 on the left And that is what we do in binary ... Binary Explanation 0 We start a 1 Then 1 10 Now start back at 0 again, but add 1 on the left 11 1 more 100 start back at 0 again, and add one to the number on the left but that number is already at 1 so it also goes back to 0 and 1 is added to the next position on the left 101   110   111   1000 Start back at 0 again (for all 3 digits), add 1 on the left See how it is done in this little demonstration 1280 640 320 160 80 40 20 10 = 0",
    "url": "http://localhost:4000/docs/binary.html",
    "relUrl": "/docs/binary.html"
  },
  "5": {
    "id": "5",
    "title": "Operators in Binary",
    "content": "Mathematical Operators in Binary Mathematical Operators in Binary Addition Subtraction Multiplication Division Binary system complements 1’s complement 2’s complement Bitwise Operators Addition 1. 0 + 0 = 0 2. 0 + 1 = 1 3. 1 + 0 = 1 4. 1 + 1 = 1 Subtraction 1. 0 - 0 = 0 2. 1 - 0 = 1 3. 1 - 1 = 0 Multiplication 1 1 0 (6) * 1 0 1 (5) 1 1 0 0 0 0 x 1 1 0 x x -- 1 1 1 1 0 (30) -- Division 1 1 1 1 0 / 1 0 1 - 1 0 1 1st - 1 1 0 0 1 - 1 0 1 2nd - 1 0 1 0 0 - 1 0 1 3rd - 0 1 1 1 1 - 1 0 1 4th - 1 0 1 0 - 1 0 1 5th - 1 0 1 - 1 0 1 6th - - 0 ans = 6 (110) - - Binary system complements As the binary system has base r = 2. So the two types of complements for the binary system are 2’s complement and 1’s complement. 1’s complement The 1’s complement of a number is found by changing all 1’s to 0’s and all 0’s to 1’s. This is called as taking complement or 1’s complement. Example of 1’s Complement is as follows. Given number 1 0 1 0 1 1&#39;s complement 0 1 0 1 0 2’s complement The 2’s complement of binary number is obtained by adding 1 to the Least Significant Bit (LSB) of 1’s complement of the number. 2’s complement = 1’s complement + 1 Given number 1 0 1 0 1 1&#39;s complement 0 1 0 1 0 add 1 + 1 2&#39;s complement 0 1 0 1 1 Bitwise Operators Operator Explanation op1 &amp; op2 The AND operator compares two bits and generates a result of 1 if both bits are 1; otherwise, it returns 0. op1 or op2 The OR operator compares two bits and generates a result of 1 if the bits are complementary; otherwise, it returns 0. op1^ op2 The EXCLUSIVE-OR operator compares two bits and returns 1 if either of the bits are 1 and it gives 0 if both bits are 0 or 1. ~op1 The COMPLEMENT operator is used to invert all of the bits of the operand. 1280 640 320 160 80 40 20 10 = AND OR XOR AND AND AND AND AND AND AND AND 1280 640 320 160 80 40 20 10 = = = = = = = = = 1280 640 320 160 80 40 20 10 = 0",
    "url": "http://localhost:4000/docs/binary2.html",
    "relUrl": "/docs/binary2.html"
  },
  "6": {
    "id": "6",
    "title": "Boolean Algebra",
    "content": "Boolean Algebra Introduction Rule in Boolean Algebra Boolean Laws AND law OR law INVERSION law Commutative law Associative law Distributive law DeMorgan’s Theorem Introduction Boolean Algebra is used to analyze and simplify the digital (logic) circuits. It uses only the binary numbers i.e. 0 and 1. It is also called as Binary Algebra or logical Algebra. Boolean algebra was invented by George Boole in 1854. Rule in Boolean Algebra Following are the important rules used in Boolean algebra. Variable used can have only two values. Binary 1 for HIGH and Binary 0 for LOW. Complement of a variable is represented by an overbar (-) or (!). Thus, complement of variable B is represented as B Bar. Thus if B = 0 then !B = 1 and B = 1 then !B = 0. ORing of the variables is represented by a plus (+) sign between them. For example ORing of A, B, C is represented as A + B + C. Logical ANDing of the two or more variable is represented by writing a dot between them such as A.B.C. Sometime the dot may be omitted like ABC. Boolean Laws There are six types of Boolean Laws. AND law These laws use the AND operation. Therefore they are called as AND laws. Example: 1. A.0 = 0 1. A.1 = A 1. A.A = A 1. A.!A = 0 OR law These laws use the OR operation. Therefore they are called as OR laws. Example: 1. A+0 = A 2. A+1 = 1 3. A+A = A 4. A+!A = 1 INVERSION law This law uses the NOT operation. The inversion law states that double inversion of a variable results in the original variable itself. Example: !!A = A Commutative law Any binary operation which satisfies the following expression is referred to as commutative operation. Example: A.B = B.A A+B = B+A Associative law This law states that the order in which the logic operations are performed is irrelevant as their effect is the same. Example: (A.B).C = A.(B.C) (A+B)+C = A+(B+C) Distributive law Distributive law states the following condition. Example: A.(B+C) = A.B + A.C DeMorgan’s Theorem This theorem is useful in finding the complement of Boolean function. It states that the complement of logical OR of at least two Boolean variables is equal to the logical AND of each complemented variable. DeMorgan’s theorem with 2 Boolean variables x and y can be represented as (x + y)’ = x’.y’ The dual of the above Boolean function is (x.y)’ = x’ + y’ Therefore, the complement of logical AND of two Boolean variables is equal to the logical OR of each complemented variable. Similarly, we can apply DeMorgan’s theorem for more than 2 Boolean variables also. AND OR XOR NOT =",
    "url": "http://localhost:4000/docs/bool.html",
    "relUrl": "/docs/bool.html"
  },
  "7": {
    "id": "7",
    "title": "Boolean Function",
    "content": "Boolean Function Introduction Truth Table Formation Sum of Product Expressions (SOP) Example Algebraic Simplification Undefined Input &amp; Don’t Cares Let us try this interactive truth table generator for better understanding Methods to simplify the boolean function Introduction Boolean algebra deals with binary variables and logic operation. A Boolean Function is described by an algebraic expression called Boolean expression which consists of binary variables, the constants 0 and 1, and the logic operation symbols. Consider the following example. Example: F(A,B,C,D) = A + BC + !(ADC) Boolean Function Boolean expression Here the left side of the equation represents the output Y. So we can state Y = A + BC + !(ADC) Boolean Function Boolean expression Truth Table Formation A truth table represents a table having all combinations of inputs and their corresponding result. It is possible to convert the switching equation into a truth table. For example, consider the following switching equation. A B C F 0 0 1 0 0 1 0 0 0 1 1 0 0 1 1 1 1 0 1 1 1 1 0 1 1 1 1 1 1 1 1 1 Sum of Product Expressions (SOP) Let’s consider a more complicated expression F(ABCD)= AB&#39;C+BD+CD+D and generate its truth table: F(AB’C+BD+CD+D) A B C D 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 1 0 0 1 1 0 0 1 0 0 1 0 1 0 1 0 0 1 1 0 1 0 1 1 1 0 1 0 0 0 1 1 0 0 1 0 1 0 1 0 1 1 0 1 1 1 1 1 0 0 1 1 1 0 1 0 1 1 1 0 1 1 1 1 1 This example was definately more involved than the previous expressions. An interesting observation is that we are doing a sum of product evaluation, that is, AB&#39;C+BD+CD+D is a sum of products. The significance of a sum of product is that when we are doing + we are in fact invoking the OR operator. Moreover, the OR operator returns true so long as any one of its arguements returns true. Therefore, if any of the terms in the sum of product (SOP) expressions is true, then we know that the final expression is true for certain. Example Algebraic Simplification Let’s simplify our expression from the previous truth table example. We can apply ordinary algebra tricks such as factoring. Remember that the + operator invokes the OR gate, and that true or x always returns true regardless of x (as shown in our first truth table). AB&#39;C+BD+CD+D // Initial expression AB&#39;C+BD+D(C+1) // Factor out a D AB&#39;C+BD+D // Since (C+1) is always true, as C OR true is always true AB&#39;C+D(B+1) // Factor out a D again AB&#39;C+D // Since (B+1) is always true, as B OR true is always true =AB&#39;C+D // Final expression As an exercise to the reader, complete the truth table to show that they are logically equivalent. Undefined Input &amp; Don’t Cares The definition of a “Don’t care” is a combination of input values that is not known, and could be either 0 or 1. For the purposes of variable simplification, we would choose the greedy approach of picking between {0, 1} such that the simplified expression has less terms. Let’s consider the following truth-table: F(AB) A B 1 0 0 1 0 1 ? 1 0 1 1 1 We observe that we have a Don’t care. Let’s observe the differences in cases for F(1,0): Case #1: F(1, 0) = 0 =&gt; F(AB) = A&#39;B&#39; + A&#39;B + AB Case #2: F(1, 0) = 1 =&gt; F(AB) = A&#39;B&#39; + A&#39;B + AB&#39; + AB Simplifying the cases... F(AB) = A&#39;B&#39; + A&#39;B + AB = A&#39;(B&#39; + B) + AB = A&#39; + AB F(AB) = A&#39;B&#39; + A&#39;B + AB&#39; + AB = A&#39;(B&#39; + B) + A (B&#39; + B) = A&#39; + A = 1 We can clearly see, if we set F(1, 0) = 1, we get a true value for any input. Therefore, for the purposes of variable simplification, we can simply let F(1, 0) = 1 thus implying F(AB) = 1. Let us try this interactive truth table generator for better understanding Truth Table Generator Enter your boolean logic expression in the following format: AND = AB&emsp; OR = A+B&emsp; NOT = A&#39; NAND = (AB)&#39; NOR = (A+B)&#39; This app requires JavaScript to run. Please enable JavaScript and refresh this page. Methods to simplify the boolean function The methods used for simplifying the Boolean function are as follows − Karnaugh-map or K-map NAND gate method.",
    "url": "http://localhost:4000/docs/bool2.html",
    "relUrl": "/docs/bool2.html"
  },
  "8": {
    "id": "8",
    "title": "Clock Signal and Triggering",
    "content": "Clock Signal and Triggering In this section, let us discuss about the clock signal and types of triggering one by one. Clock signal Types of Triggering Level triggering Edge triggering Clock signal Clock signal is a periodic signal and its ON time and OFF time need not be the same. We can represent the clock signal as a square wave, when both its ON time and OFF time are same. This clock signal is shown in the following figure. n the above figure, square wave is considered as clock signal. This signal stays at logic High (5V) for some time and stays at logic Low (0V) for equal amount of time. This pattern repeats with some time period. In this case, the time period will be equal to either twice of ON time or twice of OFF time. We can represent the clock signal as train of pulses, when ON time and OFF time are not same. This clock signal is shown in the following figure. In the above figure, train of pulses is considered as clock signal. This signal stays at logic High (5V) for some time and stays at logic Low (0V) for some other time. This pattern repeats with some time period. In this case, the time period will be equal to sum of ON time and OFF time. The reciprocal of the time period of clock signal is known as the frequency of the clock signal. All sequential circuits are operated with clock signal. So, the frequency at which the sequential circuits can be operated accordingly the clock signal frequency has to be chosen. Types of Triggering Following are the two possible types of triggering that are used in sequential circuits. Level triggering Edge triggering Level triggering There are two levels, namely logic High and logic Low in clock signal. Following are the two types of level triggering. Positive level triggering Negative level triggering If the sequential circuit is operated with the clock signal when it is in Logic High, then that type of triggering is known as Positive level triggering. It is highlighted in below figure. If the sequential circuit is operated with the clock signal when it is in Logic Low, then that type of triggering is known as Negative level triggering. It is highlighted in the following figure. Edge triggering There are two types of transitions that occur in clock signal. That means, the clock signal transitions either from Logic Low to Logic High or Logic High to Logic Low. Following are the two types of edge triggering based on the transitions of clock signal. Positive edge triggering Negative edge triggering If the sequential circuit is operated with the clock signal that is transitioning from Logic Low to Logic High, then that type of triggering is known as Positive edge triggering. It is also called as rising edge triggering. It is shown in the following figure. If the sequential circuit is operated with the clock signal that is transitioning from Logic High to Logic Low, then that type of triggering is known as Negative edge triggering. It is also called as falling edge triggering. It is shown in the following figure.",
    "url": "http://localhost:4000/docs/clock.html",
    "relUrl": "/docs/clock.html"
  },
  "9": {
    "id": "9",
    "title": "Combinational Logic",
    "content": "Digital Combinational Circuits Combinational circuits consist of Logic gates. These circuits operate with binary values. The output(s) of combinational circuit depends on the combination of present inputs. The following figure shows the block diagram of combinational circuit. This combinational circuit has ‘n’ input variables and ‘m’ outputs. Each combination of input variables will affect the output(s). Design procedure of Combinational circuits Find the required number of input variables and outputs from given specifications. Formulate the Truth table. If there are ‘n’ input variables, then there will be 2n possible combinations. For each combination of input, find the output values. Find the Boolean expressions for each output. If necessary, simplify those expressions. Implement the above Boolean expressions corresponding to each output by using Logic gates. We’re going to elaborate few important combinational circuits as follows.",
    "url": "http://localhost:4000/docs/combinational",
    "relUrl": "/docs/combinational"
  },
  "10": {
    "id": "10",
    "title": "Digital Counters",
    "content": "Digital Sequential Circuits Counter is a sequential circuit. A digital circuit which is used for a counting pulses is known counter. Counter is the widest application of flip-flops. It is a group of flip-flops with a clock signal applied. Counters are of two types. Asynchronous or ripple counters Logical Diagram Operation Truth Table Synchronous counters 2-bit Synchronous up counter Logical Diagram Operation Asynchronous or ripple counters The logic diagram of a 2-bit ripple up counter is shown in figure. The toggle (T) flip-flop are being used. But we can use the JK flip-flop also with J and K connected permanently to logic 1. External clock is applied to the clock input of flip-flop A and QA output is applied to the clock input of the next flip-flop i.e. FF-B. Logical Diagram Operation Condition Operation Initially let both the FFs be in the reset state QBQA = 00 initially. After 1st negative clock edge As soon as the first negative clock edge is applied, FF-A will toggle and QA will be equal to 1.QA is connected to clock input of FF-B. Since QA has changed from 0 to 1, it is treated as the positive clock edge by FF-B. There is no change in QB because FF-B is a negative edge triggered FF.QBQA = 01 after the first clock pulse. After 2nd negative clock edge On the arrival of second negative clock edge, FF-A toggles again and QA = 0.The change in QA acts as a negative clock edge for FF-B. So it will also toggle, and QB will be 1.QBQA = 10 after the second clock pulse. After 3rd negative clock edge On the arrival of 3rd negative clock edge, FF-A toggles again and QA become 1 from 0.Since this is a positive going change, FF-B does not respond to it and remains inactive. So QB does not change and continues to be equal to 1.QBQA = 11 after the third clock pulse. After 4th negative clock edge On the arrival of 4th negative clock edge, FF-A toggles again and QA becomes 1 from 0.This negative change in QA acts as clock pulse for FF-B. Hence it toggles to change QB from 1 to 0.QBQA = 00 after the fourth clock pulse. Truth Table Synchronous counters If the “clock” pulses are applied to all the flip-flops in a counter simultaneously, then such a counter is called as synchronous counter. 2-bit Synchronous up counter he JA and KA inputs of FF-A are tied to logic 1. So FF-A will work as a toggle flip-flop. The JB and KB inputs are connected to QA. Logical Diagram Operation Condition Operation Initially let both the FFs be in the reset state QBQA = 00 initially. After 1st negative clock edge As soon as the first negative clock edge is applied, FF-A will toggle and QA will change from 0 to 1.But at the instant of application of negative clock edge, QA , JB = KB = 0. Hence FF-B will not change its state. So QB will remain 0.QBQA = 01 after the first clock pulse. After 2nd negative clock edge On the arrival of second negative clock edge, FF-A toggles again and QA changes from 1 to 0.But at this instant QA was 1. So JB = KB= 1 and FF-B will toggle. Hence QB changes from 0 to 1.QBQA = 10 after the second clock pulse. After 3rd negative clock edge On application of the third falling clock edge, FF-A will toggle from 0 to 1 but there is no change of state for FF-B.QBQA = 11 after the third clock pulse. After 4th negative clock edge On application of the next clock pulse, QA will change from 1 to 0 as QB will also change from 1 to 0.QBQA = 00 after the fourth clock pulse.",
    "url": "http://localhost:4000/docs/counter.html",
    "relUrl": "/docs/counter.html"
  },
  "11": {
    "id": "11",
    "title": "D Flip-Flop",
    "content": "D Flip-Flop D flip-flop operates with only positive clock transitions or negative clock transitions. Whereas, D latch operates with enable signal. That means, the output of D flip-flop is insensitive to the changes in the input, D except for active transition of the clock signal. The circuit diagram of D flip-flop is shown in the following figure. This circuit has single input D and two outputs Q(t) &amp; Q(t)’. The operation of D flip-flop is similar to D Latch. But, this flip-flop affects the outputs only when positive transition of the clock signal is applied instead of active enable. State table of D flip-flop. D Q(t+1) 0 0 1 1 Therefore, D flip-flop always Hold the information, which is available on data input, D of earlier positive transition of clock signal. From the above state table, we can directly write the next state equation as Q(t + 1) = D Next state of D flip-flop is always equal to data input, D for every positive transition of the clock signal. Hence, D flip-flops can be used in registers, shift registers and some of the counters.",
    "url": "http://localhost:4000/docs/flipflop/d_flipflop.html",
    "relUrl": "/docs/flipflop/d_flipflop.html"
  },
  "12": {
    "id": "12",
    "title": "Decoder",
    "content": "Multiplexers A decoder is a combinational circuit. It has n input and to a maximum m = 2n outputs. Decoder is identical to a demultiplexer without any data input. It performs operations which are exactly opposite to those of an encoder. Block Diagram Examples of Decoders are following. Code converters BCD to seven segment decoders Nixie tube decoders Relay actuator 2 to 4 Line Decoder The block diagram of 2 to 4 line decoder is shown in the fig. A and B are the two inputs where D through D are the four outputs. Truth table explains the operations of a decoder. It shows that each output is 1 for only a specific combination of inputs. Block Diagram Truth Table Logic Circuit",
    "url": "http://localhost:4000/docs/MSI/decoder.html",
    "relUrl": "/docs/MSI/decoder.html"
  },
  "13": {
    "id": "13",
    "title": "Demultiplexers",
    "content": "Demultiplexers A demultiplexer performs the reverse operation of a multiplexer i.e. it receives one input and distributes it over several outputs. It has only one input, n outputs, m select input. At a time only one output line is selected by the select lines and the input is transmitted to the selected output line. A de-multiplexer is equivalent to a single pole multiple way switch as shown in fig. Demultiplexers in multiple variations. 1 : 2 demultiplexer 1 : 4 demultiplexer 1 : 16 demultiplexer 1 : 32 demultiplexer Block Diagram Truth Table",
    "url": "http://localhost:4000/docs/MSI/demux.html",
    "relUrl": "/docs/MSI/demux.html"
  },
  "14": {
    "id": "14",
    "title": "Encoder",
    "content": "Encoder Encoder is a combinational circuit which is designed to perform the inverse operation of the decoder. An encoder has n number of input lines and m number of output lines. An encoder produces an m bit binary code corresponding to the digital input number. The encoder accepts an n input digital word and converts it into an m bit another digital word. Block Diagram Examples of Decoders are following. Priority encoders Decimal to BCD encoder Octal to binary encoder Hexadecimal to binary encoder Priority Encoder This is a special type of encoder. Priority is given to the input lines. If two or more input line are 1 at the same time, then the input line with highest priority will be considered. There are four input D0, D1, D2, D3 and two output Y0, Y1. Out of the four input D3 has the highest priority and D0 has the lowest priority. That means if D3 = 1 then Y1 Y1 = 11 irrespective of the other inputs. Similarly if D3 = 0 and D2 = 1 then Y1 Y0 = 10 irrespective of the other inputs. Block Diagram Truth Table Logic Circuit",
    "url": "http://localhost:4000/docs/MSI/encoder.html",
    "relUrl": "/docs/MSI/encoder.html"
  },
  "15": {
    "id": "15",
    "title": "Finite State Machines",
    "content": "Introduction Mealy State Machine Moore State Machine Introduction We know that synchronous sequential circuits change (affect) their states for every positive (or negative) transition of the clock signal based on the input. So, this behavior of synchronous sequential circuits can be represented in the graphical form and it is known as state diagram. A synchronous sequential circuit is also called as Finite State Machine (FSM), if it has finite number of states. There are two types of FSMs. Mealy State Machine Moore State Machine Now, let us discuss about these two state machines one by one. Mealy State Machine A Finite State Machine is said to be Mealy state machine, if outputs depend on both present inputs &amp; present states. The block diagram of Mealy state machine is shown in the following figure. As shown in figure, there are two parts present in Mealy state machine. Those are combinational logic and memory. Memory is useful to provide some or part of previous outputs (present states) as inputs of combinational logic. So, based on the present inputs and present states, the Mealy state machine produces outputs. Therefore, the outputs will be valid only at positive (or negative) transition of the clock signal. The state diagram of Mealy state machine is shown in the following figure. In the above figure, there are three states, namely A, B &amp; C. These states are labelled inside the circles &amp; each circle corresponds to one state. Transitions between these states are represented with directed lines. Here, 0 / 0, 1 / 0 &amp; 1 / 1 denotes input / output. In the above figure, there are two transitions from each state based on the value of input, x. In general, the number of states required in Mealy state machine is less than or equal to the number of states required in Moore state machine. There is an equivalent Moore state machine for each Mealy state machine. Moore State Machine A Finite State Machine is said to be Moore state machine, if outputs depend only on present states. The block diagram of Moore state machine is shown in the following figure. As shown in figure, there are two parts present in Moore state machine. Those are combinational logic and memory. In this case, the present inputs and present states determine the next states. So, based on next states, Moore state machine produces the outputs. Therefore, the outputs will be valid only after transition of the state. The state diagram of Moore state machine is shown in the following figure. In the above figure, there are four states, namely A, B, C &amp; D. These states and the respective outputs are labelled inside the circles. Here, only the input value is labeled on each transition. In the above figure, there are two transitions from each state based on the value of input, x. In general, the number of states required in Moore state machine is more than or equal to the number of states required in Mealy state machine. There is an equivalent Mealy state machine for each Moore state machine. So, based on the requirement we can use one of them.",
    "url": "http://localhost:4000/docs/finitestatemachine.html",
    "relUrl": "/docs/finitestatemachine.html"
  },
  "16": {
    "id": "16",
    "title": "Flip-Flops",
    "content": "Flip-Flops In previous module, we discussed about Latches. Those are the basic building blocks of flip-flops. We can implement flip-flops in two methods. In first method, cascade two latches in such a way that the first latch is enabled for every positive clock pulse and second latch is enabled for every negative clock pulse. So that the combination of these two latches become a flip-flop. In second module, we can directly implement the flip-flop, which is edge sensitive. In this module, let us discuss the following flip-flops using second method. Conclusion In this module, we will implemented various flip-flops by providing the cross coupling between NOR gates. Similarly, you can implement these flip-flops by using NAND gates.",
    "url": "http://localhost:4000/docs/flipflop",
    "relUrl": "/docs/flipflop"
  },
  "17": {
    "id": "17",
    "title": "Interactive FSM",
    "content": "Interactive FSM Finite State Machines",
    "url": "http://localhost:4000/docs/fsm_interactive.html",
    "relUrl": "/docs/fsm_interactive.html"
  },
  "18": {
    "id": "18",
    "title": "Full Adder",
    "content": "Full Adder Full adder is developed to overcome the drawback of Half Adder circuit. It can add two one-bit numbers A and B, and carry c. The full adder is a three input and two output combinational circuit. Block Diagram Truth Table Circuit Diagram Full adder from 2 Half Adder Ripple Carry Adder",
    "url": "http://localhost:4000/docs/Combinational/full_adder.html",
    "relUrl": "/docs/Combinational/full_adder.html"
  },
  "19": {
    "id": "19",
    "title": "Full Subtractors",
    "content": "Full Subtractors The disadvantage of a half subtractor is overcome by full subtractor. The full subtractor is a combinational circuit with three inputs A,B,C and two output D and C’. A is the ‘minuend’, B is ‘subtrahend’, C is the ‘borrow’ produced by the previous stage, D is the difference output and C’ is the borrow output. Truth Table Circuit Diagram",
    "url": "http://localhost:4000/docs/Combinational/full_sub.html",
    "relUrl": "/docs/Combinational/full_sub.html"
  },
  "20": {
    "id": "20",
    "title": "Gates",
    "content": "Logic Gates Introduction NOT gate AND gate OR gate NAND gate NOR gate XOR gate Introduction Logic gates are the basic building blocks of any digital system. It is an electronic circuit having one or more than one input and only one output. The relationship between the input and the output is based on a certain logic. Based on this, logic gates are named as AND gate, OR gate, NOT gate etc. NOT gate The NOT gate is also known as an inverter because the output is the exact opposite of the input. It has one input and one output. The two possibilities are written out in the table below. Tables listing all logical possibilities like this are known as truth tables. Input1 Input 2 0 1 1 0 AND gate The AND gate has two inputs and one output. The output is 1 if both inputs are 1, and for all other cases the output is 0. Input1 Input 2 output 0 0 0 0 1 0 1 0 0 1 1 1 OR gate The OR gate has two inputs and one output. If at least one of the inputs is 1, then the output will be 1. If neither input is 1, the output will be 0. Input1 Input 2 output 0 0 0 0 1 1 1 0 1 1 1 1 NAND gate The NAND gate behaves in the opposite fashion to and AND gate. You can think of it as an AND gate followed immediately by a NOT gate. Its output is 0 when the two inputs are 1, and for all other cases, its output is 0. The name NAND comes from joining NOT and AND. The symbol for NAND is the same as that for AND except for the addition of a small circle on the right side. Input1 Input 2 output 0 0 1 0 1 1 1 0 1 1 1 0 NOR gate The NAND gate behaves in the opposite fashion to and AND gate. You can think of it as an AND gate followed immediately by a NOT gate. Its output is 0 when the two inputs are 1, and for all other cases, its output is 0. The name NAND comes from joining NOT and AND. The symbol for NAND is the same as that for AND except for the addition of a small circle on the right side. Input1 Input 2 output 0 0 1 0 1 0 1 0 0 1 1 0 XOR gate The NAND gate behaves in the opposite fashion to and AND gate. You can think of it as an AND gate followed immediately by a NOT gate. Its output is 0 when the two inputs are 1, and for all other cases, its output is 0. The name NAND comes from joining NOT and AND. The symbol for NAND is the same as that for AND except for the addition of a small circle on the right side. Input1 Input 2 output 0 0 0 0 1 1 1 0 1 1 1 0",
    "url": "http://localhost:4000/docs/gates.html",
    "relUrl": "/docs/gates.html"
  },
  "21": {
    "id": "21",
    "title": "Interactive Gates",
    "content": "Interactive Logic Gates You can also click/tap a symbol to copy it and then click/tap to paste it into the box. Two-Way Light Switch In your house you probabably have a light with more than one switch - e.g. landing lights often have switches upstairs and downstairs. Add the correct logic gate to the circuit and see if you can get this light work to work in the same way. You can click on Upstairs and Downstairs switches to change them. Upstairs Downstairs Security Light You can buy security lights that come on only when it&#39;s dark and they sense some movement. Add the correct logic gate to the circuit and see if you can get it to work (you can click on Darkness and Movement to change them). Darkness Movement Unfortunately your screen is too small to display this page correctly. If you are using a tablet or phone you could try turning it round to landscape orientation.",
    "url": "http://localhost:4000/docs/gatesi.html",
    "relUrl": "/docs/gatesi.html"
  },
  "22": {
    "id": "22",
    "title": "Half Adder",
    "content": "Half Adder Half adder is a combinational logic circuit with two inputs and two outputs. The half adder circuit is designed to add two single bit binary number A and B. It is the basic building block for addition of two single bit numbers. This circuit has two outputs carry and sum. Block Diagram Truth Table Circuit Diagram",
    "url": "http://localhost:4000/docs/Combinational/half_adder.html",
    "relUrl": "/docs/Combinational/half_adder.html"
  },
  "23": {
    "id": "23",
    "title": "Half Subtractors",
    "content": "Half Subtractors Half subtractor is a combination circuit with two inputs and two outputs (difference and borrow). It produces the difference between the two binary bits at the input and also produces an output (Borrow) to indicate if a 1 has been borrowed. In the subtraction (A-B), A is called as Minuend bit and B is called as Subtrahend bit. Truth Table Circuit Diagram",
    "url": "http://localhost:4000/docs/Combinational/half_sub.html",
    "relUrl": "/docs/Combinational/half_sub.html"
  },
  "24": {
    "id": "24",
    "title": "Home",
    "content": "Interactive-Book Learn Digital Logic Design easily. Computer Logical Organization refers to the level of abstraction above the digital logic level, but below the operating system level. At this level, the major components are functional units or subsystems that correspond to specific pieces of hardware built from the lower level building blocks. This interactive book gives a complete understanding on Computer Logical Organization starting from basic computer overview till its advanced architecture. It is meant to provide the readers to know how to analyze and implement the combinational circuits and sequential circuits. Based on the requirement, we can use either combinational circuit or sequential circuit or combination of both. After completing this book, you will be able to learn the type of digital circuit, which is suitable for specific application. Audience This reference has been prepared for the students pursing either Bachelors or Masters in Computer Science/Electronics to help them understand the basic-to-advanced concepts related to Computer Logical Organization.It is also meant for thosewho are aspiring to learn the concepts of digital circuits. Digital circuits contain a set of Logic gates and these can be operated with binary values, 0 and 1. Prerequisites Before you start proceeding with this Book, I’m making an assumption that you are already aware of basic computer concepts like what is keyboard, mouse, monitor, input, output, primary memory, secondary memory, etc. A basic idea regarding the initial concepts of Digital Electronics is enough to understand the topics covered in this tutorial. About the project Interactive-Book is © 2019 by Aman Singla.",
    "url": "http://localhost:4000/",
    "relUrl": "/"
  },
  "25": {
    "id": "25",
    "title": "JK Flip-Flop",
    "content": "JK Flip-Flop JK flip-flop is the modified version of SR flip-flop. It operates with only positive clock transitions or negative clock transitions. The circuit diagram of JK flip-flop is shown in the following figure. This circuit has two inputs J &amp; K and two outputs Q(t) &amp; Q(t)’. The operation of JK flip-flop is similar to SR flip-flop. Here, we considered the inputs of SR flip-flop as S = J Q(t)’ and R = KQ(t) in order to utilize the modified SR flip-flop for 4 combinations of inputs. State table of SR flip-flop. J K Q(t+1) 0 0 Q(t) 0 1 0 1 0 1 1 1 Q(t)’ Here, Q(t) &amp; Q(t + 1) are present state &amp; next state respectively. So, JK flip-flop can be used for one of these four functions such as Hold, Reset, Set &amp; Complement of present state based on the input conditions, when positive transition of clock signal is applied. Characteristic table of SR flip-flop. J K Q(t) Q(t+1) 0 0 0 0 0 0 1 1 0 1 0 0 0 1 1 0 1 0 0 1 1 0 1 1 1 1 0 1 1 1 1 0 By using three variable K-Map, we can get the simplified expression for next state, Q(t + 1). The three variable K-Map for next state, Q(t + 1) is shown in the following figure. The maximum possible groupings of adjacent ones are already shown in the figure. Therefore, the simplified expression for next state Q(t+1) is Q(t+1)=JQ(t)′+K′Q(t)",
    "url": "http://localhost:4000/docs/flipflop/jk_flipflop.html",
    "relUrl": "/docs/flipflop/jk_flipflop.html"
  },
  "26": {
    "id": "26",
    "title": "Interactive Karnaugh Map",
    "content": "Interactive Karnaugh Map This interactive Karnaugh map represents the function Y&nbsp;=&nbsp;f(xn,...,x1, x0). You can manually edit this function by clicking on the cells of the map. Alternatively, you can generate a random function by pressing the &quot;Random example&quot; button. Random example Reset Number of input variables: 1 2 3 4 5 6 7 8 &nbsp;&nbsp;&nbsp;&nbsp; Allow Don’t-Care: no Yes &nbsp;&nbsp;&nbsp;&nbsp; Hide result: no Yes",
    "url": "http://localhost:4000/docs/kmapi.html",
    "relUrl": "/docs/kmapi.html"
  },
  "27": {
    "id": "27",
    "title": "Latches",
    "content": "Latches There are two types of memory elements based on the type of triggering that is suitable to operate it. Latches Flip-flops Latches operate with enable signal, which is level sensitive. Whereas, flip-flops are edge sensitive. We will discuss about flip-flops in next module. Now, let us discuss about SR Latch &amp; D Latch one by one. SR Latch D Latch SR Latch SR Latch is also called as Set Reset Latch. This latch affects the outputs as long as the enable, E is maintained at ‘1’. The circuit diagram of SR Latch is shown in the following figure. This circuit has two inputs S &amp; R and two outputs Q(t) &amp; Q(t)’. The upper NOR gate has two inputs R &amp; complement of present state, Q(t)’ and produces next state, Q(t+1) when enable, E is ‘1’. Similarly, the lower NOR gate has two inputs S &amp; present state, Q(t) and produces complement of next state, Q(t+1)’ when enable, E is ‘1’. We know that a 2-input NOR gate produces an output, which is the complement of another input when one of the input is ‘0’. Similarly, it produces ‘0’ output, when one of the input is ‘1’. If S = 1, then next state Q(t + 1) will be equal to ‘1’ irrespective of present state, Q(t) values. If R = 1, then next state Q(t + 1) will be equal to ‘0’ irrespective of present state, Q(t) values. At any time, only of those two inputs should be ‘1’. If both inputs are ‘1’, then the next state Q(t + 1) value is undefined. The following table shows the state table of SR latch. S R Q(t+1) 0 0 Q(t) 0 1 0 1 0 1 1 1 - Therefore, SR Latch performs three types of functions such as Hold, Set &amp; Reset based on the input conditions. D Latch There is one drawback of SR Latch. That is the next state value can’t be predicted when both the inputs S &amp; R are one. So, we can overcome this difficulty by D Latch. It is also called as Data Latch. The circuit diagram of D Latch is shown in the following figure. This circuit has single input D and two outputs Q(t) &amp; Q(t)’. D Latch is obtained from SR Latch by placing an inverter between S amp;&amp; R inputs and connect D input to S. That means we eliminated the combinations of S &amp; R are of same value. If D = 0 → S = 0 &amp; R = 1, then next state Q(t + 1) will be equal to ‘0’ irrespective of present state, Q(t) values. This is corresponding to the second row of SR Latch state table. If D = 1 → S = 1 &amp; R = 0, then next state Q(t + 1) will be equal to ‘1’ irrespective of present state, Q(t) values. This is corresponding to the third row of SR Latch state table. The following table shows the state table of D latch. D Q(t + 1) 0 0 1 1 Therefore, D Latch Hold the information that is available on data input, D. That means the output of D Latch is sensitive to the changes in the input, D as long as the enable is High. In this module, we implemented various Latches by providing the cross coupling between NOR gates. Similarly, you can implement these Latches using NAND gates.",
    "url": "http://localhost:4000/docs/latches.html",
    "relUrl": "/docs/latches.html"
  },
  "28": {
    "id": "28",
    "title": "K-Maps",
    "content": "K-Maps Introduction Enumeration and Gray Codes Simple Groupings Two Dimension Groupings Disjoint Groupings Overlapping Groupings Minimizing Group Count Introduction Karnaugh Maps are a way to visually display a boolean expression onto a 2D grid. We take the variables and bind them to an axis, and then enumerate through the possible combinations of input values that could occur for all those variables bounded to an axis (either horizontally or vertically). For example, we can display the following 2 variable Karnaugh Map: We have bounded to the vertical axis, the variable A, and we enumerate through the possible values for A (being {0, 1}). Similarily, we perform a similar operation for the B variable. Since we are using a 2 variable expression, we can bound one variable to each axis and the visualization works fine in a 2x2 matrix. Let’s instead look at a more involved example with 4 variables: We have now bounded the A and B variables to the vertical axis, while we bounded the C and D variables to the horizontal axis. We now enumarate through different combinations of the bounded variables for each axis in reflected binary code order (more on this in the following section). Lastly, we indicate on the matrix each true value by augmenting a 1 value. Enumeration and Gray Codes When enumerating through the variable input combinations for the binded axis, we take advantage of reflected binary code order, otherwise known as gray codes. If we observe carefully, we can notice that from one combination to another, we only vary by one bit. That is: ... 00 01 11 10 00 01 11 10 00 ... ^ ^ ^ ^ ^ ^ ^ ^ ^ Thus, we get this wrapping that allows us to switch by only one bit. This provides us the core for how Karnaugh Maps work. Simple Groupings The main idea for how Karnaugh Maps can be used to simplify expressions is to group pairs of 1 values that are adjacent, and exploit the fact that each one has only a bit difference from another. For the purpose of this example, let F(ABCD) = CELL. We start with the expression F(0000) = 1 and F(0001) = 1. However, notice that regardless of the value of the last bit, we still get 1. Hence, let’s take a look at the SOP expressions: F(ABCD) = A&#39;B&#39;C&#39;D&#39; + A&#39;B&#39;C&#39;D F(0000) = 1 F(0001) = 1 Since the last bit is the same, we can ignore the D value, thus: F(ABCD) = A&#39;B&#39;C&#39; We can confirm by simplifying algebraically: F(ABCD) = A&#39;B&#39;C&#39;D&#39; + A&#39;B&#39;C&#39;D = A&#39;B&#39;C&#39;(D&#39; + D) = A&#39;B&#39;C&#39; Therefore, the simplification is true. We can then extend this rule to work for rectangles and more! Two Dimension Groupings Extending the idea of isolating changing bits that retain a consistent value, we can then generalize this to work in a higher dimension. Consider the following example: Letting F(ABCD) = CELL: F(0000) = 1 F(0001) = 1 F(0100) = 1 F(0101) = 1 Observe that the bits do not change by one for all pairs of numbers, for example {0000, 0101} differ by two bits. However, we can take advantage of the fact that for any bit change horizontally or vertically, it’s irrelvant what that bit is. More concretely, take a look at the following example. 0000 0001 0100 0101 =&gt; A&#39;B&#39;C&#39;D&#39; + A&#39;B&#39;C&#39;D + A&#39;BC&#39;D&#39; + A&#39;BC&#39;D Regardless of the B variable, we still get true for all products in the SOP expression. This is bounded vertically: =&gt; A&#39;C&#39;D&#39; + A&#39;C&#39;D + A&#39;C&#39;D&#39; + A&#39;C&#39;D Regardless of the D variable, we still get true for all products in the SOP expression. This is bounded horizontally: =&gt; A&#39;C&#39; + A&#39;C&#39; + A&#39;C&#39; + A&#39;C&#39; =&gt; A&#39;C&#39; (1 + 1 + 1 + 1) =&gt; A&#39;C&#39; (1) =&gt; A&#39;C&#39; Since the differences in bits needs to generalize throughout a binding of an axis, you can only have a binding of size 2^n for a given axis. For example, 1x1, 1x2, 1x4, 2x2, 2x4, 4x4. Disjoint Groupings Consider the following example: The algorithm follows precisely as it did before, except that now the two groups are joined in the SOP expression. Letting F(ABCD) = CELL: F(0000) = 1 F(0001) = 1 F(1111) = 1 F(1011) = 1 This yields the following: A&#39;B&#39;C&#39;D&#39; + A&#39;B&#39;C&#39;D + ABCD + AB&#39;CD Breaking down the expression: (A&#39;B&#39;C&#39;D&#39; + A&#39;B&#39;C&#39;D) + (ABCD + AB&#39;CD) =&gt; (A&#39;B&#39;C&#39;(D + D&#39;)) + (ACD(B + B&#39;)) =&gt; (A&#39;B&#39;C&#39;) + (ACD) =&gt; A&#39;B&#39;C&#39; + ACD Clearly this is the exact same process as before, but iterated throughout all the disjoint sets. Overlapping Groupings Overlapping groupings become more complex, because there exist ambigious cases and sometimes what may appear to be a locally optimal solutuion is not a globally optimal solution. The general technique for evaluating for overlapping groups follows a greedy algorithm. Define an unvisited cell as a cell that has a value of 1 however it is currently not matched with a grouping yet. Iterate through all the cells, and once you find a cell with 1, if it is unvisited then find the largest possible square or rectangle such that each side length is a power of 2, where all the cells are 1 in its enclosed area. If there is a tie for size (ie, 1x4 vs 2x2), assign the one that is a square (this is by convention). Repeat this process for all remaining unvisited cells. Note: You can overlap the groupings with already visited nodes, but you never instantiate a new grouping unless the current node is unvisited. In this example, at F(0000), we can create a grouping of size 2 (because 2 is the largest possible grouping, 3 is not a power of 2). We then iterate through to F(0001), however F(0001) was already resolved to a grouping. For the latest active cell, F(0011) is not resolved to a grouping thus it’s unvisited. The largest possible grouping is also of size 2, thus we create another group. To resolve the groupings into an SOP expression, we iterate through the groups and identify changing bits: Group #1 =&gt; F(ABCD) = [0000, 0001] Group #2 =&gt; F(ABCD) = [0001, 0011] For Group #1: 0000 0001 ^ ^ F(ABCD) = A&#39;B&#39;C&#39;D&#39; + A&#39;B&#39;C&#39;D =&gt; A&#39;B&#39;C&#39;(D + D&#39;) =&gt; A&#39;B&#39;C&#39; For Group #2: 0001 0011 ^ ^ F(ABCD) = A&#39;B&#39;C&#39;D + A&#39;B&#39;CD =&gt; A&#39;B&#39;D(C&#39; + C) =&gt; A&#39;B&#39;D Now we add the two results: F(ABCD) = A&#39;B&#39;C&#39; + A&#39;B&#39;D =&gt; F(ABCD) = A&#39;B&#39;D + A&#39;B&#39;C&#39; (by commutative property) Minimizing Group Count The following example will ilustrate how the greedy approach may occasionally produce too many groups. Consider the following example: This grouping state is optimal. However, consider adding a 1 to F(1111). Following the previous algorithm, iterating top-bottom and left-right, when getting to F(0110), the algorithm can choose to make the largest grouping. However, there are two possible groupings: Candidate #1: F(ABCD) = [0011, 0010, 0111, 0110] Candidate #2: F(ABCD) = [0111, 0110, 1111, 1110] Both groupings have the same size, and are the same dimension. However, upon reaching F(1110), another grouping needs to be instantiated, in which case if the first candidate grouping was created then we made a group that was not neccessary increasing the size of our SOP expression. This illustrates the idea that this is a greedy algorithm, and does not always return the most simplified SOP expression. In later sections, algorithms illustrating a globally optimal algorithm will be discussed.",
    "url": "http://localhost:4000/docs/maps.html",
    "relUrl": "/docs/maps.html"
  },
  "29": {
    "id": "29",
    "title": "MSI Components",
    "content": "MSI Digital systems obtain binary-coded data and information that are continuously being operated on in some manner. Some of the operations include: Multiplexing Demultiplexing Decoding and Encoding All of these operations and others have been facilitated by the availability of numerous ICs in the MSI (medium-scale-integration) category. In this module, we will study many of the common types of MSI devices. For each type, we will start with a brief discussion of its basic operating principle and then introduce specific ICs. We then show how they can be used alone or in combination with other ICs in various applications.",
    "url": "http://localhost:4000/docs/msi",
    "relUrl": "/docs/msi"
  },
  "30": {
    "id": "30",
    "title": "Multiplexers",
    "content": "Multiplexers Multiplexer is a special type of combinational circuit. There are n-data inputs, one output and m select inputs with 2m = n. It is a digital circuit which selects one of the n data inputs and routes it to the output. The selection of one of the n inputs is done by the selected inputs. Depending on the digital code applied at the selected inputs, one out of n data sources is selected and transmitted to the single output Y. E is called the strobe or enable input which is useful for the cascading. It is generally an active low terminal that means it will perform the required operation when it is low. Block Diagram Multiplexers come in multiple variations 2 : 1 multiplexer 4 : 1 multiplexer 16 : 1 multiplexer 32 : 1 multiplexer Truth Table",
    "url": "http://localhost:4000/docs/MSI/mux.html",
    "relUrl": "/docs/MSI/mux.html"
  },
  "31": {
    "id": "31",
    "title": "Parallel Input Parallel Output",
    "content": "Parallel Input Parallel Output Introduction In this mode, the 4 bit binary input B0, B1, B2, B3 is applied to the data inputs D0, D1, D2, D3 respectively of the four flip-flops. As soon as a negative clock edge is applied, the input binary bits will be loaded into the flip-flops simultaneously. The loaded bits will appear simultaneously to the output side. Only clock pulse is essential to load all the bits. Block Diagram",
    "url": "http://localhost:4000/docs/registers/pp.html",
    "relUrl": "/docs/registers/pp.html"
  },
  "32": {
    "id": "32",
    "title": "Parallel Input Serial Output",
    "content": "Parallel Input Serial Output Introduction Data bits are entered in parallel fashion. The circuit shown below is a four bit parallel input serial output register. Output of previous Flip Flop is connected to the input of the next one via a combinational circuit. The binary input word B0, B1, B2, B3 is applied though the same combinational circuit. There are two modes in which this circuit can work namely - shift mode or load mode. Load mode When the shift/load bar line is low (0), the AND gate 2, 4 and 6 become active they will pass B1, B2, B3 bits to the corresponding flip-flops. On the low going edge of clock, the binary input B0, B1, B2, B3 will get loaded into the corresponding flip-flops. Thus parallel loading takes place. Shift mode When the shift/load bar line is low (1), the AND gate 2, 4 and 6 become inactive. Hence the parallel loading of the data becomes impossible. But the AND gate 1,3 and 5 become active. Therefore the shifting of data from left to right bit by bit on application of clock pulses. Thus the parallel in serial out operation takes place. Block Diagram",
    "url": "http://localhost:4000/docs/registers/ps.html",
    "relUrl": "/docs/registers/ps.html"
  },
  "33": {
    "id": "33",
    "title": "Digital Registers",
    "content": "Digital Registers Flip-flop is a 1 bit memory cell which can be used for storing the digital data. To increase the storage capacity in terms of number of bits, we have to use a group of flip-flop. Such a group of flip-flop is known as a Register. The n-bit register will consist of n number of flip-flop and it is capable of storing an n-bit word. The binary data in a register can be moved within the register from one flip-flop to another. The registers that allow such data transfers are called as shift registers. There are four mode of operations of a shift register.",
    "url": "http://localhost:4000/docs/register",
    "relUrl": "/docs/register"
  },
  "34": {
    "id": "34",
    "title": "Digital Sequential Circuits",
    "content": "Digital Sequential Circuits The combinational circuit does not use any memory. Hence the previous state of input does not have any effect on the present state of the circuit. But sequential circuit has memory so output can vary based on input. This type of circuits uses previous input, output, clock and a memory element. This sequential circuit contains a set of inputs and output(s). The output(s) of sequential circuit depends not only on the combination of present inputs but also on the previous output(s). Previous output is nothing but the present state. Therefore, sequential circuits contain combinational circuits along with memory (storage) elements. Some sequential circuits may not contain combinational circuits, but only memory elements. Following table shows the differences between combinational circuits and sequential circuits. Combinational Circuits Sequential Circuits Outputs depend only on present inputs. Outputs depend on both present inputs and present state. Feedback path is not present. Feedback path is present. Memory elements are not required. Memory elements are required. Clock signal is not required. Clock signal is required. Easy to design. Difficult to design. Types of Sequential Circuits Following are the two types of sequential circuits − Asynchronous sequential circuits Synchronous sequential circuits Asynchronous sequential circuits If some or all the outputs of a sequential circuit do not change (affect) with respect to active transition of clock signal, then that sequential circuit is called as Asynchronous sequential circuit. That means, all the outputs of asynchronous sequential circuits do not change (affect) at the same time. Therefore, most of the outputs of asynchronous sequential circuits are not in synchronous with either only positive edges or only negative edges of clock signal. Synchronous sequential circuits If all the outputs of a sequential circuit change (affect) with respect to active transition of clock signal, then that sequential circuit is called as Synchronous sequential circuit. That means, all the outputs of synchronous sequential circuits change (affect) at the same time. Therefore, the outputs of synchronous sequential circuits are in synchronous with either only positive edges or only negative edges of clock signal.",
    "url": "http://localhost:4000/docs/sequential.html",
    "relUrl": "/docs/sequential.html"
  },
  "35": {
    "id": "35",
    "title": "Serial Input Parallel Output",
    "content": "Serial Input Parallel Output Introduction In such types of operations, the data is entered serially and taken out in parallel fashion. Data is loaded bit by bit. The outputs are disabled as long as the data is loading. As soon as the data loading gets completed, all the flip-flops contain their required data, the outputs are enabled so that all the loaded data is made available over all the output lines at the same time. 4 clock cycles are required to load a four bit word. Hence the speed of operation of SIPO mode is same as that of SISO mode. Block Diagram",
    "url": "http://localhost:4000/docs/registers/sp.html",
    "relUrl": "/docs/registers/sp.html"
  },
  "36": {
    "id": "36",
    "title": "SR Flip-Flop",
    "content": "SR Flip-Flop SR flip-flop operates with only positive clock transitions or negative clock transitions. Whereas, SR latch operates with enable signal. The circuit diagram of SR flip-flop is shown in the following figure. his circuit has two inputs S &amp; R and two outputs Q(t) &amp; Q(t)’. The operation of SR flipflop is similar to SR Latch. But, this flip-flop affects the outputs only when positive transition of the clock signal is applied instead of active enable. State table of SR flip-flop. S R Q(t+1) 0 0 Q(t) 0 1 0 1 0 1 1 1 - Here, Q(t) &amp; Q(t + 1) are present state &amp; next state respectively. So, SR flip-flop can be used for one of these three functions such as Hold, Reset &amp; Set based on the input conditions, when positive transition of clock signal is applied. Characteristic table of SR flip-flop. Therefore, SR Latch performs three types of functions such as Hold, Set &amp; Reset based on the input conditions. S R Q(t) Q(t+1) 0 0 0 0 0 0 1 1 0 1 0 0 0 1 1 0 1 0 0 1 1 0 1 1 1 1 0 x 1 1 1 x By using three variable K-Map, we can get the simplified expression for next state, Q(t + 1). The three variable K-Map for next state, Q(t + 1) is shown in the following figure. The maximum possible groupings of adjacent ones are already shown in the figure. Therefore, the simplified expression for next state Q(t + 1) is Q(t+1)=S+R′Q(t)",
    "url": "http://localhost:4000/docs/flipflop/sr_flipflop.html",
    "relUrl": "/docs/flipflop/sr_flipflop.html"
  },
  "37": {
    "id": "37",
    "title": "Serial Input Serial Output",
    "content": "Serial Input Serial Output Introduction Block Diagram Operation Truth Table Waveforms Introduction Let all the flip-flop be initially in the reset condition i.e. Q3 = Q2 = Q1 = Q0 = 0. If an entry of a four bit binary number 1 1 1 1 is made into the register, this number should be applied to Din bit with the LSB bit applied first. The D input of FF-3 i.e. D3 is connected to serial data input Din. Output of FF-3 i.e. Q3 is connected to the input of the next flip-flop i.e. D2 and so on. Block Diagram Operation Before application of clock signal, let Q3 Q2 Q1 Q0 = 0000 and apply LSB bit of the number to be entered to Din. So Din = D3 = 1. Apply the clock. On the first falling edge of clock, the FF-3 is set, and stored word in the register is Q3 Q2 Q1 Q0 = 1000. Apply the next bit to Din. So Din = 1. As soon as the next negative edge of the clock hits, FF-2 will set and the stored word change to Q3 Q2 Q1 Q0 = 1100. Apply the next bit to be stored i.e. 1 to Din. Apply the clock pulse. As soon as the third negative clock edge hits, FF-1 will be set and output will be modified to Q3 Q2 Q1 Q0 = 1110. Similarly with Din = 1 and with the fourth negative clock edge arriving, the stored word in the register is Q3 Q2 Q1 Q0 = 1111. Truth Table Waveforms",
    "url": "http://localhost:4000/docs/registers/ss.html",
    "relUrl": "/docs/registers/ss.html"
  },
  "38": {
    "id": "38",
    "title": "T Flip-Flop",
    "content": "T Flip-Flop T flip-flop is the simplified version of JK flip-flop. It is obtained by connecting the same input ‘T’ to both inputs of JK flip-flop. It operates with only positive clock transitions or negative clock transitions. The circuit diagram of T flip-flop is shown in the following figure. This circuit has single input T and two outputs Q(t) &amp; Q(t)’. The operation of T flip-flop is same as that of JK flip-flop. Here, we considered the inputs of JK flip-flop as J = T and K = T in order to utilize the modified JK flip-flop for 2 combinations of inputs. So, we eliminated the other two combinations of J &amp; K, for which those two values are complement to each other in T flip-flop. State table of T flip-flop. D Q(t+1) 0 Q(t) 1 Q(t)’ Here, Q(t) &amp; Q(t + 1) are present state &amp; next state respectively. So, T flip-flop can be used for one of these two functions such as Hold, &amp; Complement of present state based on the input conditions, when positive transition of clock signal is applied. Characteristic table of T flip-flop. T Q(t) Q(t + 1) 0 0 0 0 1 1 1 0 1 1 1 0 From the above characteristic table, we can directly write the next state equation as Q(t+1)=T′Q(t)+TQ(t)′ ⇒ Q(t+1)=T⊕Q(t) The output of T flip-flop always toggles for every positive transition of the clock signal, when input T remains at logic High (1). Hence, T flip-flop can be used in counters.",
    "url": "http://localhost:4000/docs/flipflop/t_flipflop.html",
    "relUrl": "/docs/flipflop/t_flipflop.html"
  }
  
}
