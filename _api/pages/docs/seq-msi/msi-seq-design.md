{
  "name": "msi-seq-design.md",
  "path": "docs/seq-msi/msi-seq-design.md",
  "relative_path": "docs/seq-msi/msi-seq-design.md",
  "layout": "circuitverse",
  "title": "MSI based design",
  "nav_order": "l1s000",
  "cvib_level": "medium",
  "parent": "Sequential MSI",
  "has_children": false,
  "content": "<h1 class=\"no_toc\" id=\"msi-based-design\">MSI based design</h1>\n\n<h2 class=\"no_toc text-delta\" id=\"table-of-contents\">Table of contents</h2>\n\n<ol id=\"markdown-toc\">\n  <li><a href=\"#introduction\" id=\"markdown-toc-introduction\">Introduction</a></li>\n  <li><a href=\"#mux-based-design\" id=\"markdown-toc-mux-based-design\">Mux based design</a>    <ol>\n      <li><a href=\"#previous-states-for-the-same-input-word\" id=\"markdown-toc-previous-states-for-the-same-input-word\">Previous states for the same input word</a></li>\n      <li><a href=\"#no-previous-state-for-a-given-input-word\" id=\"markdown-toc-no-previous-state-for-a-given-input-word\">No previous state for a given input word</a></li>\n      <li><a href=\"#output-bit-set-by-multiple-states\" id=\"markdown-toc-output-bit-set-by-multiple-states\">Output bit set by multiple states</a></li>\n    </ol>\n  </li>\n</ol>\n\n<h2 id=\"introduction\">Introduction</h2>\n\n<p>It is possible, specially for large systems, to use Medium Scale Integration components (counters, MUXs, DeMUXs, etc.) to design sequential systems</p>\n\n<p>For systems with a large number of inputs, the state diagram looses its purpose and there is no standard method to design with a greater scale of integration.</p>\n\n<p>The main idea is to use fixed architectures as building blocks and adapt the problem to these architectures.</p>\n\n<h2 id=\"mux-based-design\">Mux based design</h2>\n\n<p>In this architecture, each state is represented by the output of a MUX. A memory element (D type flip-flop) is added to the MUX output.</p>\n\n<p>The basic building block of this architecture is depicted in Fig. 1.</p>\n\n<figure class=\"image\">\n  <img src=\"/assets/images/seq/mux-buildingblock.svg\" alt=\"Fig. 1: MUX + D flip-flop building block.\" />\n  <figcaption>Fig. 1: MUX + D flip-flop building block.</figcaption>\n</figure>\n\n<p>The selection lines $x_1,\\ldots,x_n$ are connected to the systemâ€™s inputs. The multiplexed inputs $C_0,\\ldots,C_{2^n-1}$ are connected to the previous states (MUXs), and the output $F$ is connected to the next states (MUXs).</p>\n\n<p>During operation there will be only one MUX with its output activated, the one representing the current state. When an input combination triggers the transition to the next state the output of the MUX representing that next state will become active and the previously active MUX output will deactivate.</p>\n\n<p>For simplicity, we will consider a Moore FSM, however the system can be also configured for Mealy state machines adding the input conditions to the output decoder.</p>\n\n<p>The following transition cases can be combined to form any Finite State Machine:</p>\n\n<ol>\n  <li>Multiple previous states transitioning to a common next state for the same input word.</li>\n  <li>No previous state for input combination $k$.</li>\n  <li>Output bit associated to multiple states (Moore style machine).</li>\n</ol>\n\n<p>The following are examples for each of these cases.</p>\n\n<h3 id=\"previous-states-for-the-same-input-word\">Previous states for the same input word</h3>\n\n<p>States B and C will transit to next state A if the input $x=I_j$.</p>\n\n<figure class=\"image\">\n  <img src=\"/assets/images/seq/mux-next-state.svg\" alt=\"Previous states for the same input word.\" />\n  <figcaption>Previous states for the same input word.</figcaption>\n</figure>\n\n<h3 id=\"no-previous-state-for-a-given-input-word\">No previous state for a given input word</h3>\n\n<p>State D has no previous state for input combination $x=I_k$.</p>\n\n<figure class=\"image\">\n  <img src=\"/assets/images/seq/mux-noprev-state.svg\" alt=\"No previous state for a given input word.\" />\n  <figcaption>No previous state for a given input word.</figcaption>\n</figure>\n\n<h3 id=\"output-bit-set-by-multiple-states\">Output bit set by multiple states</h3>\n\n<p>If output function $z$ is active for states A, B or C, then the output decoder is simply:</p>\n\n<figure class=\"image\">\n  <img src=\"/assets/images/seq/mux-output.svg\" alt=\"Output associated to multiple states.\" />\n  <figcaption>Output associated to multiple states.</figcaption>\n</figure>\n\n",
  "dir": "/docs/seq-msi/",
  "excerpt": null,
  "url": "/docs/seq-msi/msi-seq-design.html",
  "raw_content": "# MSI based design\n{: .no_toc}\n\n\n## Table of contents\n{: .no_toc .text-delta}\n\n1. TOC\n{:toc}\n\n\n## Introduction\n\nIt is possible, specially for large systems, to use Medium Scale Integration components (counters, MUXs, DeMUXs, etc.) to design sequential systems\n\nFor systems with a large number of inputs, the state diagram looses its purpose and there is no standard method to design with a greater scale of integration.\n\nThe main idea is to use fixed architectures as building blocks and adapt the problem to these architectures.\n\n\n## Mux based design\n\nIn this architecture, each state is represented by the output of a MUX. A memory element (D type flip-flop) is added to the MUX output.\n\nThe basic building block of this architecture is depicted in Fig. 1.\n\n{% include image.html url=\"/assets/images/seq/mux-buildingblock.svg\" description=\"Fig. 1: MUX + D flip-flop building block.\" %}\n\nThe selection lines $x\\_1,\\ldots,x\\_n$ are connected to the system's inputs. The multiplexed inputs $C_0,\\ldots,C_{2^n-1}$ are connected to the previous states (MUXs), and the output $F$ is connected to the next states (MUXs).\n\nDuring operation there will be only one MUX with its output activated, the one representing the current state. When an input combination triggers the transition to the next state the output of the MUX representing that next state will become active and the previously active MUX output will deactivate.\n\nFor simplicity, we will consider a Moore FSM, however the system can be also configured for Mealy state machines adding the input conditions to the output decoder.\n\nThe following transition cases can be combined to form any Finite State Machine:\n\n1.  Multiple previous states transitioning to a common next state for the same input word.\n2.  No previous state for input combination $k$.\n3.  Output bit associated to multiple states (Moore style machine).\n\nThe following are examples for each of these cases.\n\n\n### Previous states for the same input word\n\nStates B and C will transit to next state A if the input $x=I_j$.\n\n{% include image.html url=\"/assets/images/seq/mux-next-state.svg\" description=\"Previous states for the same input word.\" %}\n\n\n### No previous state for a given input word\n\nState D has no previous state for input combination $x=I_k$.\n\n{% include image.html url=\"/assets/images/seq/mux-noprev-state.svg\" description=\"No previous state for a given input word.\" %}\n\n\n### Output bit set by multiple states\n\nIf output function $z$ is active for states A, B or C, then the output decoder is simply:\n\n{% include image.html url=\"/assets/images/seq/mux-output.svg\" description=\"Output associated to multiple states.\" %}\n",
  "front_matter": {
    "layout": "circuitverse",
    "title": "MSI based design",
    "nav_order": "l1s000",
    "cvib_level": "medium",
    "parent": "Sequential MSI",
    "has_children": false
  },
  "front_matter_defaults": {
  },
  "http_url": "https://learn.circuitverse.org/docs/seq-msi/msi-seq-design.html",
  "api_url": "https://learn.circuitverse.org/_api/pages/docs/seq-msi/msi-seq-design.md"
}