{
  "name": "implementation.md",
  "path": "docs/logic-design/implementation.md",
  "relative_path": "docs/logic-design/implementation.md",
  "layout": "circuitverse",
  "title": "Implementation",
  "nav_order": "l0s001",
  "cvib_level": "basic",
  "parent": "Logic Design",
  "has_children": false,
  "content": "<h1 class=\"no_toc\" id=\"implementation\">Implementation</h1>\n\n<h2 class=\"no_toc text-delta\" id=\"table-of-contents\">Table of contents</h2>\n\n<ol id=\"markdown-toc\">\n  <li><a href=\"#from-boolean-function-to-a-logic-circuit\" id=\"markdown-toc-from-boolean-function-to-a-logic-circuit\">From Boolean function to a logic circuit</a>    <ol>\n      <li><a href=\"#example\" id=\"markdown-toc-example\">Example</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#optimizing-a-circuit\" id=\"markdown-toc-optimizing-a-circuit\">Optimizing a circuit</a></li>\n</ol>\n\n<h2 id=\"from-boolean-function-to-a-logic-circuit\">From Boolean function to a logic circuit</h2>\n\n<p>The easiest path to go from a logic design to an actual logic circuit is to obtain its Boolean function and replace the logical addition, multiplication and negation operators by the logical OR, AND and NOT gates.</p>\n\n<p>If the design is expressed as a truth table or a map (such as the ones described in <a href=\"/docs/logic-design/kmaps.html\">K-Maps</a>) it is better to transform them to the equivalent Boolean function.</p>\n\n<p>Another representation presented in the section <a href=\"/docs/logic-design/mev.html\">Map-entered Variables</a> can be directly implemented with <em>multiplexers</em>, a medium scale integration (MSI) component described in section <a href=\"/docs/comb-msi/mux-demux.html\">MUX/DEMUX</a>.</p>\n\n<h3 id=\"example\">Example</h3>\n\n<p>The logic system defined by the truth table in Table 1:</p>\n\n<table>\n  <thead>\n    <tr>\n      <th style=\"text-align: center\">: Table 1: Truth table of function $F(x,y,z)$  {: .tblcap } :||||</th>\n      <th style=\"text-align: center\"> </th>\n      <th style=\"text-align: center\"> </th>\n      <th style=\"text-align: center\"> </th>\n      <th style=\"text-align: center\"> </th>\n    </tr>\n    <tr>\n      <th style=\"text-align: center\">$i$</th>\n      <th style=\"text-align: center\">$x$</th>\n      <th style=\"text-align: center\">$y$</th>\n      <th style=\"text-align: center\">$z$</th>\n      <th style=\"text-align: center\">$F$</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td style=\"text-align: center\">0</td>\n      <td style=\"text-align: center\">0</td>\n      <td style=\"text-align: center\">0</td>\n      <td style=\"text-align: center\">0</td>\n      <td style=\"text-align: center\">0</td>\n    </tr>\n    <tr>\n      <td style=\"text-align: center\">1</td>\n      <td style=\"text-align: center\">0</td>\n      <td style=\"text-align: center\">0</td>\n      <td style=\"text-align: center\">1</td>\n      <td style=\"text-align: center\">1</td>\n    </tr>\n    <tr>\n      <td style=\"text-align: center\">2</td>\n      <td style=\"text-align: center\">0</td>\n      <td style=\"text-align: center\">1</td>\n      <td style=\"text-align: center\">0</td>\n      <td style=\"text-align: center\">0</td>\n    </tr>\n    <tr>\n      <td style=\"text-align: center\">3</td>\n      <td style=\"text-align: center\">0</td>\n      <td style=\"text-align: center\">1</td>\n      <td style=\"text-align: center\">1</td>\n      <td style=\"text-align: center\">0</td>\n    </tr>\n    <tr>\n      <td style=\"text-align: center\">4</td>\n      <td style=\"text-align: center\">1</td>\n      <td style=\"text-align: center\">0</td>\n      <td style=\"text-align: center\">0</td>\n      <td style=\"text-align: center\">0</td>\n    </tr>\n    <tr>\n      <td style=\"text-align: center\">5</td>\n      <td style=\"text-align: center\">1</td>\n      <td style=\"text-align: center\">0</td>\n      <td style=\"text-align: center\">1</td>\n      <td style=\"text-align: center\">0</td>\n    </tr>\n    <tr>\n      <td style=\"text-align: center\">6</td>\n      <td style=\"text-align: center\">1</td>\n      <td style=\"text-align: center\">1</td>\n      <td style=\"text-align: center\">0</td>\n      <td style=\"text-align: center\">1</td>\n    </tr>\n    <tr>\n      <td style=\"text-align: center\">7</td>\n      <td style=\"text-align: center\">1</td>\n      <td style=\"text-align: center\">1</td>\n      <td style=\"text-align: center\">1</td>\n      <td style=\"text-align: center\">1</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>can be represented by the function:</p>\n\n<p>$F(x,y,z) = \\overline{x}\\overline{y}z + xy\\overline{z} + xyz$</p>\n\n<p>using Boolean algebra’s rules and laws the function can be re-arranged as</p>\n\n<p>$\\begin{align*}\nF(x,y,z) &amp;= \\overline{x}\\overline{y}z + xy\\underbrace{(\\overline{z} + z)}_{=1}\\\\<br />\nF(x,y,z) &amp;= \\overline{x}\\overline{y}z + xy\n\\end{align*}$</p>\n\n<p>By replacing the negations by NOT gates, the sum by an OR gate and the products by AND gates, the following circuit is implemented:</p>\n\n<iframe width=\"100%\" height=\"400px\" src=\"https://circuitverse.org/simulator/embed/boolean-implementation-example\" id=\"projectPreview\" scrolling=\"no\" title=\"Boolean implementation example\" webkitallowfullscreen=\"\" mozallowfullscreen=\"\" allowfullscreen=\"\">\n</iframe>\n\n<h2 id=\"optimizing-a-circuit\">Optimizing a circuit</h2>\n\n<p>As it was shown in the example above, in general, a Boolean function is reduced before its implementation. The reduced expression leads to a more optimal circuit, with fewer gates and connections. In turn, this makes the circuit less complex and easier to implement, debug and repair. It may also reduce the total cost and energy requirements due to the reduced number of components. Additionally, if the circuit is being implemented with discrete components, it will be more compact in size.</p>\n\n<p>There are several methods to minimise a logic function:</p>\n\n<ol>\n  <li>Use the Boolean algebra’s laws and rules. This process is complex and difficult but it works for any function, independent of the number of variables.</li>\n  <li>A graphical, visual inspection method based on the representation using Karnaugh Maps as described in section <a href=\"/docs/logic-design/kmaps.html\">K-Maps</a> or the extension using Map-entered Variables shown in section <a href=\"/docs/logic-design/mev.html\">Map-entered variables</a> or the</li>\n  <li>A tabular recursive algorithm known as Quine-McCluskey method which is explained in section <a href=\"/docs/logic-design/qmc.html\">Quine McCluskey</a>.</li>\n  <li>Even other optimisation methods can be used (for instance, heuristic based, or evolutionary computation), specially with extremely large circuits or when additional restrictions need to be satisfied.</li>\n</ol>\n",
  "dir": "/docs/logic-design/",
  "excerpt": null,
  "url": "/docs/logic-design/implementation.html",
  "raw_content": "# Implementation\n{: .no_toc}\n\n\n## Table of contents\n{: .no_toc .text-delta}\n\n1. TOC\n{:toc}\n\n\n## From Boolean function to a logic circuit\n\nThe easiest path to go from a logic design to an actual logic circuit is to obtain its Boolean function and replace the logical addition, multiplication and negation operators by the logical OR, AND and NOT gates.\n\nIf the design is expressed as a truth table or a map (such as the ones described in [K-Maps]({% link docs/logic-design/kmaps.md %})) it is better to transform them to the equivalent Boolean function.\n\nAnother representation presented in the section [Map-entered Variables]({% link docs/logic-design/mev.md %}) can be directly implemented with *multiplexers*, a medium scale integration (MSI) component described in section [MUX/DEMUX]({% link docs/comb-msi/mux-demux.md %}).\n\n\n### Example\n\nThe logic system defined by the truth table in Table 1:\n\n|: Table 1: Truth table of function $F(x,y,z)$  {: .tblcap } :|||||\n| $i$ | $x$ | $y$ | $z$ | $F$ |\n|:---:|:---:|:---:|:---:|:---:|\n|  0  |  0  |  0  |  0  |  0  |\n|  1  |  0  |  0  |  1  |  1  |\n|  2  |  0  |  1  |  0  |  0  |\n|  3  |  0  |  1  |  1  |  0  |\n|  4  |  1  |  0  |  0  |  0  |\n|  5  |  1  |  0  |  1  |  0  |\n|  6  |  1  |  1  |  0  |  1  |\n|  7  |  1  |  1  |  1  |  1  |\n\ncan be represented by the function:\n\n$F(x,y,z) = \\overline{x}\\overline{y}z + xy\\overline{z} + xyz$\n\nusing Boolean algebra's rules and laws the function can be re-arranged as\n\n$\\begin{align\\*}\nF(x,y,z) &= \\overline{x}\\overline{y}z + xy\\underbrace{(\\overline{z} + z)}\\_{=1}\\\\\\\\\\\\\nF(x,y,z) &= \\overline{x}\\overline{y}z + xy\n\\end{align\\*}$\n\nBy replacing the negations by NOT gates, the sum by an OR gate and the products by AND gates, the following circuit is implemented:\n\n<iframe width=\"100%\" height=\"400px\"\n\tsrc=\"https://circuitverse.org/simulator/embed/boolean-implementation-example\"\n\tid=\"projectPreview\" scrolling=\"no\"\n\ttitle=\"Boolean implementation example\"\n\twebkitAllowFullScreen mozAllowFullScreen allowFullScreen>\n</iframe>\n\n\n## Optimizing a circuit\n\nAs it was shown in the example above, in general, a Boolean function is reduced before its implementation. The reduced expression leads to a more optimal circuit, with fewer gates and connections. In turn, this makes the circuit less complex and easier to implement, debug and repair. It may also reduce the total cost and energy requirements due to the reduced number of components. Additionally, if the circuit is being implemented with discrete components, it will be more compact in size.\n\nThere are several methods to minimise a logic function:\n\n1.  Use the Boolean algebra's laws and rules. This process is complex and difficult but it works for any function, independent of the number of variables.\n2.  A graphical, visual inspection method based on the representation using Karnaugh Maps as described in section [K-Maps]({% link docs/logic-design/kmaps.md %}) or the extension using Map-entered Variables shown in section [Map-entered variables]({% link docs/logic-design/mev.md %}) or the\n3.  A tabular recursive algorithm known as Quine-McCluskey method which is explained in section [Quine McCluskey]({% link docs/logic-design/qmc.md %}).\n4.  Even other optimisation methods can be used (for instance, heuristic based, or evolutionary computation), specially with extremely large circuits or when additional restrictions need to be satisfied.\n",
  "front_matter": {
    "layout": "circuitverse",
    "title": "Implementation",
    "nav_order": "l0s001",
    "cvib_level": "basic",
    "parent": "Logic Design",
    "has_children": false
  },
  "front_matter_defaults": {
  },
  "http_url": "https://learn.circuitverse.org/docs/logic-design/implementation.html",
  "api_url": "https://learn.circuitverse.org/_api/pages/docs/logic-design/implementation.md"
}