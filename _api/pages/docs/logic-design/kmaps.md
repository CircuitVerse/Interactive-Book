{
  "name": "kmaps.md",
  "path": "docs/logic-design/kmaps.md",
  "relative_path": "docs/logic-design/kmaps.md",
  "layout": "circuitverse",
  "title": "K-Maps",
  "nav_order": "l1s001",
  "cvib_level": "medium",
  "parent": "Logic Design",
  "has_children": false,
  "content": "<h1 class=\"no_toc\" id=\"k-maps\">K-Maps</h1>\n\n<h2 class=\"no_toc text-delta\" id=\"table-of-contents\">Table of contents</h2>\n\n<ol id=\"markdown-toc\">\n  <li><a href=\"#introduction\" id=\"markdown-toc-introduction\">Introduction</a></li>\n  <li><a href=\"#enumeration-and-gray-codes\" id=\"markdown-toc-enumeration-and-gray-codes\">Enumeration and gray codes</a></li>\n  <li><a href=\"#simple-groupings\" id=\"markdown-toc-simple-groupings\">Simple groupings</a></li>\n  <li><a href=\"#two-dimension-groupings\" id=\"markdown-toc-two-dimension-groupings\">Two dimension groupings</a></li>\n  <li><a href=\"#disjoint-groupings\" id=\"markdown-toc-disjoint-groupings\">Disjoint groupings</a></li>\n  <li><a href=\"#overlapping-groupings\" id=\"markdown-toc-overlapping-groupings\">Overlapping groupings</a></li>\n  <li><a href=\"#minimizing-group-count\" id=\"markdown-toc-minimizing-group-count\">Minimizing group count</a></li>\n</ol>\n\n<h2 id=\"introduction\">Introduction</h2>\n<p>Karnaugh Maps are a way to visually display a boolean expression onto a 2D grid. Take the variables and bind them to an axis, and then enumerate through the possible combinations of input values that could occur for all those variables bounded to an axis (either horizontally or vertically).</p>\n\n<p>For example, display the following 2 variable Karnaugh Map:</p>\n\n<p><img src=\"/assets/images/map11.png\" alt=\"\" /></p>\n\n<p>You have bounded to the vertical axis, the variable <code class=\"language-plaintext highlighter-rouge\">A</code>, and enumerate through the possible values for <code class=\"language-plaintext highlighter-rouge\">A</code> (being <code class=\"language-plaintext highlighter-rouge\">{0, 1}</code>). Similarly, perform a similar operation for the <code class=\"language-plaintext highlighter-rouge\">B</code> variable. Since you are using a 2 variable expression, you can bound one variable to each axis and the visualization works fine in a <code class=\"language-plaintext highlighter-rouge\">2x2</code> matrix.</p>\n\n<p>Let’s instead look at a more involved example with 4 variables:</p>\n\n<p><img src=\"/assets/images/map1.png\" alt=\"\" /></p>\n\n<p>You have now bounded the <code class=\"language-plaintext highlighter-rouge\">A</code> and <code class=\"language-plaintext highlighter-rouge\">B</code> variables to the vertical axis, and <code class=\"language-plaintext highlighter-rouge\">C</code> and <code class=\"language-plaintext highlighter-rouge\">D</code> variables to the horizontal axis. Now enumerate through different combinations of the bounded variables for each axis in <em>reflected binary code order</em> (more on this in the following section). Lastly, indicate on the matrix each true value by augmenting a <code class=\"language-plaintext highlighter-rouge\">1</code> value.</p>\n\n<h2 id=\"enumeration-and-gray-codes\">Enumeration and gray codes</h2>\n<p>When enumerating through the variable input combinations for the bound axis, we take advantage of <em>reflected binary code order</em>, otherwise known as grey codes. If we observe, we can notice that from one combination to another, we only vary by one bit. That is:</p>\n\n<div class=\"language-yml highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nn\">...</span> <span class=\"s\">00 01 11 10 00 01 11 10 00 ...</span>\n    <span class=\"s\">^   ^ ^   ^ ^   ^ ^   ^ ^</span>\n</code></pre></div></div>\n\n<p>Thus, you get this wrapping that allows us to switch by only one bit. This provides us with the core of how Karnaugh Maps work.</p>\n\n<h2 id=\"simple-groupings\">Simple groupings</h2>\n<p>The main idea for how Karnaugh Maps can be used to simplify expressions is to group pairs of <code class=\"language-plaintext highlighter-rouge\">1</code> values that are adjacent and exploit the fact that each one has only a bit different from another.</p>\n\n<p><img src=\"/assets/images/map2.png\" alt=\"\" /></p>\n\n<p>For this example, let <code class=\"language-plaintext highlighter-rouge\">F(ABCD) = CELL</code>. start with the expression <code class=\"language-plaintext highlighter-rouge\">F(0000) = 1</code> and <code class=\"language-plaintext highlighter-rouge\">F(0001) = 1</code>. However, notice that <em>regardless</em> of the value of the last bit, you still get <code class=\"language-plaintext highlighter-rouge\">1</code>. Hence, let’s take a look at the SOP expressions:</p>\n\n<div class=\"language-yml highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"s\">F(ABCD) = A'B'C'D' + A'B'C'D</span>\n<span class=\"s\">F(0000) = </span><span class=\"m\">1</span>\n<span class=\"s\">F(0001) = </span><span class=\"m\">1</span>\n\n<span class=\"s\">Since the last bit is the same, you can ignore the D value, thus</span><span class=\"pi\">:</span>\n<span class=\"s\">F(ABCD) = A'B'C'</span>\n\n<span class=\"na\">You can confirm by simplifying algebraically</span><span class=\"pi\">:</span>\n<span class=\"s\">F(ABCD) = A'B'C'D' + A'B'C'D</span>\n      <span class=\"s\">= A'B'C'(D' + D)</span>\n      <span class=\"s\">= A'B'C'</span>\n<span class=\"s\">Therefore, the simplification is </span><span class=\"no\">true</span><span class=\"s\">.</span>\n</code></pre></div></div>\n\n<p>You can then extend this rule to work for rectangles and more!</p>\n\n<h2 id=\"two-dimension-groupings\">Two dimension groupings</h2>\n<p>Extending the idea of isolating changing bits that retain a consistent value, we can then generalize this to work in a higher dimension. Consider the following example:</p>\n\n<p><img src=\"/assets/images/map3.png\" alt=\"\" /></p>\n\n<p>Letting <code class=\"language-plaintext highlighter-rouge\">F(ABCD) = CELL</code>:</p>\n<div class=\"language-yml highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"s\">F(0000) = </span><span class=\"m\">1</span>\n<span class=\"s\">F(0001) = </span><span class=\"m\">1</span>\n<span class=\"s\">F(0100) = </span><span class=\"m\">1</span>\n<span class=\"s\">F(0101) = </span><span class=\"m\">1</span>\n</code></pre></div></div>\n\n<p>Observe that the bits do not change by one for all pairs of numbers, for example, <code class=\"language-plaintext highlighter-rouge\">{0000, 0101}</code> differ by two bits. However, you can take advantage of the fact that for any bit change horizontally or vertically, it’s irrelevant what that bit is. More concretely, take a look at the following example.</p>\n\n<div class=\"language-yml highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"s\">0000 </span><span class=\"m\">0001</span>\n<span class=\"s\">0100 </span><span class=\"m\">0101</span>\n\n<span class=\"s\">=&gt; A'B'C'D' + A'B'C'D + A'BC'D' + A'BC'D</span>\n<span class=\"s\">Regardless of the B variable, you still get </span><span class=\"no\">true</span><span class=\"s\"> for all products in the SOP expression.</span>\n<span class=\"na\">This is bounded vertically</span><span class=\"pi\">:</span>\n<span class=\"s\">=&gt; A'C'D' + A'C'D + A'C'D' + A'C'D</span>\n<span class=\"s\">Regardless of the D variable, you still get </span><span class=\"no\">true</span><span class=\"s\"> for all products in the SOP expression.</span>\n<span class=\"na\">This is bounded horizontally</span><span class=\"pi\">:</span>\n<span class=\"s\">=&gt; A'C' + A'C' + A'C' + A'C'</span>\n<span class=\"s\">=&gt; A'C' (1 + 1 + 1 + 1)</span>\n<span class=\"s\">=&gt; A'C' (1)</span>\n<span class=\"s\">=&gt; A'C'</span>\n</code></pre></div></div>\n\n<p>Since the differences in bits need to generalize throughout a binding of an axis, you can only have a binding of size <code class=\"language-plaintext highlighter-rouge\">2^n</code> for a given axis. For example, <code class=\"language-plaintext highlighter-rouge\">1x1, 1x2, 1x4, 2x2, 2x4, 4x4</code>.</p>\n\n<h2 id=\"disjoint-groupings\">Disjoint groupings</h2>\n<p>Consider the following example:\n<img src=\"/assets/images/map4.png\" alt=\"\" /></p>\n\n<p>The algorithm follows precisely as it did before, except that now the two groups are joined in the SOP expression. Letting <code class=\"language-plaintext highlighter-rouge\">F(ABCD) = CELL</code>:</p>\n<div class=\"language-yml highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"s\">F(0000) = </span><span class=\"m\">1</span>\n<span class=\"s\">F(0001) = </span><span class=\"m\">1</span>\n<span class=\"s\">F(1111) = </span><span class=\"m\">1</span>\n<span class=\"s\">F(1011) = </span><span class=\"m\">1</span>\n</code></pre></div></div>\n<p>This yields the following:</p>\n<div class=\"language-yml highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"s\">A'B'C'D' + A'B'C'D + ABCD + AB'CD</span>\n<span class=\"na\">Breaking down the expression</span><span class=\"pi\">:</span>\n<span class=\"s\">(A'B'C'D' + A'B'C'D) + (ABCD + AB'CD)</span>\n<span class=\"s\">=&gt; (A'B'C'(D + D')) + (ACD(B + B'))</span>\n<span class=\"s\">=&gt; (A'B'C') + (ACD)</span>\n<span class=\"s\">=&gt; A'B'C' + ACD</span>\n</code></pre></div></div>\n<p>Clearly this is the exact same process as before, but iterated throughout all the disjoint sets.</p>\n\n<h2 id=\"overlapping-groupings\">Overlapping groupings</h2>\n<p>Overlapping groupings become more complex because there exist ambiguous cases and sometimes what may appear to be a locally optimal solution is not a globally optimal solution.</p>\n\n<p>The general technique for evaluating for overlapping groups follows a greedy algorithm. Define an unvisited cell as a cell that has a value of <code class=\"language-plaintext highlighter-rouge\">1</code> however it is currently not matched with a grouping yet.</p>\n\n<p>Iterate through all the cells, and once you find a cell with <code class=\"language-plaintext highlighter-rouge\">1</code>, if it is unvisited then find the largest possible square or rectangle such that each side length is a power of 2, where all the cells are <code class=\"language-plaintext highlighter-rouge\">1</code> in its enclosed area. If there is a tie for size (ie, <code class=\"language-plaintext highlighter-rouge\">1x4</code> vs <code class=\"language-plaintext highlighter-rouge\">2x2</code>), assign the one that is a square (this is by convention).</p>\n\n<p>Repeat this process for all remaining unvisited cells.</p>\n\n<p><strong><em>Note: You can overlap the groupings with already visited nodes, but you never instantiate a new grouping unless the current node is unvisited.</em></strong></p>\n\n<p><img src=\"/assets/images/map5.png\" alt=\"\" /></p>\n\n<p>In this example, at <code class=\"language-plaintext highlighter-rouge\">F(0000)</code>, you can create a grouping of size 2 (because 2 is the largest possible grouping, 3 is not a power of 2). Then iterate through to <code class=\"language-plaintext highlighter-rouge\">F(0001)</code>, however <code class=\"language-plaintext highlighter-rouge\">F(0001)</code> was already resolved to a grouping. For the latest active cell, <code class=\"language-plaintext highlighter-rouge\">F(0011)</code> is not resolved to a grouping thus it’s unvisited. The largest possible grouping is also of size 2, thus you create another group.</p>\n\n<p>To resolve the groupings into an SOP expression, iterate through the groups and identify changing bits:</p>\n\n<div class=\"language-yml highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"na\">Group 1</span><span class=\"pi\">:</span> <span class=\"s\">F(ABCD) = [0000, 0001]</span>\n<span class=\"na\">Group 2</span><span class=\"pi\">:</span> <span class=\"s\">F(ABCD) = [0001, 0011]</span>\n\n<span class=\"na\">For Group 1</span><span class=\"pi\">:</span>\n<span class=\"s\">0000 </span><span class=\"m\">0001</span>\n   <span class=\"s\">^    ^</span>\n<span class=\"s\">F(ABCD) = A'B'C'D' + A'B'C'D</span>\n<span class=\"s\">=&gt; A'B'C'(D + D')</span>\n<span class=\"s\">=&gt; A'B'C'</span>\n\n<span class=\"na\">For Group 2</span><span class=\"pi\">:</span>\n<span class=\"s\">0001 </span><span class=\"m\">0011</span>\n  <span class=\"s\">^    ^</span>\n<span class=\"s\">F(ABCD) = A'B'C'D + A'B'CD</span>\n<span class=\"s\">=&gt; A'B'D(C' + C)</span>\n<span class=\"s\">=&gt; A'B'D</span>\n\n<span class=\"na\">Now add the two results</span><span class=\"pi\">:</span>\n<span class=\"s\">F(ABCD) = A'B'C' + A'B'D</span>\n<span class=\"s\">=&gt; F(ABCD) = A'B'D + A'B'C' (by commutative property)</span>\n</code></pre></div></div>\n\n<h2 id=\"minimizing-group-count\">Minimizing group count</h2>\n<p>The following example will illustrate how the greedy approach may occasionally produce too many groups. Consider the following example:</p>\n\n<p><img src=\"/assets/images/map6.png\" alt=\"\" /></p>\n\n<p>This grouping state is optimal. However, consider adding a <code class=\"language-plaintext highlighter-rouge\">1</code> to <code class=\"language-plaintext highlighter-rouge\">F(1111)</code>.</p>\n\n<p><img src=\"/assets/images/map7.png\" alt=\"\" /></p>\n\n<p>Following the previous algorithm, iterating top-bottom and left-right, when getting to <code class=\"language-plaintext highlighter-rouge\">F(0110)</code>, the algorithm can choose to make the largest grouping. However, there are two possible groupings:</p>\n\n<div class=\"language-yml highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"na\">Candidate 1</span><span class=\"pi\">:</span>\n<span class=\"s\">F(ABCD) = [0011, 0010, 0111, 0110]</span>\n\n<span class=\"na\">Candidate 2</span><span class=\"pi\">:</span>\n<span class=\"s\">F(ABCD) = [0111, 0110, 1111, 1110]</span>\n</code></pre></div></div>\n\n<p>Both groupings have the same size and are the same dimension. However, upon reaching <code class=\"language-plaintext highlighter-rouge\">F(1110)</code>, another grouping needs to be instantiated, in which case if the first candidate grouping was created then you made a group that did not necessarily increase the size of our SOP expression.</p>\n\n<p>This illustrates the idea that this is a greedy algorithm, and does not always return the most simplified SOP expression. In later sections, algorithms illustrating a globally optimal algorithm will be discussed.</p>\n\n<html lang=\"en\">\n<head>\n    <meta charset=\"utf-8\" />\n\n    <meta name=\"viewport\" content=\"width=240\" />\n    <script src=\"/assets/js/module.js\"></script>\n    <script language=\"JavaScript\" type=\"text/javascript\">\n        var karnaugh = -1;\n        var qmc = -1;\n        function run() {\n            qmc = new QuineMcCluskey(\"fakeDivId\", 2, 4, 0);\n            //qmc = new QuineMcCluskey(\"myQmcDisplay\", 2, 4, 0); // enable for debugging\n            qmc.init();\n\n            karnaugh = new KarnaughMap(\"myKarnaughMap\", qmc);\n            karnaugh.init();\n        }\n\n        function noOfVarsChanged() {\n            var d = document.getElementById(\"noOfVarsChanged_id\").value;\n            karnaugh.setNoOfVars(d);\n        }\n\n        function dontCareChanged() {\n            var d = document.getElementById(\"select_dontCare\").value;\n            karnaugh.allowDontCares(d);\n        }\n\n        function dontShowChanged() {\n            var d = document.getElementById(\"select_dontShow\").value;\n            karnaugh.setDontShowResult(d);\n        }\n\twindow.onload = run;\n    </script>\n    <style type=\"text/css\">\n        .qmcMathFont{font-family:\"Times New Roman\",Georgia,Serif;font-size:30px}\n    </style>\n</head>\n<body onload=\"run();\">\n\n<p>This Interactive Karnaugh-Map represents the function- <i>Y</i>&nbsp;=&nbsp;f(<i>x</i><sub><small>n</small></sub>,...,<i>x</i><sub><small>1</small></sub>, <i>x</i><sub><small>0</small></sub>).\n    This function can manually be edited by a click on different cells in the K-map, or by pressing the button:'Random example' a random function can be generated.</p>\n<p>\n    <button type=\"button\" onclick=\"karnaugh.genRandom();\">Random example</button>\n    <button type=\"button\" onclick=\"karnaugh.clear();\">Reset</button>\n    <br />\n    <br />\n    Number of input variables:\n    <select onchange=\"noOfVarsChanged();\" id=\"noOfVarsChanged_id\">\n        <option value=\"1\">1</option>\n        <option value=\"2\">2</option>\n        <option value=\"3\">3</option>\n        <option value=\"4\" selected=\"\">4</option>\n        <option value=\"5\">5</option>\n        <option value=\"6\">6</option>\n        <option value=\"7\">7</option>\n        <option value=\"8\">8</option>\n    </select>&nbsp;&nbsp;&nbsp;&nbsp; Allow Don’t-Care:\n    <select onchange=\"dontCareChanged();\" id=\"select_dontCare\">\n        <option value=\"0\" selected=\"\">no</option>\n        <option value=\"1\">Yes</option>\n    </select>&nbsp;&nbsp;&nbsp;&nbsp; Hide result:\n    <select onchange=\"dontShowChanged();\" id=\"select_dontShow\">\n        <option value=\"0\" selected=\"\">no</option>\n        <option value=\"1\">Yes</option>\n    </select>  <br />\n</p>\n\n\n<div id=\"myKarnaughMap\"> </div>\n\n<div id=\"myQmcDisplay\"></div>\n\n\n\n</body>\n</html>\n\n",
  "dir": "/docs/logic-design/",
  "url": "/docs/logic-design/kmaps.html",
  "raw_content": "# K-Maps\n{: .no_toc}\n\n\n## Table of contents\n{: .no_toc .text-delta}\n\n1. TOC\n{:toc}\n\n## Introduction\nKarnaugh Maps are a way to visually display a boolean expression onto a 2D grid. Take the variables and bind them to an axis, and then enumerate through the possible combinations of input values that could occur for all those variables bounded to an axis (either horizontally or vertically).\n\nFor example, display the following 2 variable Karnaugh Map:\n\n![](/assets/images/map11.png)\n\nYou have bounded to the vertical axis, the variable `A`, and enumerate through the possible values for `A` (being `{0, 1}`). Similarly, perform a similar operation for the `B` variable. Since you are using a 2 variable expression, you can bound one variable to each axis and the visualization works fine in a `2x2` matrix.\n\nLet's instead look at a more involved example with 4 variables:\n\n![](/assets/images/map1.png)\n\nYou have now bounded the `A` and `B` variables to the vertical axis, and `C` and `D` variables to the horizontal axis. Now enumerate through different combinations of the bounded variables for each axis in *reflected binary code order* (more on this in the following section). Lastly, indicate on the matrix each true value by augmenting a `1` value.\n\n## Enumeration and gray codes\nWhen enumerating through the variable input combinations for the bound axis, we take advantage of _reflected binary code order_, otherwise known as grey codes. If we observe, we can notice that from one combination to another, we only vary by one bit. That is:\n\n``` yml\n... 00 01 11 10 00 01 11 10 00 ...\n    ^   ^ ^   ^ ^   ^ ^   ^ ^\n```\n\nThus, you get this wrapping that allows us to switch by only one bit. This provides us with the core of how Karnaugh Maps work.\n\n## Simple groupings\nThe main idea for how Karnaugh Maps can be used to simplify expressions is to group pairs of `1` values that are adjacent and exploit the fact that each one has only a bit different from another. \n\n![](/assets/images/map2.png)\n\nFor this example, let `F(ABCD) = CELL`. start with the expression `F(0000) = 1` and `F(0001) = 1`. However, notice that _regardless_ of the value of the last bit, you still get `1`. Hence, let's take a look at the SOP expressions:\n\n```yml\nF(ABCD) = A'B'C'D' + A'B'C'D\nF(0000) = 1\nF(0001) = 1\n\nSince the last bit is the same, you can ignore the D value, thus:\nF(ABCD) = A'B'C'\n\nYou can confirm by simplifying algebraically:\nF(ABCD) = A'B'C'D' + A'B'C'D\n      = A'B'C'(D' + D)\n      = A'B'C'\nTherefore, the simplification is true.\n```\n\nYou can then extend this rule to work for rectangles and more!\n\n## Two dimension groupings\nExtending the idea of isolating changing bits that retain a consistent value, we can then generalize this to work in a higher dimension. Consider the following example:\n\n![](/assets/images/map3.png)\n\nLetting `F(ABCD) = CELL`:\n```yml\nF(0000) = 1\nF(0001) = 1\nF(0100) = 1\nF(0101) = 1\n```\n\nObserve that the bits do not change by one for all pairs of numbers, for example, `{0000, 0101}` differ by two bits. However, you can take advantage of the fact that for any bit change horizontally or vertically, it's irrelevant what that bit is. More concretely, take a look at the following example.\n\n```yml\n0000 0001\n0100 0101\n\n=> A'B'C'D' + A'B'C'D + A'BC'D' + A'BC'D\nRegardless of the B variable, you still get true for all products in the SOP expression.\nThis is bounded vertically:\n=> A'C'D' + A'C'D + A'C'D' + A'C'D\nRegardless of the D variable, you still get true for all products in the SOP expression.\nThis is bounded horizontally:\n=> A'C' + A'C' + A'C' + A'C'\n=> A'C' (1 + 1 + 1 + 1)\n=> A'C' (1)\n=> A'C'\n```\n\nSince the differences in bits need to generalize throughout a binding of an axis, you can only have a binding of size `2^n` for a given axis. For example, `1x1, 1x2, 1x4, 2x2, 2x4, 4x4`. \n\n## Disjoint groupings\nConsider the following example:\n![](/assets/images/map4.png)\n\nThe algorithm follows precisely as it did before, except that now the two groups are joined in the SOP expression. Letting `F(ABCD) = CELL`:\n```yml\nF(0000) = 1\nF(0001) = 1\nF(1111) = 1\nF(1011) = 1\n```\nThis yields the following:\n```yml\nA'B'C'D' + A'B'C'D + ABCD + AB'CD\nBreaking down the expression:\n(A'B'C'D' + A'B'C'D) + (ABCD + AB'CD)\n=> (A'B'C'(D + D')) + (ACD(B + B'))\n=> (A'B'C') + (ACD)\n=> A'B'C' + ACD\n```\nClearly this is the exact same process as before, but iterated throughout all the disjoint sets.\n\n## Overlapping groupings\nOverlapping groupings become more complex because there exist ambiguous cases and sometimes what may appear to be a locally optimal solution is not a globally optimal solution.\n\nThe general technique for evaluating for overlapping groups follows a greedy algorithm. Define an unvisited cell as a cell that has a value of `1` however it is currently not matched with a grouping yet. \n\nIterate through all the cells, and once you find a cell with `1`, if it is unvisited then find the largest possible square or rectangle such that each side length is a power of 2, where all the cells are `1` in its enclosed area. If there is a tie for size (ie, `1x4` vs `2x2`), assign the one that is a square (this is by convention). \n\nRepeat this process for all remaining unvisited cells. \n\n**_Note: You can overlap the groupings with already visited nodes, but you never instantiate a new grouping unless the current node is unvisited._**\n\n![](/assets/images/map5.png)\n\nIn this example, at `F(0000)`, you can create a grouping of size 2 (because 2 is the largest possible grouping, 3 is not a power of 2). Then iterate through to `F(0001)`, however `F(0001)` was already resolved to a grouping. For the latest active cell, `F(0011)` is not resolved to a grouping thus it's unvisited. The largest possible grouping is also of size 2, thus you create another group.\n\nTo resolve the groupings into an SOP expression, iterate through the groups and identify changing bits:\n\n```yml\nGroup 1: F(ABCD) = [0000, 0001]\nGroup 2: F(ABCD) = [0001, 0011]\n\nFor Group 1:\n0000 0001\n   ^    ^\nF(ABCD) = A'B'C'D' + A'B'C'D\n=> A'B'C'(D + D')\n=> A'B'C'\n\nFor Group 2:\n0001 0011\n  ^    ^\nF(ABCD) = A'B'C'D + A'B'CD\n=> A'B'D(C' + C)\n=> A'B'D\n\nNow add the two results:\nF(ABCD) = A'B'C' + A'B'D\n=> F(ABCD) = A'B'D + A'B'C' (by commutative property)\n```\n\n## Minimizing group count\nThe following example will illustrate how the greedy approach may occasionally produce too many groups. Consider the following example:\n\n![](/assets/images/map6.png)\n\nThis grouping state is optimal. However, consider adding a `1` to `F(1111)`.\n\n![](/assets/images/map7.png)\n\nFollowing the previous algorithm, iterating top-bottom and left-right, when getting to `F(0110)`, the algorithm can choose to make the largest grouping. However, there are two possible groupings:\n\n```yml\nCandidate 1:\nF(ABCD) = [0011, 0010, 0111, 0110]\n\nCandidate 2:\nF(ABCD) = [0111, 0110, 1111, 1110]\n```\n\nBoth groupings have the same size and are the same dimension. However, upon reaching `F(1110)`, another grouping needs to be instantiated, in which case if the first candidate grouping was created then you made a group that did not necessarily increase the size of our SOP expression. \n\nThis illustrates the idea that this is a greedy algorithm, and does not always return the most simplified SOP expression. In later sections, algorithms illustrating a globally optimal algorithm will be discussed.\n\n{% include kmap.html %}\n",
  "front_matter": {
    "layout": "circuitverse",
    "title": "K-Maps",
    "nav_order": "l1s001",
    "cvib_level": "medium",
    "parent": "Logic Design",
    "has_children": false
  },
  "front_matter_defaults": {
  },
  "http_url": "https://learn.circuitverse.org/docs/logic-design/kmaps.html",
  "api_url": "https://learn.circuitverse.org/_api/pages/docs/logic-design/kmaps.md"
}