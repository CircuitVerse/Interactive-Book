{
  "name": "rom-microcontrollers.md",
  "path": "docs/seq-lsi/rom-microcontrollers.md",
  "relative_path": "docs/seq-lsi/rom-microcontrollers.md",
  "layout": "circuitverse",
  "title": "ROM-based µcontrollers",
  "nav_order": "l0s000",
  "cvib_level": "basic",
  "parent": "Sequential LSI",
  "has_children": false,
  "content": "<h1 class=\"no_toc\" id=\"rom-based-µcontrollers\">ROM-based µcontrollers</h1>\n\n<h2 class=\"no_toc text-delta\" id=\"table-of-contents\">Table of contents</h2>\n\n<ol id=\"markdown-toc\">\n  <li><a href=\"#introduction\" id=\"markdown-toc-introduction\">Introduction</a></li>\n  <li><a href=\"#general-purpose-rom-based-µcontroller\" id=\"markdown-toc-general-purpose-rom-based-µcontroller\">General purpose ROM-based µcontroller</a></li>\n  <li><a href=\"#counter-based-µcontroller\" id=\"markdown-toc-counter-based-µcontroller\">Counter based µcontroller</a></li>\n  <li><a href=\"#preset-counter-based-µcontroller\" id=\"markdown-toc-preset-counter-based-µcontroller\">Preset counter based µcontroller</a></li>\n  <li><a href=\"#mux-based-µcontroller\" id=\"markdown-toc-mux-based-µcontroller\">MUX based µcontroller</a></li>\n</ol>\n\n<h2 id=\"introduction\">Introduction</h2>\n\n<p>ROM-based µcontrollers take the simple approach of implementing the combinational logic block of any sequential circuit (both the next state decoder and the output decoder) in a ROM circuit, while latches and counters can be used to make a more efficient use of the ROM capacity. In some cases, additional combinational MUX components are used for the same reason.</p>\n\n<p>The following are examples of different ROM-based µcontrollers</p>\n\n<h2 id=\"general-purpose-rom-based-µcontroller\">General purpose ROM-based µcontroller</h2>\n\n<p>A general purpose ROM-based µcontroller can be implemented as depicted in the block diagram below:</p>\n\n<p><img src=\"/assets/images/seq/rom_general.svg\" alt=\"General purpose ROM-based microcontroller\" /></p>\n\n<p>Both, the output decoder and the next-state decoder are implemented in the ROM.</p>\n\n<p>The number of address bits for the ROM must be greater than or equal to the sum of the number of input bits $M$ and the number of state variables $N$s. The size of the output word must be greater than or equal to the sum of the number of outputs html:(K)@@ and the number of state variables.</p>\n\n<p>ROM capacity: $2^{(M+N)}\\times (K+N)$</p>\n\n<h2 id=\"counter-based-µcontroller\">Counter based µcontroller</h2>\n\n<p>When the FSM corresponds to a simple sequence of states (without branches), a counter can be used to represent the state. The counter output (or state code) selects the corresponding output word from the ROM (A in the figure below). At the same time, part of the bits stored in the ROM (B in the figure) are used to select (via the MUX) the input associated which can produce the state transition for the current state.</p>\n\n<p><img src=\"/assets/images/seq/rom_counter.svg\" alt=\"Counter based microcontroller\" /></p>\n\n<p>ROM capacity: $2^N \\times (K+\\log_2 M)$</p>\n\n<h2 id=\"preset-counter-based-µcontroller\">Preset counter based µcontroller</h2>\n\n<p>If the FSM is mostly a simple sequence of state, but there are a few “jumps” to states out of the sequence, the previous circuit can be extended to store the address of the state which is out of the sequence and load it through the preset lines of the counter.</p>\n\n<p><img src=\"/assets/images/seq/rom_preset_counter.svg\" alt=\"Preset counter based microcontroller\" /></p>\n\n<p>ROM capacity: $2^N \\times (N+K+\\log_2 M)$</p>\n\n<h2 id=\"mux-based-µcontroller\">MUX based µcontroller</h2>\n\n<p>For FSM which do not exhibit a simple sequence of states, the counter can be replaced by a MUX and the next state addresses must be stored in the ROM.</p>\n\n<p><img src=\"/assets/images/seq/rom_mux.svg\" alt=\"MUX based microcontroller\" /></p>\n\n<p>ROM capacity: $2^N \\times (2N+K+\\log_2 M)$</p>\n\n<ol class=\"quiz\">\n  <li>What is the ROM capacity of Counter based µcontroller ?\n    <ol>\n      <li>2^N\\times(K+\\log_2 M)\n        <ul>\n          <li>2^N\\times(N+K+\\log_2 M)</li>\n          <li>2^{(M+N)}\\times(K+N)</li>\n          <li>2^M\\times(M+N)</li>\n        </ul>\n      </li>\n    </ol>\n  </li>\n  <li>Which among the following is not micro-controller ?\n    <ol>\n      <li>DMUX based µcontroller\n        <ul>\n          <li>MUX based µcontroller</li>\n          <li>ROM-based µcontroller</li>\n          <li>None</li>\n        </ul>\n      </li>\n    </ol>\n  </li>\n  <li>What is the ROM capacity of Preset counter based µcontroller ?\n    <ol>\n      <li>2^N\\times(N+K+\\log_2 M)\n        <ul>\n          <li>2^N\\times(K+\\log_2 M)</li>\n          <li>2^{(M+N)}\\times(K+N)</li>\n          <li>2^M\\times(M+N)</li>\n        </ul>\n      </li>\n    </ol>\n  </li>\n</ol>\n",
  "dir": "/docs/seq-lsi/",
  "url": "/docs/seq-lsi/rom-microcontrollers.html",
  "raw_content": "# ROM-based µcontrollers\n{: .no_toc}\n\n\n## Table of contents\n{: .no_toc .text-delta}\n\n1. TOC\n{:toc}\n\n\n## Introduction\n\nROM-based µcontrollers take the simple approach of implementing the combinational logic block of any sequential circuit (both the next state decoder and the output decoder) in a ROM circuit, while latches and counters can be used to make a more efficient use of the ROM capacity. In some cases, additional combinational MUX components are used for the same reason.\n\nThe following are examples of different ROM-based µcontrollers\n\n\n## General purpose ROM-based µcontroller\n\nA general purpose ROM-based µcontroller can be implemented as depicted in the block diagram below:\n\n![General purpose ROM-based microcontroller](/assets/images/seq/rom_general.svg)\n\nBoth, the output decoder and the next-state decoder are implemented in the ROM.\n\nThe number of address bits for the ROM must be greater than or equal to the sum of the number of input bits $M$ and the number of state variables $N$s. The size of the output word must be greater than or equal to the sum of the number of outputs html:\\(K\\)@@ and the number of state variables.\n\nROM capacity: $2^{(M+N)}\\times (K+N)$\n\n\n## Counter based µcontroller\n\nWhen the FSM corresponds to a simple sequence of states (without branches), a counter can be used to represent the state. The counter output (or state code) selects the corresponding output word from the ROM (A in the figure below). At the same time, part of the bits stored in the ROM (B in the figure) are used to select (via the MUX) the input associated which can produce the state transition for the current state.\n\n![Counter based microcontroller](/assets/images/seq/rom_counter.svg)\n\nROM capacity: $2^N \\times (K+\\log_2 M)$\n\n\n## Preset counter based µcontroller\n\nIf the FSM is mostly a simple sequence of state, but there are a few \"jumps\" to states out of the sequence, the previous circuit can be extended to store the address of the state which is out of the sequence and load it through the preset lines of the counter.\n\n![Preset counter based microcontroller](/assets/images/seq/rom_preset_counter.svg)\n\nROM capacity: $2^N \\times (N+K+\\log_2 M)$\n\n\n## MUX based µcontroller\n\nFor FSM which do not exhibit a simple sequence of states, the counter can be replaced by a MUX and the next state addresses must be stored in the ROM.\n\n![MUX based microcontroller](/assets/images/seq/rom_mux.svg)\n\nROM capacity: $2^N \\times (2N+K+\\log_2 M)$\n\n{:.quiz}\n\n1. What is the ROM capacity of Counter based µcontroller ?\n   1. 2^N\\times(K+\\log_2 M)\n   * 2^N\\times(N+K+\\log_2 M)\n   * 2^{(M+N)}\\times(K+N)\n   * 2^M\\times(M+N)\n\n2. Which among the following is not micro-controller ?\n   1. DMUX based µcontroller\n   * MUX based µcontroller\n   * ROM-based µcontroller\n   * None\n\n3. What is the ROM capacity of Preset counter based µcontroller ?\n   1. 2^N\\times(N+K+\\log_2 M)\n   * 2^N\\times(K+\\log_2 M)\n   * 2^{(M+N)}\\times(K+N)\n   * 2^M\\times(M+N)",
  "front_matter": {
    "layout": "circuitverse",
    "title": "ROM-based µcontrollers",
    "nav_order": "l0s000",
    "cvib_level": "basic",
    "parent": "Sequential LSI",
    "has_children": false
  },
  "front_matter_defaults": {
  },
  "http_url": "https://learn.circuitverse.org/docs/seq-lsi/rom-microcontrollers.html",
  "api_url": "https://learn.circuitverse.org/_api/pages/docs/seq-lsi/rom-microcontrollers.md"
}