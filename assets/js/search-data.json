{"0": {
    "doc": "About",
    "title": "About Interactive Book",
    "content": "Interactive-Book is © 2024 by CircuitVerse. ",
    "url": "/about.html#about-interactive-book",
    
    "relUrl": "/about.html#about-interactive-book"
  },"1": {
    "doc": "About",
    "title": "CircuitVerse",
    "content": "CircuitVerse is a digital circuit simulation platform. It aims to provide a platform where circuits can be designed and simulated using a graphical user interface. While users can design complete CPU implementations within the simulator, the software is designed primarily for educational use. CircuitVerse is an opensource project with an active community. ",
    "url": "/about.html#circuitverse",
    
    "relUrl": "/about.html#circuitverse"
  },"2": {
    "doc": "About",
    "title": "Contributors",
    "content": "Thanks to everyone who has contributed to the Interactive Book. ",
    "url": "/about.html#contributors",
    
    "relUrl": "/about.html#contributors"
  },"3": {
    "doc": "About",
    "title": "About",
    "content": " ",
    "url": "/about.html",
    
    "relUrl": "/about.html"
  },"4": {
    "doc": "Adders",
    "title": "Adders",
    "content": " ",
    "url": "/docs/comb-msi/adders.html",
    
    "relUrl": "/docs/comb-msi/adders.html"
  },"5": {
    "doc": "Adders",
    "title": "Table of contents",
    "content": ". | Half adder | Introduction | Block diagram | Truth table | Circuit diagram | Half adder from universal gates | Full adder | Introduction | Block diagram | Truth table | Circuit diagram | Full adder from 2 half adder | Full adder from universal gates | Ripple carry adder | Half subtractors | Introduction | Truth table | Circuit diagram | Half subtractor from universal gates | Full subtractors | Introduction | Truth table | Circuit diagram | Full subtractor from universal gates | N-Bit parallel adder and subtractor | Introduction | 4-bit parallel adder | Block diagram | N-bit parallel subtractor . | 4-bit parallel subtractor | Block diagram | 8-bit full adder and subtractor | . | . ",
    "url": "/docs/comb-msi/adders.html#table-of-contents",
    
    "relUrl": "/docs/comb-msi/adders.html#table-of-contents"
  },"6": {
    "doc": "Adders",
    "title": "Half adder",
    "content": " ",
    "url": "/docs/comb-msi/adders.html#half-adder",
    
    "relUrl": "/docs/comb-msi/adders.html#half-adder"
  },"7": {
    "doc": "Adders",
    "title": "Introduction",
    "content": "Half adder is a combinational logic circuit with two inputs and two outputs. The half adder circuit is designed to add two single bit binary number A and B. It is the basic building block for the addition of two single-bit numbers. This circuit has two outputs carry and sum. ",
    "url": "/docs/comb-msi/adders.html#introduction",
    
    "relUrl": "/docs/comb-msi/adders.html#introduction"
  },"8": {
    "doc": "Adders",
    "title": "Block diagram",
    "content": " ",
    "url": "/docs/comb-msi/adders.html#block-diagram",
    
    "relUrl": "/docs/comb-msi/adders.html#block-diagram"
  },"9": {
    "doc": "Adders",
    "title": "Truth table",
    "content": " ",
    "url": "/docs/comb-msi/adders.html#truth-table",
    
    "relUrl": "/docs/comb-msi/adders.html#truth-table"
  },"10": {
    "doc": "Adders",
    "title": "Circuit diagram",
    "content": " ",
    "url": "/docs/comb-msi/adders.html#circuit-diagram",
    
    "relUrl": "/docs/comb-msi/adders.html#circuit-diagram"
  },"11": {
    "doc": "Adders",
    "title": "Half adder from universal gates",
    "content": " ",
    "url": "/docs/comb-msi/adders.html#half-adder-from-universal-gates",
    
    "relUrl": "/docs/comb-msi/adders.html#half-adder-from-universal-gates"
  },"12": {
    "doc": "Adders",
    "title": "Full adder",
    "content": " ",
    "url": "/docs/comb-msi/adders.html#full-adder",
    
    "relUrl": "/docs/comb-msi/adders.html#full-adder"
  },"13": {
    "doc": "Adders",
    "title": "Introduction",
    "content": "Full adder is developed to overcome the drawback of Half Adder circuit. It can add two one-bit numbers A and B, and carry c. The full adder is a three-input and two output combinational circuit. ",
    "url": "/docs/comb-msi/adders.html#introduction-1",
    
    "relUrl": "/docs/comb-msi/adders.html#introduction-1"
  },"14": {
    "doc": "Adders",
    "title": "Block diagram",
    "content": " ",
    "url": "/docs/comb-msi/adders.html#block-diagram-1",
    
    "relUrl": "/docs/comb-msi/adders.html#block-diagram-1"
  },"15": {
    "doc": "Adders",
    "title": "Truth table",
    "content": " ",
    "url": "/docs/comb-msi/adders.html#truth-table-1",
    
    "relUrl": "/docs/comb-msi/adders.html#truth-table-1"
  },"16": {
    "doc": "Adders",
    "title": "Circuit diagram",
    "content": " ",
    "url": "/docs/comb-msi/adders.html#circuit-diagram-1",
    
    "relUrl": "/docs/comb-msi/adders.html#circuit-diagram-1"
  },"17": {
    "doc": "Adders",
    "title": "Full adder from 2 half adder",
    "content": " ",
    "url": "/docs/comb-msi/adders.html#full-adder-from-2-half-adder",
    
    "relUrl": "/docs/comb-msi/adders.html#full-adder-from-2-half-adder"
  },"18": {
    "doc": "Adders",
    "title": "Full adder from universal gates",
    "content": " ",
    "url": "/docs/comb-msi/adders.html#full-adder-from-universal-gates",
    
    "relUrl": "/docs/comb-msi/adders.html#full-adder-from-universal-gates"
  },"19": {
    "doc": "Adders",
    "title": "Ripple carry adder",
    "content": " ",
    "url": "/docs/comb-msi/adders.html#ripple-carry-adder",
    
    "relUrl": "/docs/comb-msi/adders.html#ripple-carry-adder"
  },"20": {
    "doc": "Adders",
    "title": "Half subtractors",
    "content": " ",
    "url": "/docs/comb-msi/adders.html#half-subtractors",
    
    "relUrl": "/docs/comb-msi/adders.html#half-subtractors"
  },"21": {
    "doc": "Adders",
    "title": "Introduction",
    "content": "Half subtractor is a combination circuit with two inputs and two outputs (difference and borrow). It produces the difference between the two binary bits at the input and also produces an output (Borrow) to indicate if a 1 has been borrowed. In the subtraction (A-B), A is called a Minuend bit and B is called a Subtrahend bit. ",
    "url": "/docs/comb-msi/adders.html#introduction-2",
    
    "relUrl": "/docs/comb-msi/adders.html#introduction-2"
  },"22": {
    "doc": "Adders",
    "title": "Truth table",
    "content": " ",
    "url": "/docs/comb-msi/adders.html#truth-table-2",
    
    "relUrl": "/docs/comb-msi/adders.html#truth-table-2"
  },"23": {
    "doc": "Adders",
    "title": "Circuit diagram",
    "content": " ",
    "url": "/docs/comb-msi/adders.html#circuit-diagram-2",
    
    "relUrl": "/docs/comb-msi/adders.html#circuit-diagram-2"
  },"24": {
    "doc": "Adders",
    "title": "Half subtractor from universal gates",
    "content": " ",
    "url": "/docs/comb-msi/adders.html#half-subtractor-from-universal-gates",
    
    "relUrl": "/docs/comb-msi/adders.html#half-subtractor-from-universal-gates"
  },"25": {
    "doc": "Adders",
    "title": "Full subtractors",
    "content": " ",
    "url": "/docs/comb-msi/adders.html#full-subtractors",
    
    "relUrl": "/docs/comb-msi/adders.html#full-subtractors"
  },"26": {
    "doc": "Adders",
    "title": "Introduction",
    "content": "The disadvantage of a half subtractor is overcome by full subtractor. The full subtractor is a combinational circuit with three inputs A, B, C and two output D and C’. A is the ‘minuend’, B is ‘subtrahend’, C is the ‘borrow’ produced by the previous stage, D is the difference output and C’ is the borrow output. ",
    "url": "/docs/comb-msi/adders.html#introduction-3",
    
    "relUrl": "/docs/comb-msi/adders.html#introduction-3"
  },"27": {
    "doc": "Adders",
    "title": "Truth table",
    "content": " ",
    "url": "/docs/comb-msi/adders.html#truth-table-3",
    
    "relUrl": "/docs/comb-msi/adders.html#truth-table-3"
  },"28": {
    "doc": "Adders",
    "title": "Circuit diagram",
    "content": " ",
    "url": "/docs/comb-msi/adders.html#circuit-diagram-3",
    
    "relUrl": "/docs/comb-msi/adders.html#circuit-diagram-3"
  },"29": {
    "doc": "Adders",
    "title": "Full subtractor from universal gates",
    "content": " ",
    "url": "/docs/comb-msi/adders.html#full-subtractor-from-universal-gates",
    
    "relUrl": "/docs/comb-msi/adders.html#full-subtractor-from-universal-gates"
  },"30": {
    "doc": "Adders",
    "title": "N-Bit parallel adder and subtractor",
    "content": " ",
    "url": "/docs/comb-msi/adders.html#n-bit-parallel-adder-and-subtractor",
    
    "relUrl": "/docs/comb-msi/adders.html#n-bit-parallel-adder-and-subtractor"
  },"31": {
    "doc": "Adders",
    "title": "Introduction",
    "content": "The Full Adder is capable of adding only two single-digit binary number along with a carry input. But in practice, you need to add binary numbers which are much longer than just one bit. To add two n-bit binary numbers you need to use the n-bit parallel adder. It uses several full adders in cascade. The carry output of the previous full adder is connected to carry input of the next full adder. ",
    "url": "/docs/comb-msi/adders.html#introduction-4",
    
    "relUrl": "/docs/comb-msi/adders.html#introduction-4"
  },"32": {
    "doc": "Adders",
    "title": "4-bit parallel adder",
    "content": "In the block diagram, A0 and B0 represent the LSB of the four-bit words A and B. Hence Full Adder-0 is the lowest stage. Hence its Cin has been permanently made 0. The rest of the connections are the same as those of n-bit parallel adder is shown in fig. The four-bit parallel adder is a very common logic circuit. ",
    "url": "/docs/comb-msi/adders.html#4-bit-parallel-adder",
    
    "relUrl": "/docs/comb-msi/adders.html#4-bit-parallel-adder"
  },"33": {
    "doc": "Adders",
    "title": "Block diagram",
    "content": " ",
    "url": "/docs/comb-msi/adders.html#block-diagram-2",
    
    "relUrl": "/docs/comb-msi/adders.html#block-diagram-2"
  },"34": {
    "doc": "Adders",
    "title": "N-bit parallel subtractor",
    "content": "The subtraction can be carried out by taking the 1’s or 2’s complement of the number to be subtracted. For example, you can perform the subtraction (A-B) by adding either 1’s or 2’s complement of B to A. That means you can use a binary adder to perform the binary subtraction. ",
    "url": "/docs/comb-msi/adders.html#n-bit-parallel-subtractor",
    
    "relUrl": "/docs/comb-msi/adders.html#n-bit-parallel-subtractor"
  },"35": {
    "doc": "Adders",
    "title": "4-bit parallel subtractor",
    "content": "The number to be subtracted (B) is first passed through inverters to obtain its 1’s complement. The 4-bit adder then adds A and 2’s complement of B to produce the subtraction. S3 S2 S1 S0 represents the result of binary subtraction (A-B) and carry output Cout represents the polarity of the result. If A &gt; B Cout = 0 and the result of binary form (A-B) then Cout = 1 and the result is in the 2’s complement form. ",
    "url": "/docs/comb-msi/adders.html#4-bit-parallel-subtractor",
    
    "relUrl": "/docs/comb-msi/adders.html#4-bit-parallel-subtractor"
  },"36": {
    "doc": "Adders",
    "title": "Block diagram",
    "content": " ",
    "url": "/docs/comb-msi/adders.html#block-diagram-3",
    
    "relUrl": "/docs/comb-msi/adders.html#block-diagram-3"
  },"37": {
    "doc": "Adders",
    "title": "8-bit full adder and subtractor",
    "content": ". | Consider a half adder circuit - for which of the following inputs A,B the sum (S) output is same ? . | 0,0 . | 0,1 | 1,0 | . | 1,1 | . | Using only which of the following gates in minimum number Half Adder circuit can be implemented ? . | NOR . | AND | OR | NOT | . | . | Which of the following is 4-bit Full Adder IC ? . | 74LS83 . | 7474 | 7408 | 7432 | . | . | Which of the following circuit is called n-bit parallel adder ? . | Ripple Carry Adder . | Half Adder | Half Substractor | Full Adder | . | . | In which of the following cases Adders can be used as a primary element ? . | Arithmatic Logic Unit (ALU) | Digital Calculator . | Memory Block | Loop Operation | . | . | . ",
    "url": "/docs/comb-msi/adders.html#8-bit-full-adder-and-subtractor",
    
    "relUrl": "/docs/comb-msi/adders.html#8-bit-full-adder-and-subtractor"
  },"38": {
    "doc": "Addition",
    "title": "Binary addition",
    "content": " ",
    "url": "/docs/binary-algebra/addition.html#binary-addition",
    
    "relUrl": "/docs/binary-algebra/addition.html#binary-addition"
  },"39": {
    "doc": "Addition",
    "title": "Table of contents",
    "content": ". | Addition | . ",
    "url": "/docs/binary-algebra/addition.html#table-of-contents",
    
    "relUrl": "/docs/binary-algebra/addition.html#table-of-contents"
  },"40": {
    "doc": "Addition",
    "title": "Addition",
    "content": "Binary addition is similar to Decimal addition. As this addition is binary, it implies that you cannot have a number greater than 1 i.e., when you do ‘1+1’ it gives 0 with carry 1 i.e, 10. Examples : 0 + 0 = 0 0 + 1 = 1 1 + 0 = 1 1 + 1 = 1 1 1 (3) + 1 0 (2) ----- 1 0 1 (5) ----- . In the above example, for units place gives 1 as the submission of 1 and 0, whereas, when addition occurs at the ten’s place where 1 and 1 are added, it gives 10 not 2 because this is binary addition which results in carry of 1 and 0 as a result of the submission. The example below gives 110 because it results in 111 at the tens place which is 11 in binary. As two 1’s gives 10, further if you add 1 it will give 11. 1 1 (3) + 1 1 (3) ----- 1 1 0 (6) ----- . | What is the answer to 1100 + 0011= ? . | 1111 . | 1101 | 1110 | 1100 | . | . | 11111111 + 00100000 = 100011111 is an example of ______ . | Overflow error . | 8 bit binary addition | . | . | What is the answer to 01101011 + 01010100= ? . | 10111111 . | 01111011 | 11101111 | 11101101 | . | . | . ",
    "url": "/docs/binary-algebra/addition.html",
    
    "relUrl": "/docs/binary-algebra/addition.html"
  },"41": {
    "doc": "ALU",
    "title": "Arithmetic Logic Unit",
    "content": " ",
    "url": "/docs/comb-lsi/alu.html#arithmetic-logic-unit",
    
    "relUrl": "/docs/comb-lsi/alu.html#arithmetic-logic-unit"
  },"42": {
    "doc": "ALU",
    "title": "Table of contents",
    "content": ". | Introduction | In detail | . ",
    "url": "/docs/comb-lsi/alu.html#table-of-contents",
    
    "relUrl": "/docs/comb-lsi/alu.html#table-of-contents"
  },"43": {
    "doc": "ALU",
    "title": "Introduction",
    "content": "An arithmetic logic unit (ALU) is a digital circuit used to perform arithmetic and logic operations. It represents the fundamental building block of the central processing unit (CPU) of a computer. Modern CPUs contain very powerful and complex ALUs. In addition to ALUs, modern CPUs contain a control unit (CU). The purpose of the ALU is to perform mathematical operations such as addition, subtraction, multiplication and division. Additionally, the ALU processes basic logical operations like AND/OR calculations. It serves as the computational hub of the Central Processing Unit (CPU) for a computer system . ",
    "url": "/docs/comb-lsi/alu.html#introduction",
    
    "relUrl": "/docs/comb-lsi/alu.html#introduction"
  },"44": {
    "doc": "ALU",
    "title": "In detail",
    "content": "So with the above building blocks i.e. half adder and full adder discussed in Combinational Analysis, lets construct a simple ALU that performs a arithmetic operation (1 bit addition) and does 3 logical operations namely AND, NOR and XOR as shown below. The multiplexer selects only one operation at a time. The operation selected depends on the selection lines of the multiplexer as shown in the truth table. Input = M0,M1 &amp; Output = Operation . | M0 | M1 | Operation | . | 0 | 0 | SUM | . | 0 | 1 | AND | . | 1 | 0 | OR | . | 1 | 1 | XOR | . Now you can take up the 1 bit ALU as block and construct a 4 bit ALU, which performs all the functions of the 1 bit ALU on the 4 bit inputs. Thus a single building block can be constructed and used recursively. The inputs A and B are four bits and the output is 4 bit as well. Figure below illustrates it: . 4 bit ALU There are a few important takeaways here: . | The selection lines MO and M1 select the function ALU performs. These selection lines combined with the input arguments and desired functions, an Instruction Set can be formed. | These Instructions can used to create meaningful programs. Since these are required to be easily available, they can be stored on ROM unit. | The input arguments A and B are often stored in Internal Registers. These along with other special purpose register form the registers of the microcontroller. | ROM memories are slower in speed, hence an intermediate high speed RAM is often used. | All the critical timings, decoding of the instructions are often grouped together in seperate control and timings unit. | If a Micro controller would be constructed only from ALU, RAM and ROM, there would not be any external interface. Hence, you now have Input/Output (I/O) ports. | Additional features such as Interrupts, communication protocols, EEPROM, Timers/Counters, Debug interfaces etc. are incorporated to make a controller complete. | . In above discussion you might have left out intricate details involved in an ALU, CPU design. But the aim was to understand ALU/CPU at a deeper level. | An ALU having n selection lines can provide upto _____ operations. | 2n | n / 2 . | 2^n | . | . | Input data can flow in parallel to multiple units inside the ALU. | True . | False | . | . | The data is stored in which of the following before ALU accesses it for operation ? . | ROM memory . | Internal registers | . | RAM memory | . | . ",
    "url": "/docs/comb-lsi/alu.html#in-detail",
    
    "relUrl": "/docs/comb-lsi/alu.html#in-detail"
  },"45": {
    "doc": "ALU",
    "title": "ALU",
    "content": " ",
    "url": "/docs/comb-lsi/alu.html",
    
    "relUrl": "/docs/comb-lsi/alu.html"
  },"46": {
    "doc": "Binary cubes",
    "title": "Binary cubes representation",
    "content": " ",
    "url": "/docs/logic-design/binary-cubes.html#binary-cubes-representation",
    
    "relUrl": "/docs/logic-design/binary-cubes.html#binary-cubes-representation"
  },"47": {
    "doc": "Binary cubes",
    "title": "Table of contents",
    "content": ". | Another abstract representation . | Functions of 1 variable | Functions of 2 variables | Functions of 3 variables and more | . | References | . ",
    "url": "/docs/logic-design/binary-cubes.html#table-of-contents",
    
    "relUrl": "/docs/logic-design/binary-cubes.html#table-of-contents"
  },"48": {
    "doc": "Binary cubes",
    "title": "Another abstract representation",
    "content": "The simplicity in applying the absorption and logic adjacency in Karnaugh Maps is derived from another way of representing binary functions: the binary cubes. This representation is also key to understand the Quine McCluskey algorithm to minimize logic functions. More information can be found in the section on Karnaugh Maps in [1] . Functions of 1 variable . Any logic function of a single variable $f(x)$ can be represented by a line: . Cube representing a logic function with one variable. The points at both ends of the line indicate the values that the variable $x$ can take (0 or 1). Functions of 2 variables . In a similar way a function of two variables can be represented by a square in a two-dimensional space: . Cube representing a logic function with two variables. In the figure it is easy to see that (1,0) and (0,1) are not adjacent, while (1,1) and (0,1) are adjacent. Functions of 3 variables and more . This representation can be further extended to higher orders. For instance, a function with three variables would be represented by the following three-dimensional cube: . Cube representing a logic function with three variables. Again, the adjacencies can be identified by the lines connecting the corners of the cube. If there is not a line, those binary numbers are not adjacent. The adjacency is key to group cubes in Karnaugh maps and in the Quine McCluskey method to obtain minimal expressions. ",
    "url": "/docs/logic-design/binary-cubes.html#another-abstract-representation",
    
    "relUrl": "/docs/logic-design/binary-cubes.html#another-abstract-representation"
  },"49": {
    "doc": "Binary cubes",
    "title": "References",
    "content": ". | [1]G. Donzellini, L. Oneto, D. Ponta, and D. Anguita, Introduction to Digital Systems Design. Springer International Publishing, 2018 [Online]. Available at: https://books.google.cl/books?id=va1qDwAAQBAJ | . | Which shape is represented by an object having exactly 1 variable? . | Line . | Circle | Triangle | . | . | Which shape is represented by an object having exactly 2 variables? . | Square . | Circle | Triangle | . | . | Which shape is represented by an object having exactly 3 variables? . | Cube . | Parallelogram | Sphere | . | . | . ",
    "url": "/docs/logic-design/binary-cubes.html#references",
    
    "relUrl": "/docs/logic-design/binary-cubes.html#references"
  },"50": {
    "doc": "Binary cubes",
    "title": "Binary cubes",
    "content": " ",
    "url": "/docs/logic-design/binary-cubes.html",
    
    "relUrl": "/docs/logic-design/binary-cubes.html"
  },"51": {
    "doc": "Binary numbers",
    "title": "Binary numbers",
    "content": " ",
    "url": "/docs/binary-representation/binary-numbers.html",
    
    "relUrl": "/docs/binary-representation/binary-numbers.html"
  },"52": {
    "doc": "Binary numbers",
    "title": "Table of contents",
    "content": ". | Introduction | Binary counting | Binary to decimal demonstration | . ",
    "url": "/docs/binary-representation/binary-numbers.html#table-of-contents",
    
    "relUrl": "/docs/binary-representation/binary-numbers.html#table-of-contents"
  },"53": {
    "doc": "Binary numbers",
    "title": "Introduction",
    "content": "Binary number system was invented by Gottfried Leibniz. As the word is prefixed with ‘Bi’ which is a Latin word and means ‘two’ in English. This brings us to the first two digits i.e., 0 and 1 which means that while counting in binary you cannot exceed 1. Infact all the numbers which you represent are made up of only two digits i.e., 0 and 1 which is quite interesting. Check out the binary representation of a decimal number (the numbers used for counting i.e., from 0-9) in binary. Example: Decimal Number :: 25 Binary Number :: 11001 . ",
    "url": "/docs/binary-representation/binary-numbers.html#introduction",
    
    "relUrl": "/docs/binary-representation/binary-numbers.html#introduction"
  },"54": {
    "doc": "Binary numbers",
    "title": "Binary counting",
    "content": "How do we count using binary? . It is just like counting in decimal except we reach 10 much sooner. | Binary | Explanation | . | 0 | Start at 0 | . | 1 | Then 1 | . | ??? | But then there is no symbol for 2 … what to do? | . Well how do we count in Decimal? . | Decimal | Explanation | . | 0 | Start at 0 | . | 1 | Then 1 | . | 2-8 | Count 1,2,3,4,5,6,7,8 | . | 9 | This is the **last digit** in Decimal | . | **1**0 | Start from back at **0** again, but carry **1** on the left | . The same thing is done in Binary … . | Binary | Explanation | . | 0 | Start at 0 | . | 1 | Then 1 | . | **1**0 | Now start back at **0** again, but carry **1** on the left | . | 11 | 1 more | . | ??? | But NOW what … ? | . What happens in Decimal? . | Decimal | Explanation | . | 99 | When you run out of digits, … | . | 100 | … start from back at **0** again, but carry **1** on the left | . And that is what is done in Binary … . | Binary | Explanation | . | 0 | Start at 0 | . | 1 | Then 1 | . | **1**0 | Now start back at **0** again, but carry **1** on the left | . | 11 | 1 more | . | **1**00 | start back at 0 again, and carry one to the number on the left but that number is already at 1 so it also goes back to 0 and 1 is carried to the next position on the left | . | 101 |   | . | 110 |   | . | 111 |   | . | **1**000 | Start back at 0 again (for all 3 digits), add 1 on the left | . ",
    "url": "/docs/binary-representation/binary-numbers.html#binary-counting",
    
    "relUrl": "/docs/binary-representation/binary-numbers.html#binary-counting"
  },"55": {
    "doc": "Binary numbers",
    "title": "Binary to decimal demonstration",
    "content": "Let’s tell you something more about conversion. Conversion from Binary to Decimal is quite a simple task. All you need to do is begin from the right. Follow the steps below: . | STEP 1: Write the decimal value of each digit on top of them respectively. The value which you seek to write is 2(place value from right) beginning from 0 i.e., 20, 21, 22 …. continuing up to 27. | STEP 2: Now, multiply each digit of binary number with its value. | STEP 3: Add ‘em all. | STEP 4: Result is ready :) | . Note: If the number is large, increase bits of the binary number on the left. Keep in mind that it’s value will increase subsequently. Example :: Decimal number :: 25 You can convert the 1st, 4th, and the 5th digit from the right by tapping on it to convert from 0 to 1. Further, the respective binary digit is multiplied with the value present on top of each digit. Now add. In this Case :: 1x16 + 1x8 + 0x4 + 0x2 + 1x1 = 25 which is the decimal equivalent of the binary number 11001 . ",
    "url": "/docs/binary-representation/binary-numbers.html#binary-to-decimal-demonstration",
    
    "relUrl": "/docs/binary-representation/binary-numbers.html#binary-to-decimal-demonstration"
  },"56": {
    "doc": "Binary numbers",
    "title": "Use the Simulator below to get the decimal equivalent of a binary number",
    "content": "Click on the ‘0’ to change it to ‘1’ and vice-versa . Binary 1280 640 320 160 80 40 20 10 Decimal0 . | Is 0110103 a binary number? . | No . | Yes | . | . | What is 10101 as a decimal number? . | 21 . | 10101 | 25 | 1000 | . | . | . ",
    "url": "/docs/binary-representation/binary-numbers.html#use-the-simulator-below-to-get-the-decimal-equivalent-of-a-binary-number",
    
    "relUrl": "/docs/binary-representation/binary-numbers.html#use-the-simulator-below-to-get-the-decimal-equivalent-of-a-binary-number"
  },"57": {
    "doc": "Boolean algebra",
    "title": "Boolean algebra",
    "content": " ",
    "url": "/docs/binary-algebra/boolean-algebra.html",
    
    "relUrl": "/docs/binary-algebra/boolean-algebra.html"
  },"58": {
    "doc": "Boolean algebra",
    "title": "Table of contents",
    "content": ". | Introduction | Rules of boolean algebra . | Null rule | Identity rule | Complement rule | Involution rule | . | Laws of boolean algebra . | Commutative law | Associative law | Idempotence law | Distributive law | Redundance law | De Morgan’s law | . | Bitwise operators | . ",
    "url": "/docs/binary-algebra/boolean-algebra.html#table-of-contents",
    
    "relUrl": "/docs/binary-algebra/boolean-algebra.html#table-of-contents"
  },"59": {
    "doc": "Boolean algebra",
    "title": "Introduction",
    "content": "Boolean Algebra was invented by George Boole and described in his first book known as The Mathematical Analysis of Logic in the year 1847. Further, he made several laws which were described by him in his second book known as An investigation of the Laws of Thought in the year 1854. As the word boolean is prefixed with the word ‘bool’ which implies a boolean value which could either be true or false. In this case it is referred to as 0 and 1. ",
    "url": "/docs/binary-algebra/boolean-algebra.html#introduction",
    
    "relUrl": "/docs/binary-algebra/boolean-algebra.html#introduction"
  },"60": {
    "doc": "Boolean algebra",
    "title": "Rules of boolean algebra",
    "content": "These are the building blocks of Boolean Algebra. Try not to forget these as these are the most important one’s and you can solve any digital equation with the help of the described rules and Laws below. Null rule . As the rule states ‘null’ which means that when 1 is added i.e., ‘OR’ and when 0 is ‘AND’ with a variable it gives 1 and 0 respectively. A + 1 = 1 A . 0 = 0 . Identity rule . As the rule states ‘identity’ which means that when 0 is added i.e., ‘OR’ and when 0 is ‘OR’ with a variable it gives the variable back. A + 0 = A A . 1 = A . Complement rule . Whenever ‘AND’ or ‘OR’ is used with the negation of the variable and the variable itself it gives 0 and 1 respectively. A + A' = 1 A . A' = 0 . Involution rule . Any variable when double negated gives the variable back. (A')' = A . ",
    "url": "/docs/binary-algebra/boolean-algebra.html#rules-of-boolean-algebra",
    
    "relUrl": "/docs/binary-algebra/boolean-algebra.html#rules-of-boolean-algebra"
  },"61": {
    "doc": "Boolean algebra",
    "title": "Laws of boolean algebra",
    "content": "There are six Laws in Boolean Algebra. All six laws are described below in increasing order of importance. Note: We can construct any digital circuit with the help of only two gates namely AND and OR along with NOT to use a respective variables in it’s high or low state as required. Keep in mind that all laws are stated for us to design any digital circuit with the help of only AND and OR gate. Similarly, these laws are stated for the same. Commutative law . The word commutative is prefixed with the word ‘commute’ which means movement i.e., the movement of variables meaning if you switch or change the position of variables it won’t affect the result. Examples: A + B = B + A A . B = B . A . Associative law . The position of parenthesis does not matter. The basic idea of this law is that which set of variables you resolve first is not a matter of fact. Examples: (A + B) + C = A + (B + C) (A . B) . C = A . (B . C) . Idempotence law . As the word states ‘Identity’ tries to understand the importance of the term. When we apply AND gate to a single variable it will output the variable itself(*Conditions that we do not know the value of that variable). Similar will be the case when we will apply the OR gate. If you understand this then you got it ;) . Examples: A + A = A A . A = A . Distributive law . Suppose it’s your birthday and you want to distribute sweets to everyone in the class. What would the birthday reader do? Go to each person and distribute the sweets?. Awesome. That’s what happens in the case of Distributive law. Think of the number outside the parenthesis as the birthday variable who needs to attend each and every variable inside the parenthesis. Follow up the examples to understand better. Examples: A (B + C) = A.B + A.C A + (B.C) = (A + B)(A + C) . Redundance law . What do you do when you find two identical items while going to a track inside your bag? Obviously you remove one of the two redundant items. That’s what you need to do here, extract the common variable, and solve the expression inside the parenthesis. Examples: A + A.B = A A(A + B) = A //Here initial expression is reduced to A.A + A.B(Distributive Law) which can further be A + A.B(using Identity Law) . De Morgan’s law . This is the most important law of Boolean Algebra. Remember the phrase ‘Break the Line, change the Sign’ and ‘Join the Line, change the sign’ both are applicable. Meaning break the negate and change AND to OR and OR to AND within that negate sign. Do not remove the line. As the phrase speaks of breaking the line and changing the sign not removing the line. Be careful while applying this law. (A + B)' = (A'B') (AB)' = (A' + B') . Try to implement any gate you wish to with the help of the simulator present below, where ‘switch on’ means a high state i.e., 1 and ‘switch off’ means a low state i.e., 0. Select the gate in between with the help of the list present. Click on gate to toggle between other gates . AND OR XOR NOT = . ",
    "url": "/docs/binary-algebra/boolean-algebra.html#laws-of-boolean-algebra",
    
    "relUrl": "/docs/binary-algebra/boolean-algebra.html#laws-of-boolean-algebra"
  },"62": {
    "doc": "Boolean algebra",
    "title": "Bitwise operators",
    "content": "| Operator | Explanation | . | bit1 &amp; bit2 | The AND(****&amp;****) operator is used to compare two bits and gives a result equal to 1 if both the bits are 1, and it returns 0, if any one bit is 0. | . | bit1 | bit2 | The OR(****|****) operator is used to compare two bits and gives a result equal to 1 if anyone of the bit is 1 or both the bits are 1, and if both are 0 it returns 0. | . | bit1 ^ bit2 | The EXCLUSIVE-OR(****^****) also known as XOR(****^****) operator is used to compare two bits and returns 1 if any one of the bit is 1 and it returns 0 if both the bits are 0 or 1. | . | ~bit1 | The COMPLEMENT(****~****) operator is similar to 1’s complement and can be used to convert all the 1’s to 0’s and all the 1’ to 0’s of the operand. | . Binary 128 0 0 64 0 0 32 0 0 16 0 0 8 0 0 4 0 0 2 0 0 1 0 0 Decimal OR &nbsp;Answer 0 0 0 0 0 0 0 0 0 . | Which among the following states DeMorgan’s theorem ? . | (AB)’ = A’ + B’ . | (A + B)’ = A’ * B | A’ + B’ = A’B’ | (AB)’ = A’ + B | . | . | Idempotence law states that _________ ? . | A + A = A . | A + B = B + A | A + A.B = A | A + B)’ = (A’B’) | . | . | A(A + B) = A is known as _________ ? . | Redundance law . | Distributive law | Associative law | . | . | A(A + B) is equivalent to _________ ? . | A . | (A’B’) | (A’B’) | A’ | . | . | (A')' = A is known as _________ ? . | Involution rule . | Distributive rule | Associative rule | Redundance rule | . | . | . ",
    "url": "/docs/binary-algebra/boolean-algebra.html#bitwise-operators",
    
    "relUrl": "/docs/binary-algebra/boolean-algebra.html#bitwise-operators"
  },"63": {
    "doc": "Boolean functions",
    "title": "Boolean functions",
    "content": " ",
    "url": "/docs/binary-algebra/boolean-functions.html",
    
    "relUrl": "/docs/binary-algebra/boolean-functions.html"
  },"64": {
    "doc": "Boolean functions",
    "title": "Table of contents",
    "content": ". | Introduction | Mathematical definition | Important concepts | Further reading | References | . ",
    "url": "/docs/binary-algebra/boolean-functions.html#table-of-contents",
    
    "relUrl": "/docs/binary-algebra/boolean-functions.html#table-of-contents"
  },"65": {
    "doc": "Boolean functions",
    "title": "Introduction",
    "content": "A mathematical expression consisting of Boolean variables combined using the Boolean algebra operators: logical addition (OR), multiplication (AND) and negation (NOT) is a Boolean function. ",
    "url": "/docs/binary-algebra/boolean-functions.html#introduction",
    
    "relUrl": "/docs/binary-algebra/boolean-functions.html#introduction"
  },"66": {
    "doc": "Boolean functions",
    "title": "Mathematical definition",
    "content": "If $k$ is the number of Boolean variables of the function, then the function $f(x_1,\\ldots,x_k)$ and its domain and codomain are defined as $f:{0,1}^k\\rightarrow{0,1}$ . ",
    "url": "/docs/binary-algebra/boolean-functions.html#mathematical-definition",
    
    "relUrl": "/docs/binary-algebra/boolean-functions.html#mathematical-definition"
  },"67": {
    "doc": "Boolean functions",
    "title": "Important concepts",
    "content": "The following is a list of definitions for fundamental concepts used in Boolean functions: . | Literal: A logic variable or its complement $(x,\\overline{x},y_0,\\ldots)$. | Product term: An expression where literals are combined by the logical AND operator $(x\\overline{y}z,\\ldots)$. | Sum term: An expression where literals are combined by the logical OR operator $(y+\\overline{z},\\ldots)$. | Normal term: A (product or sum) term without repeated variables. | Sum of Products (SoP): A sum of product terms $(\\overline{x}+xwz+x\\overline{y})$. | Product of Sums (PoS): A product of sum terms $((x+y+z)(z+\\overline{w})(z+\\overline{x}))$. | . ",
    "url": "/docs/binary-algebra/boolean-functions.html#important-concepts",
    
    "relUrl": "/docs/binary-algebra/boolean-functions.html#important-concepts"
  },"68": {
    "doc": "Boolean functions",
    "title": "Further reading",
    "content": ". | Section 3.2 “Switching functions” in [1]. | Section 1.3 “Boolean Functions” in [2]. | Chapter 3 “Boolean Algebra and Logic” in [3]. | . ",
    "url": "/docs/binary-algebra/boolean-functions.html#further-reading",
    
    "relUrl": "/docs/binary-algebra/boolean-functions.html#further-reading"
  },"69": {
    "doc": "Boolean functions",
    "title": "References",
    "content": ". | [1]Z. Kohavi and N. K. Jha, Switching and Finite Automata Theory. Cambridge University Press, 2010 [Online]. Available at: https://books.google.cl/books?id=jZIxam8Rb9AC | [2]G. Donzellini, L. Oneto, D. Ponta, and D. Anguita, Introduction to Digital Systems Design. Springer International Publishing, 2018 [Online]. Available at: https://books.google.cl/books?id=va1qDwAAQBAJ | [3]M. Ferdjallah, Introduction to Digital Systems: Modeling, Synthesis, and Simulation Using VHDL. Wiley, 2011 [Online]. Available at: https://books.google.cl/books?id=kJRoR8AAu1AC | . | Every Boolean Function can be expressed as ________ ? . | Algebraic expression . | Laplace expression | Binomial expression | . | . | SOP (Sum of Product) is referred as ________ ? . | (x+xwz+xy) . | ((x+y+z)(z+w)(z+x)) | . | . | . ",
    "url": "/docs/binary-algebra/boolean-functions.html#references",
    
    "relUrl": "/docs/binary-algebra/boolean-functions.html#references"
  },"70": {
    "doc": "Canonical functions",
    "title": "Canonical functions",
    "content": " ",
    "url": "/docs/logic-design/canonical.html",
    
    "relUrl": "/docs/logic-design/canonical.html"
  },"71": {
    "doc": "Canonical functions",
    "title": "Table of contents",
    "content": ". | Introduction | Truth table formation | Truth table formation | Sum of product expressions (SOP) | Product of sum expressions (POS) | Canonical expressions . | Minterms | Maxterms | . | Conversion of canonical forms | Conversion from minimal to canonical forms . | Minimal POS to canonical POS | Minimal SOP to canonical SOP | . | Example algebraic simplification | Undefined input &amp; don’t-cares | Try the interactive truth table generator | Methods to simplify the boolean function | . ",
    "url": "/docs/logic-design/canonical.html#table-of-contents",
    
    "relUrl": "/docs/logic-design/canonical.html#table-of-contents"
  },"72": {
    "doc": "Canonical functions",
    "title": "Introduction",
    "content": "Boolean Functions are comprised of two components i.e., Variables and Logic operations(AND, OR, NOT…etc). Any equation with the mixture of these two components forms a Boolean function. The value of variables may or may not be pre-defined. The shorthand notation for a boolean function is that it is represented with a capital F followed by parenthesis comprising of all variables of that equation separated by comma(‘,’). You can represent any boolean expression in form of a Truth Table. Follow up to know How? Consider the following example: . Example: Shorthand notation representing the boolean expression / F(A,B) = A + B //This is a boolean function comprising of variables A and B F(A, B, C) = A(B + C(A + B)) \\ Boolean Expression . ",
    "url": "/docs/logic-design/canonical.html#introduction",
    
    "relUrl": "/docs/logic-design/canonical.html#introduction"
  },"73": {
    "doc": "Canonical functions",
    "title": "Truth table formation",
    "content": "Truth Table is formed by evaluating the Boolean expression for each and every truth value of a variable. Now truth values of a variable are either ‘true’ or ‘false’. The main point is to evaluate the value of Boolean expression for each and every combination of the Truth values of variables present. Suppose there is only one variable, it implies that it can hold either ‘true’ or ‘false’ but, when there are two variables then you can have a combination of {TT, TF, FT, FF}(T -&gt; True, F -&gt; False). Implies you need to evaluate the value of expression for each and every Truth value of a variable. The above implications bring us to a conclusion that there can be 2^(number of variables) number of combination for a single boolean expression. Follow up the examples below to learn how to map those values. Example: F(A,B) = A + B . Truth Table:: . | A | B | F(A,B) |   | . | 0 | 0 | 0 | a | . | 0 | 1 | 1 |   | . | 1 | 0 | 1 |   | . | 1 | 1 | 1 |   | . Here you have 4 combinations for 2 variables, try to grasp the next example where variables are 3 which implies 8 combinations. Make a note of how Truth values of a variable are written under each column for every variable. Example: F(A,B,C) = A + B.C . ",
    "url": "/docs/logic-design/canonical.html#truth-table-formation",
    
    "relUrl": "/docs/logic-design/canonical.html#truth-table-formation"
  },"74": {
    "doc": "Canonical functions",
    "title": "Truth table formation",
    "content": "A truth table shows a table having all the combinations of the inputs and their corresponding results. The switching equation can also be converted into a Truth Table. For example- Consider the switching equation: F(A,B,C) = A + BC. | A | B | C | F | . | 0 | 0 | 0 | 0 | . | 0 | 0 | 1 | 0 | . | 0 | 1 | 0 | 0 | . | 0 | 1 | 1 | 0 | . | 1 | 0 | 0 | 1 | . | 1 | 0 | 1 | 1 | . | 1 | 1 | 0 | 1 | . | 1 | 1 | 1 | 1 | . ",
    "url": "/docs/logic-design/canonical.html#truth-table-formation-1",
    
    "relUrl": "/docs/logic-design/canonical.html#truth-table-formation-1"
  },"75": {
    "doc": "Canonical functions",
    "title": "Sum of product expressions (SOP)",
    "content": "Let’s take a look at an more complex expression F(A, B, C, D) = AB'C + BD + CD + D. Let’s generate the truth table: . | F(AB’C+BD+CD+D) | A | B | C | D | . | 0 | 0 | 0 | 0 | 0 | . | 1 | 0 | 0 | 0 | 1 | . | 0 | 0 | 0 | 1 | 0 | . | 1 | 0 | 0 | 1 | 1 | . | 0 | 0 | 1 | 0 | 0 | . | 1 | 0 | 1 | 0 | 1 | . | 0 | 0 | 1 | 1 | 0 | . | 1 | 0 | 1 | 1 | 1 | . | 0 | 1 | 0 | 0 | 0 | . | 1 | 1 | 0 | 0 | 1 | . | 1 | 1 | 0 | 1 | 0 | . | 1 | 1 | 0 | 1 | 1 | . | 0 | 1 | 1 | 0 | 0 | . | 1 | 1 | 1 | 0 | 1 | . | 0 | 1 | 1 | 1 | 0 | . | 1 | 1 | 1 | 1 | 1 | . In this example an interesting observation is that, you are doing a sum of product evaluation, that is, AB'C + BD + CD + D is a sum of products. The significance of sum of product is that when you are doing +, you are in fact invoking the OR operator. Moreover, the OR operator returns true so long as any one of its arguments returns true. Therefore, if any of the terms in the sum of product (SOP) expressions is true, then you know that the final expression is true for certain. ",
    "url": "/docs/logic-design/canonical.html#sum-of-product-expressions-sop",
    
    "relUrl": "/docs/logic-design/canonical.html#sum-of-product-expressions-sop"
  },"76": {
    "doc": "Canonical functions",
    "title": "Product of sum expressions (POS)",
    "content": "Let’s take a look at another expression F(A, B, C, D) = (A + B + C + D')(A + B' + C' + D)(A' + B' + C + D'). Let’s generate the truth table: . | F(A,B,C,D) | A | B | C | D | . | 1 | 0 | 0 | 0 | 0 | . | 0 | 0 | 0 | 0 | 1 | . | 1 | 0 | 0 | 1 | 0 | . | 1 | 0 | 0 | 1 | 1 | . | 1 | 0 | 1 | 0 | 0 | . | 1 | 0 | 1 | 0 | 1 | . | 1 | 0 | 1 | 1 | 0 | . | 1 | 0 | 1 | 1 | 1 | . | 1 | 1 | 0 | 0 | 0 | . | 0 | 1 | 0 | 0 | 1 | . | 1 | 1 | 0 | 1 | 0 | . | 1 | 1 | 0 | 1 | 1 | . | 1 | 1 | 1 | 0 | 0 | . | 1 | 1 | 1 | 0 | 1 | . | 1 | 1 | 1 | 1 | 0 | . | 1 | 1 | 1 | 1 | 1 | . Judging by the algebraic expression, it is evident that the expression is a product of sums. Such an expression is called a Product of Sum expression or POS in short. Here the sum terms are defined by using the OR operation and the product term is defined by using AND operation. When two or more sum terms are multiplied by a Boolean OR operation, the resultant output expression will be in the form of product-of-sums form or POS form. The product-of-sums form is also called as Conjunctive Normal Form as the sum terms are ANDed together and Conjunction operation is logical AND. Product-of-sums form is also called as Standard POS. ",
    "url": "/docs/logic-design/canonical.html#product-of-sum-expressions-pos",
    
    "relUrl": "/docs/logic-design/canonical.html#product-of-sum-expressions-pos"
  },"77": {
    "doc": "Canonical functions",
    "title": "Canonical expressions",
    "content": "Before understanding Canonical Expressions, let us understand Minterms and Maxterms first. Minterms . A minterm is defined as the product term of n variables, in which each of the n variables will appear once either in its complemented or un-complemented form. The min term is denoted as mi where i is in the range of 0 ≤ i &lt; 2n. For a 2-variable (x and y) Boolean function, the possible minterms are: . x’y’, x’y, xy’ and xy. For a 3-variable (x, y and z) Boolean function, the possible minterms are: . x’y’z’, x’y’z, x’yz’, x’yz, xy’z’, xy’z, xyz’ and xyz. 1 – Minterms = minterms for which the function F = 1. 0 – Minterms = minterms for which the function F = 0. Any Boolean function can be expressed as the sum (OR) of its 1- min terms. The representation of the equation will be . F(list of variables) = Σ(list of 1-min term indices) . Ex: F(x, y, z) = Σ(3, 5, 6, 7) . The inverse of the function can be expressed as a sum (OR) of its 0- min terms. The representation of the equation will be . F(list of variables) = Σ(list of 0-min term indices) Ex: F’(x, y, z) = Σ(0, 1, 2, 4) . Examples of canonical form of sum of products expressions (min term canonical form): . | Z = XY + XZ′ . | F = XYZ′ + X′YZ + X′YZ′ + XY′Z + XYZ . | . In standard SOP form, the maximum possible product terms for n number of variables are given by 2n. So, for 2 variable equations, the product terms are 22 = 4. Similarly, for 3 variable equations, the product terms are 23 = 8. Maxterms . A max term is defined as the product of n variables, within the range of 0 ≤ i &lt; 2n. The max term is denoted as Mi. In max term, each variable is complemented, if its value is assigned to 1, and each variable is un-complemented if its value is assigned to 0. For a 2-variable (x and y) Boolean function, the possible max terms are: . x + y, x + y’, x’ + y and x’ + y’ . For a 3-variable (x, y and z) Boolean function, the possible maxterms are: . x + y + z, x + y + z’, x + y’ + z, x + y’ + z’, x’ + y + z, x’ + y + z’, x’ + y’ + z and x’ + y’ + z’ . 1 – Max terms = max terms for which the function F = 1. 0 – max terms = max terms for which the function F = 0. Any Boolean function can be expressed the product (AND) of its 0 – max terms. The representation of the equation will be . F(list of variables) = Π (list of 0-max term indices) . Ex: F(x, y, z) = Π(0, 1, 2, 4) . The inverse of the function can be expressed as a product (AND) of its 1 – max terms. The representation of the equation will be . F(list of variables) = Π(list of 1-max term indices) . Ex: F’(x, y, z) = Π(3, 5, 6, 7) . Examples of canonical form of product of sums expressions (max term canonical form): . 1. Z = (X + Y).(X + Y′) 2. F = (X′ + Y + Z′).(X′ + Y + Z).(X′ + Y′ + Z′) . In standard POS form, the maximum possible sum terms for n number of variables are given by 2n. So, for 2 variable equations, the sum terms are 22 = 4. Similarly, for 3 variable equations, the sum terms are 23 = 8. Having understood minterms and maxterms, you are now in a position to understand canonical forms. Any Boolean function that is expressed as a sum of minterms or as a product of maxterms is said to be in its canonical form. When the SOP form of a Boolean expression is in canonical form, then each of its product term is called minterm. So, the canonical form of sum of products function is also known as minterm canonical form or Sum-of-minterms or standard canonical SOP form. Similarly, when the POS form of a Boolean expression is in canonical form, then each of its sum term is called maxterm. So, the canonical form of product of sums function is also known as maxterm canonical form or Product-of sum or standard canonical POS form. ",
    "url": "/docs/logic-design/canonical.html#canonical-expressions",
    
    "relUrl": "/docs/logic-design/canonical.html#canonical-expressions"
  },"78": {
    "doc": "Canonical functions",
    "title": "Conversion of canonical forms",
    "content": "You can represent the one canonical formed equation in other canonical form i.e. you can represent the SOP form of equation in POS form and POS form equation in SOP form. To convert the canonical equations, you interchange the Σ and Π symbols after listing out the index numbers of the equations, which are excluded from the original form of equation. The important thing to remember about Boolean functions is that, the SOP and POS forms are Duals to each other. There are 2 steps to follow to convert the canonical form of the equations. They are:- . | Interchanging the operational symbols, Σ and Π in the equation. | Use the De Morgan’s principle of Duality to the index numbers of the Boolean function or writing the indexes of the terms that are not presented in the given form of equation. | . For Example:- . The SOP function F(A, B, C) = ∑(0, 2, 3, 5, 7) = A’B’C’ + AB’C’ + AB’C + ABC’ + ABC is written in POS form by . | changing the operational sign to Π . | writing the missing indexes of the terms, 001, 100 and 110. Now write the sum form for these noted terms. | . 001 = (A + B + C'), 100 = (A' + B + C), 110 = (A' + B’ + C) . Writing down the new equation in the form of POS form, . F(A, B, C) = Π(1, 4, 6) = (A + B + C') * (A' + B + C) * (A' + B’ + C’) . The POS function F(A, B, C) = Π(2, 3, 5) = (A + B' + C)(A + B' + C')(A' + B + C') is written in SOP form by . | changing the operational sign to Σ . | writing the missing indexes of the terms, 000, 001, 100, 110, and 111. Now write the product form for these noted terms. | . 000 = A’B’C’, 001 = A’B’C, 100 = AB’C’, 110 = ABC’, 111 = ABC . Writing down the new equation in the form of SOP form, . F(A, B, C) = Σ(0, 1, 4, 6, 7) = (A’B'C’) + (A’B’C) + (AB’C’) + (ABC’) + (ABC) . ",
    "url": "/docs/logic-design/canonical.html#conversion-of-canonical-forms",
    
    "relUrl": "/docs/logic-design/canonical.html#conversion-of-canonical-forms"
  },"79": {
    "doc": "Canonical functions",
    "title": "Conversion from minimal to canonical forms",
    "content": "Minimal POS to canonical POS . You can include all the variables in each product term of the POS form equation, which doesn’t have all the variables by converting into standard POS form. The normal POS form function can be converted to standard POS form by using the Boolean algebraic law, (A * A’ = 0) and by following the below steps. | By adding each non-standard sum term to the product of its missing variable and its complement, which results in 2 sum terms . | Applying Boolean algebraic law, A + BC = (A + B) * (A + C) . | By repeating the step 1, until all resulting sum terms contain all variables . | . By these three steps you can convert the POS function into standard POS function. Example: F = (A’ + B + C)*(B’ + C + D’) * (A + B’ + C’ + D) . In the first term, the variable D or D’ is missing, so add D*D’ = 1 to it. Then . (A’ + B + C + D*D’) = (A’ + B + C + D) * (A’ + B + C + D’) . Similarly, in the second term, the variable A or A’ is missing, so add A*A’ = 1 to it. Then . (B’ + C + D’ + A*A’) = (A + B’ + C + D’) * (A’ + B’ + C + D’) . The third term is already in the standard form, as it has all the variables. Now the standard POS form equation of the function is . F = (A’ + B + C + D) * (A’ + B + C + D’) * (A + B’ + C + D’) * (A’ + B’ + C + D’) * (A + B’ + C’ + D) . Minimal SOP to canonical SOP . You can include all the variables in each product term of the SOP form equation, which doesn’t have all the variables by converting into standard SOP form. The normal SOP form function can be converted to standard SOP form by using the Boolean algebraic law, (A + A’ = 1) and by following the below steps. | By multiplying each non-standard product term with the sum of its missing variable and its complement, which results in 2 product terms . | By repeating the step 1, until all resulting product terms contain all variables . | . By these two steps you can convert the SOP function into standard SOP function. In this process, for each missing variable in the function, the number of product terms will double. Example: Convert the non standard SOP function F = x y + x z + y z . Sol: . F = x y + x z + y z = x y (z + z’) + x (y + y’) z + (x + x’) y z = x y z + x y z’ + x y z + x y’ z + x y z + x’ y z = x y z + x y z’ + x y’ z + x’ y z . The standard SOP form is F = x y z + x y z’ + x y’ z + x’ y z . ",
    "url": "/docs/logic-design/canonical.html#conversion-from-minimal-to-canonical-forms",
    
    "relUrl": "/docs/logic-design/canonical.html#conversion-from-minimal-to-canonical-forms"
  },"80": {
    "doc": "Canonical functions",
    "title": "Example algebraic simplification",
    "content": "Let’s simplify our expression from the previous truth table example. you can apply ordinary algebra tricks such as factoring. Remember that the + operator invokes the OR gate, and that true or x always returns true regardless of x (as shown in our first truth table). AB'C + BD + CD + D // Initial expression AB'C + BD + D // Applying Absorption Law on CD + D, which reduces it to D AB'C + D // Applying Absorption Law on BD + D, which reduces it to D =&gt; AB'C + D // Final expression . As an exercise to the reader, complete the truth table to show that they are logically equivalent. ",
    "url": "/docs/logic-design/canonical.html#example-algebraic-simplification",
    
    "relUrl": "/docs/logic-design/canonical.html#example-algebraic-simplification"
  },"81": {
    "doc": "Canonical functions",
    "title": "Undefined input &amp; don’t-cares",
    "content": "The definition of a “don’t-care” is a combination of input values that is not known, and could be either 0 or 1. For the purposes of variable simplification, we would choose the greedy approach of picking between {0, 1} such that the simplified expression has less terms. Let’s consider the following truth-table: . | A | B | F(A,B) | . | 0 | 0 | 1 | . | 0 | 1 | 1 | . | 1 | 0 | ? | . | 1 | 1 | 1 | . We observe that we have a don’t-care. Let’s observe the differences in cases for F(1,0): . Case 1: F(1, 0) = 0 =&gt; F(AB) = A'B' + A'B + AB Case 2: F(1, 0) = 1 =&gt; F(AB) = A'B' + A'B + AB' + AB Simplifying the cases... F(AB) = A'B' + A'B + AB = A'(B' + B) + AB = A' + AB F(AB) = A'B' + A'B + AB' + AB = A'(B' + B) + A (B' + B) = A' + A = 1 . You can clearly see, if you set F(1, 0) = 1, you get a true value for any input. Therefore, for the purposes of variable simplification, you can simply let F(1, 0) = 1 thus implying F(A, B) = 1. ",
    "url": "/docs/logic-design/canonical.html#undefined-input--dont-cares",
    
    "relUrl": "/docs/logic-design/canonical.html#undefined-input--dont-cares"
  },"82": {
    "doc": "Canonical functions",
    "title": "Try the interactive truth table generator",
    "content": ". ",
    "url": "/docs/logic-design/canonical.html#try-the-interactive-truth-table-generator",
    
    "relUrl": "/docs/logic-design/canonical.html#try-the-interactive-truth-table-generator"
  },"83": {
    "doc": "Canonical functions",
    "title": "Truth Table Generator",
    "content": "Enter your boolean logic expression in the following format AND = AB&emsp; OR = A+B&emsp; NOT = A' NAND = (AB)' NOR = (A+B)' . This app requires JavaScript to run. Please enable JavaScript and refresh this page. ",
    "url": "/docs/logic-design/canonical.html",
    
    "relUrl": "/docs/logic-design/canonical.html"
  },"84": {
    "doc": "Canonical functions",
    "title": "Methods to simplify the boolean function",
    "content": "The following methods can be used to simplify the the Boolean function: . | The Karnaugh-map or K-map method. | The NAND gate method. | . ",
    "url": "/docs/logic-design/canonical.html#methods-to-simplify-the-boolean-function",
    
    "relUrl": "/docs/logic-design/canonical.html#methods-to-simplify-the-boolean-function"
  },"85": {
    "doc": "Clock signals",
    "title": "Clock signals",
    "content": " ",
    "url": "/docs/seq-ssi/clock-signals.html",
    
    "relUrl": "/docs/seq-ssi/clock-signals.html"
  },"86": {
    "doc": "Clock signals",
    "title": "Table of contents",
    "content": ". | Clock signal | Types of triggering . | Level triggering | Edge triggering | . | . ",
    "url": "/docs/seq-ssi/clock-signals.html#table-of-contents",
    
    "relUrl": "/docs/seq-ssi/clock-signals.html#table-of-contents"
  },"87": {
    "doc": "Clock signals",
    "title": "Clock signal",
    "content": "Clock signal is a periodic signal and its ON time and OFF time need not be the same. You can represent the clock signal as a square wave, when both its ON time and OFF time are same. This clock signal is shown in the following figure. In the above figure, square wave is considered as clock signal. This signal stays at logic High (5V) for some time and stays at logic Low (0V) for equal amount of time. This pattern repeats with some time period. In this case, the time period will be equal to either twice of ON time or twice of OFF time. You can represent the clock signal as train of pulses, when ON time and OFF time are not same. This clock signal is shown in the following figure. In the above figure, train of pulses is considered as clock signal. This signal stays at logic High (5V) for some time and stays at logic Low (0V) for some other time. This pattern repeats with some time period. In this case, the time period will be equal to sum of ON time and OFF time. The reciprocal of the time period of clock signal is known as the frequency of the clock signal. All sequential circuits are operated with clock signal. So, the frequency at which the sequential circuits can be operated accordingly the clock signal frequency has to be chosen. ",
    "url": "/docs/seq-ssi/clock-signals.html#clock-signal",
    
    "relUrl": "/docs/seq-ssi/clock-signals.html#clock-signal"
  },"88": {
    "doc": "Clock signals",
    "title": "Types of triggering",
    "content": "Following are the two possible types of triggering that are used in sequential circuits. | Level triggering | Edge triggering | . Level triggering . There are two levels, namely logic High and logic Low in clock signal. Following are the two types of level triggering. | Positive level triggering | Negative level triggering | . If the sequential circuit is operated with the clock signal when it is in Logic High, then that type of triggering is known as Positive level triggering. It is highlighted in below figure. If the sequential circuit is operated with the clock signal when it is in Logic Low, then that type of triggering is known as Negative level triggering. It is highlighted in the following figure. Edge triggering . There are two types of transitions that occur in clock signal. That means, the clock signal transitions either from Logic Low to Logic High or Logic High to Logic Low. Following are the two types of edge triggering based on the transitions of clock signal. | Positive edge triggering | Negative edge triggering | . If the sequential circuit is operated with the clock signal that is transitioning from Logic Low to Logic High, then that type of triggering is known as Positive edge triggering. It is also called as rising edge triggering. It is shown in the following figure. If the sequential circuit is operated with the clock signal that is transitioning from Logic High to Logic Low, then that type of triggering is known as Negative edge triggering. It is also called as falling edge triggering. It is shown in the following figure. ",
    "url": "/docs/seq-ssi/clock-signals.html#types-of-triggering",
    
    "relUrl": "/docs/seq-ssi/clock-signals.html#types-of-triggering"
  },"89": {
    "doc": "Guidelines",
    "title": "Contributing Guidelines",
    "content": " ",
    "url": "/contributing_guidelines.html#contributing-guidelines",
    
    "relUrl": "/contributing_guidelines.html#contributing-guidelines"
  },"90": {
    "doc": "Guidelines",
    "title": "Table of contents",
    "content": ". | About this guidelines . | Revision history | Purpose of the guidelines | Acknowledgements | . | Workflow | Licensing . | Non-free materials and special requirements | Linking to copyrighted works | . | Proposing a contribution | Editing existing content | Writing content . | Quality assurance | . | Style manual . | Figures and tables | Equations | References | . | Templates and examples . | New chapter template | New section template | Equations examples | Figure examples | Table examples | Bibliography example | . | Code of conduct, interacting with the community / etiquette | Tools . | Git | Jekyll | . | . ",
    "url": "/contributing_guidelines.html#table-of-contents",
    
    "relUrl": "/contributing_guidelines.html#table-of-contents"
  },"91": {
    "doc": "Guidelines",
    "title": "About this guidelines",
    "content": "This guidelines documentation was started on September 2020 as part of the Google Season of Docs 2020 initiative. Revision history . The revision history is presented in the following table . | Revision number | Date | Revised by | . | 1.0 | 2020-11-25 | DVLS | . Purpose of the guidelines . These guidelines are inteded to guide those who wish to contribute to this Interactive Book. It (tries) to cover most aspects such as the process workflow, license, style, quality, templates and tools. Acknowledgements . These guidlines are heavily based on the Linux Document Project Author Guide and the Wikibooks Contributing help and Policies and guidelines. | The LDP Author Guide is Copyright (C) 1999-2002 Mark F. Komarinski, David C. Merrill, Jorge Godoy. It is licensed under the GNU FDL v1.1+ (no invariant sections, no front-cover texts and no-back-cover texts) | Wikibooks documents are licensed under the CC-by-sa License and copyrighted by contributors to Wikibooks | . ",
    "url": "/contributing_guidelines.html#about-this-guidelines",
    
    "relUrl": "/contributing_guidelines.html#about-this-guidelines"
  },"92": {
    "doc": "Guidelines",
    "title": "Workflow",
    "content": "Usually, the contribution process will include the following steps: . | find an opportunity to contribute: . | add new content (new chapters, new sections, extend a section, add example circuits), | correct existing content, | translate content, | … | . | contact the interactive book development coordination team and share/discuss your idea | further discuss the idea with the community | fork the book repository | work on the contribution | create a pull-request to start the reviewing process of your contribution | . ",
    "url": "/contributing_guidelines.html#workflow",
    
    "relUrl": "/contributing_guidelines.html#workflow"
  },"93": {
    "doc": "Guidelines",
    "title": "Licensing",
    "content": "The book is licensed under the CC BY-SA 4.0 and copyrighted by contributors to CircuitVerse unless otherwise noted. The author has to make sure that the all content contributed can be licensed under the specified license. Never submit copyrighted material without permission from copyright owner. If you contribute to the book, you irrevocably agree to license it to the public under CC BY-SA 4.0. Non-free materials and special requirements . CircuitVerse’s Interactive Book may also include quotations, images, or other media under the U.S. Copyright law “fair use” doctrine. In CircuitVerse, such “fair use” material should be identified as from an external source by an appropriate method (on the figure or table description, as appropriate; quotations should be denoted as a quotation block. This leads to possible restrictions on the use, outside of the Interactive Book, of such “fair use” content retrieved from the book: this “fair use” content does not fall under the CC BY-SA 4.0 license as such, but under the “fair use” (or similar/different) regulations in the country where the media are retrieved. More information about “Fair use” . | https://www.baylor.edu/copyright/index.php?id=56543 | https://www.baylor.edu/copyright/doc.php/240714.pdf | https://librarycopyright.net/resources/fairuse/index.php | https://www.baylor.edu/content/services/document.php/68621.pdf | https://www.copylaw.com/new_articles/copy_myths.html | https://blogs.library.duke.edu/scholcomm/2007/11/30/citation-infringement/ | . Linking to copyrighted works . Since most recently-created works are copyrighted, almost all cites sources will link to copyrighted material. It is usually not necessary to obtain the permission of a copyright holder before linking to copyrighted material, just as an author of a dead-tree book does not need permission to cite someone else’s work in their bibliography. Likewise, CircuitVerse’s Interactive Book is not restricted to linking only to CC-BY-SA or open-source content. ",
    "url": "/contributing_guidelines.html#licensing",
    
    "relUrl": "/contributing_guidelines.html#licensing"
  },"94": {
    "doc": "Guidelines",
    "title": "Proposing a contribution",
    "content": "If you have in mind new content to be added, it is important that the CircuitVerse community understand why your contribution should be included in the book. You may have already discussed your idea in some of CircuitVerse social channels, in that case, please include the discussion in your proposal. The proposal should clearly indicate what kind of contribution are you planning to submit (add new content, edit existing content, translate content). When proposing new content, please, also specify whether it will be a whole new chapter, a new section, specific content within a section (text, figures, equations, example circuits, etc.) . Then, include a brief summary of the contribution content followed by the justification why it is needed. Finaly, submit your proposal to the CircuitVerse Interactive Book coordination team, and discuss the proposal with them in order to refine it. The coordination team will either approve or reject the proposal. In case of rejection, comments will be included explaining why it was rejected, and how could it be improved when the proposed content is useful, but the proposed “format” whas not adequate enough. ",
    "url": "/contributing_guidelines.html#proposing-a-contribution",
    
    "relUrl": "/contributing_guidelines.html#proposing-a-contribution"
  },"95": {
    "doc": "Guidelines",
    "title": "Editing existing content",
    "content": "When editing existing content, try to contact the original author first in order to discuss your idea. If the original author cannot be contacted after a “good-faith” effort, fall back to discuss the topic with the CircuiVerse community through any of the social channels. ",
    "url": "/contributing_guidelines.html#editing-existing-content",
    
    "relUrl": "/contributing_guidelines.html#editing-existing-content"
  },"96": {
    "doc": "Guidelines",
    "title": "Writing content",
    "content": "All content should be supported by valid sources. Please, research carefuly and validate all your references. Check that there are no copyright or license issues regarding the use of each of your sources. When using online resources, make a “hard-copy” (screen-capture, pdf-printed version) of them to avoid missing resources in the future (Error 404) . The Interactive Book is not intended as a thorough textbook, but its main focus is on interactive content. Try to keep the content to the amount necessary to understand the topic and cite appropriate references for further study on the subject. To keep the consistency of the book, please follow the style indicated in these guidelines, also use the templates and existing content as example. Quality assurance . Besides researching and validating your sources and adhering to the Interactive Book style, please also edit (remove unnecesary content) and check for spelling and grammar errors. Then, forward your contribution to a third party for proofreading. When you are satisfied with the quality and accuracy of your contribution ask for peer reviewers from the CircuitVerse community. Finally, submit your work to the “formal” review by creating a pull-request of your forked repository . ",
    "url": "/contributing_guidelines.html#writing-content",
    
    "relUrl": "/contributing_guidelines.html#writing-content"
  },"97": {
    "doc": "Guidelines",
    "title": "Style manual",
    "content": "[Work in Progress] . While most of the formatting style is carried out automatically by the layout, templates and stylesheets in the SSG (jekyll) pipeline, it is important to also adhere to a common writing style in order to assure consistency of the book. Please use a neutral and simple language. Avoid slang. Also, technical jargon should be explained. Figures and tables . Figures and tables should include a description or caption, and they should be commented in text. If a figure or table is not part of the description, probably it is not needed and can be removed from the book. See an example in section Templates and examples. Equations . Equations can be typesetted in LaTeX to be rendered by MathJax. A few examples can be found in the Templates and examples section. If equations need to be referenced in the text, use numbered or labelled equations. General useful guidelines: . | There are many variants for the notation of negated variables, prefer the bar over the variable or the prime (complement) symbol. | For binary words with many literals (high number of bits) prefer a single letter with subscript numbers for each bit. For instance a four bit word can be written as $(x_3,x_2,x_1,x_0)$ instead of a different letter for each literal $(A,B,C,D)$. The least significant bit should be subscripted with 0. In case of ambiguity or if the opposite arrangement is necessary, use a superscript mark to identify the MSB and LSB: $(x_0^{\\text{MSB}},x_1,x_2,x_3^{\\text{LSB}})$ | . References . Information obtained from other sources should be properly cited and referenced. Check the Templates and examples section for examples. Currently, references are formatted according to the ieee-with-url style defined CiteProc-Ruby. ",
    "url": "/contributing_guidelines.html#style-manual",
    
    "relUrl": "/contributing_guidelines.html#style-manual"
  },"98": {
    "doc": "Guidelines",
    "title": "Templates and examples",
    "content": "To help you with getting started with writing your contribution, please use the following templates and examples, accordingly: . | New chapter template | New section template | Equations example | Figure example | Table example | Bibliography example | . The structure of the book, as well as the navigation menu is handled by Jekyll’s Just-the-docs plugin. A two-level structure has been chosen. The top-level is for chapters and the second level is for sections in a chapter . New chapter template . Each chapter should be a directory under the docs directory. The index.md in the chapter directory is used for the Chapter text and table of contents. The index.md file should have the following contents: . --- layout: circuitverse title: Chapter title nav_order: 10 has_children: true has_toc: false --- # Long chapter title {: .no_toc} Introductory chapter text ## Chapter contents {: .no_toc .text-delta} {% include chapter_toc.html %} . The title and nav_order elements in the front matter should be filled-in accordingly. The other elements in the front matter block should be left as in the template above. After the “Long” chapter title an introductory text for the chapter can be added. It is followed by the ’ title and the include directive which create a list of links to the sections of the chapter according to their level and navigation order. New section template . Files for sections within a chapter must be placed in the chapter’s directory. Currently, the contents of the book are organised in three levels of difficulty: . | basic | medium | advanced | . The following code represents an empty section and can be used as a template . --- layout: circuitverse title: Section title nav_order: l0s000 cvib_level: advanced parent: Parent Chapter has_children: false --- # Long section title {: .no_toc} ## {: .no_toc .text-delta} 1. TOC {:toc} ## Title Text . Each section file should have content belonging only to one of these levels. Therefore, the front matter block presents the cvib_level which correspond to one of the levels. The parent element must be the name of the Chapter containing the section. The section’s title goes in the title element. To standardise the order of sections in the navigation bar according to the difficulty level, the nav_order element is an “encoded” string with this form: l, followed by a digit, followed by s, followed by three digits. l stands for level and is a number between 0 and 2 and represent the basic, medium and advanced level, respectively. s stands for section and the three digit number after it is a zero-padded number indicating the section position in the chapter. The other elements in the front matter block (layout, has_children) should be should be left as they are. After the front matter block comes the section’s title followed by the table of contents title and code to generate it automatically. After that, parts within the section can be added. Equations examples . Equations are processed using MathJax provided by the jekyll-spaceship plugin. The following are valid mathematical formulas and their rendering: . | Unnumbered equations . $ f(x)=\\int_2^n \\frac{1}{2\\pi}x^2 $ . $ f(x)=\\int_2^n \\frac{1}{2\\pi}x^2 $ . $ F(A,B,C) = A + B \\cdot C $ . $ F(A,B,C) = A + B ⋅ C $ . | Automatically numbered equations . $ \\begin{equation}F(x_0, x_1) = x_0 + \\overline{x_1} \\end{equation} $ . $ \\begin{equation}F(x_0, x_1) = x_0 + \\overline{x_1} \\end{equation} $ . | Manually numbered equations . \\\\[ F(A,B,C) = A + B \\cdot C \\tag{1}\\\\] . \\[ F(A,B,C) = A + B \\cdot C \\tag{1}\\] . | . Figure examples . Neither Jekyll nor Markdown provide facilities to add captions to images. Therefore, instead of using direct inclusion of images in MD syntax, the Jekyll include mechanism is used to generate properly captioned figures in the HTML rendering. To use it, include a figure like this: . {% include image.html url=\"/assets/images/path-to-image/image.svg\" description=\"Image caption\" %} . For instance, the following code: . {% include image.html url=\"/assets/images/XnorGate.svg\" description=\"XNOR Gate\" %} . will render like this: . XNOR Gate Table examples . Complex tables can be handled by the jekyll-spaceship plugin. However, there is no support for table captions. As a workaround, the Table caption can be included in the first row and styled with the table caption CSS tblcap. |: Table: Sample data {: .tblcap} :||| col 1 | col 2 | col 3 |:-----------:|:------------|------------:| row1 col2 | row1 col2 | row1 col3 | row2 col1 | row2 col2 | row2 col3 | . which renders to . | : Table: Sample data {: .tblcap} :|| |   |   | . | col 1 | col 2 | col 3 | . | row1 col2 | row1 col2 | row1 col3 | . | row2 col1 | row2 col2 | row2 col3 | . Bibliography example . Bibliographic references are processed by the jekyll-scholar plugin. It uses BibTeX files as the source for the references. To use it, the following must be done: . | Add the the BibTeX file to the _bibliography/ directory. Care must be taken to not overwrite other bib files in the directory. | If the BibTex file is named myrefs.bib, then . | To cite a reference use this tag: . {% cite refid --file myrefs %} . where refid is the BibTeX id of the reference and myfile is the BibTeX file without the .bib extension. | To print the list of references cited in the section use the following code: . ## References {% bibliography --cited --file myrefs %} . | . | . Check the plugin page for more complex uses. ",
    "url": "/contributing_guidelines.html#templates-and-examples",
    
    "relUrl": "/contributing_guidelines.html#templates-and-examples"
  },"99": {
    "doc": "Guidelines",
    "title": "Code of conduct, interacting with the community / etiquette",
    "content": "Refer to the Contributor Covenant Code of Conduct . ",
    "url": "/contributing_guidelines.html#code-of-conduct-interacting-with-the-community--etiquette",
    
    "relUrl": "/contributing_guidelines.html#code-of-conduct-interacting-with-the-community--etiquette"
  },"100": {
    "doc": "Guidelines",
    "title": "Tools",
    "content": "The following tools will be useful to work in your contribution. Git . The CircuitVerse Interactive Book’s sources are hosted in a GitHub repository. Besides the web interface provided by GitHub, other tools to manipulate git repositories can be used: . | Git | . Jekyll . The Interactive Book is rendered using the Jekyll Static Site Generator (SSG). The GitHub repository is able to create a live version of the book using the continuous integration (CI) / continuous deployment (CD) workflows. To work locally, you will need to setup a Jekyll development environment. It is posible to setup Jekyll natively for your OS or run it in a docker container. | Workflow with native Jekyll . | Install Jekyll following the official documentation. If you don’t have time to follow the quickstart guide, the following steps might help you: . | Install Ruby if necessary | Install Jekyll using the command line: gem install jekyll | Install Bundler: gem install bundle | Change (cd) to your local repository directory and install the project dependencies: bundle install | . | Serve a live local copy at http://0.0.0.0:4000/, running: bundle exec jekyll serve | Point your browser to the url above and see your changes live. | . | Workflow using docker . | Install and setup docker if you haven’t done so already | Change (cd) to your local repository directory and Run a jekyll docker image (BretFisher’s images have been tested and work well with the book). docker run --rm -p 4000:4000 -v $(pwd):/site bretfisher/jekyll-serve | Point your browser to the appropriate url, http://0.0.0.0:4000/ if you use the command suggested previously. | . | . ",
    "url": "/contributing_guidelines.html#tools",
    
    "relUrl": "/contributing_guidelines.html#tools"
  },"101": {
    "doc": "Guidelines",
    "title": "Guidelines",
    "content": " ",
    "url": "/contributing_guidelines.html",
    
    "relUrl": "/contributing_guidelines.html"
  },"102": {
    "doc": "Counters",
    "title": "Counters",
    "content": " ",
    "url": "/docs/seq-msi/counters.html",
    
    "relUrl": "/docs/seq-msi/counters.html"
  },"103": {
    "doc": "Counters",
    "title": "Table of contents",
    "content": ". | Digital sequential circuits | Asynchronous or ripple counters . | Logical diagram | Types | Operation | Truth table | . | Synchronous counters . | 2-bit Synchronous up counter | Types | Logical diagram | Operation | . | . ",
    "url": "/docs/seq-msi/counters.html#table-of-contents",
    
    "relUrl": "/docs/seq-msi/counters.html#table-of-contents"
  },"104": {
    "doc": "Counters",
    "title": "Digital sequential circuits",
    "content": "Counter is a sequential circuit. A digital circuit which is used for a counting pulses is known counter. Counter is the widest application of flip-flops. It is a group of flip-flops with a clock signal applied. ",
    "url": "/docs/seq-msi/counters.html#digital-sequential-circuits",
    
    "relUrl": "/docs/seq-msi/counters.html#digital-sequential-circuits"
  },"105": {
    "doc": "Counters",
    "title": "Asynchronous or ripple counters",
    "content": "The logic diagram of a 2-bit ripple up counter is shown in figure. The toggle (T) flip-flop are being used. But you can use the JK flip-flop also with J and K connected permanently to logic 1. External clock is applied to the clock input of flip-flop A and QA output is applied to the clock input of the next flip-flop i.e. FF-B. Logical diagram . Types . It is known as ripple counter because of the way the clock pulse ripples its way through the flip-flops. The flip-flop applied with external clock pulse act as LSB (Least Significant Bit) in the counting sequence.The flip-flop toggles the output either for every positive edge of clock signal or for negative edge of clock signal. | 2 bit ripple up counter: It contains two flip flops. A 2-bit ripple counter can count up to 4 states. It counts from 0 to 3. | . | 2 bit ripple down counter: It contains two flip flops. A 2-bit ripple counter can count up to 4 states. It is known as down counter as it counts down from 3 to 0. | . | 3 bit ripple up counter: It contains three flip flops. A 3-bit ripple counter can count up to 8 states. It counts from 0 to 7. | 3 bit ripple down counter: It contains three flip flops. A 3-bit ripple counter can count up to 8 states.It counts down from 7 to 0. | . | Decade or BCD counter : A binary coded decimal (BCD) is a serial digital counter that counts ten digits. It counts from 0 to 9.When the clock pulse advances to 10 the ports QB and QD become high and thus NAND gate’s output will become low which will reset all the flip flops. | . Operation . | Condition | Operation | . | **Initially let both the FFs be in the reset state** | QBQA = 00 initially. | . | **After 1st negative clock edge** | As soon as the first negative clock edge is applied, FF-A will toggle and QA will be equal to 1.QA is connected to clock input of FF-B. Since QA has changed from 0 to 1, it is treated as the positive clock edge by FF-B. There is no change in QB because FF-B is a negative edge triggered FF.QBQA = 01 after the first clock pulse. | . | **After 2nd negative clock edge** | On the arrival of second negative clock edge, FF-A toggles again and QA = 0.The change in QA acts as a negative clock edge for FF-B. So it will also toggle, and QB will be 1.QBQA = 10 after the second clock pulse. | . | **After 3rd negative clock edge** | On the arrival of 3rd negative clock edge, FF-A toggles again and QA become 1 from 0.Since this is a positive going change, FF-B does not respond to it and remains inactive. So QB does not change and continues to be equal to 1.QBQA = 11 after the third clock pulse. | . | **After 4th negative clock edge** | On the arrival of 4th negative clock edge, FF-A toggles again and QA becomes 1 from 0.This negative change in QA acts as clock pulse for FF-B. Hence it toggles to change QB from 1 to 0.QBQA = 00 after the fourth clock pulse. | . Truth table . ",
    "url": "/docs/seq-msi/counters.html#asynchronous-or-ripple-counters",
    
    "relUrl": "/docs/seq-msi/counters.html#asynchronous-or-ripple-counters"
  },"106": {
    "doc": "Counters",
    "title": "Synchronous counters",
    "content": "If the “clock” pulses are applied to all the flip-flops in a counter simultaneously, then such a counter is called as synchronous counter. 2-bit Synchronous up counter . The JA and KA inputs of FF-A are tied to logic 1. So FF-A will work as a toggle flip-flop. The JB and KB inputs are connected to QA. Types . | 4 bit synchronous up counter: In the up counter the 4 bit binary sequence starts from 0000 and increments up to 1111, i.e from 0 to 15. | . | 4 bit synchronous down counter: Down counter counts the numbers in decreasing order i.e from 15 to 0. | . | 4 bit synchronous up/down counter: This counter has two modes of counting i.e. up counting and down counting. There is a mode switch which switches between the two modes of the counter. When the mode M = 0 it counts up &amp; when mode M = 1 then it counts down. | . | 4-Bit synchronous decade counter: A BCD decade counter exhibits a truncated binary sequence and goes from 0000 through the 1001 state. Rather than going from the 1001 state to the 1010 state, it recycles to the 0000 state. | . | Ring counter: The ring counter is a application of shift register, in which the output of last flip flop is connected to input of first flip flop. In ring counter if the output of any flip flop is 1, then the output of remaining flip flops is 0. The Ring counters transfers the same output throughout the circuit. | . | Johnson’s counter or twisted ring counter: The Johnson counter is a modification of ring counter. In this the inverted output of the last stage flip flop is connected to the input of first flip flop. If we use n flip flops to design the Johnson counter, it is known as 2n bit Johnson counter or Mod 2n Johnson counter. | . Logical diagram . Operation . | Condition | Operation | . | **Initially let both the FFs be in the reset state** | QBQA = 00 initially. | . | **After 1st negative clock edge** | As soon as the first negative clock edge is applied, FF-A will toggle and QA will change from 0 to 1.But at the instant of application of negative clock edge, QA , JB = KB = 0. Hence FF-B will not change its state. So QB will remain 0.QBQA = 01 after the first clock pulse. | . | **After 2nd negative clock edge** | On the arrival of second negative clock edge, FF-A toggles again and QA changes from 1 to 0.But at this instant QA was 1. So JB = KB= 1 and FF-B will toggle. Hence QB changes from 0 to 1.QBQA = 10 after the second clock pulse. | . | **After 3rd negative clock edge** | On application of the third falling clock edge, FF-A will toggle from 0 to 1 but there is no change of state for FF-B.QBQA = 11 after the third clock pulse. | . | **After 4th negative clock edge** | On application of the next clock pulse, QA will change from 1 to 0 as QB will also change from 1 to 0.QBQA = 00 after the fourth clock pulse. | . ",
    "url": "/docs/seq-msi/counters.html#synchronous-counters",
    
    "relUrl": "/docs/seq-msi/counters.html#synchronous-counters"
  },"107": {
    "doc": "Discrete quantities",
    "title": "Discrete quantities",
    "content": " ",
    "url": "/docs/binary-representation/discrete-quantities.html",
    
    "relUrl": "/docs/binary-representation/discrete-quantities.html"
  },"108": {
    "doc": "Discrete quantities",
    "title": "Table of contents",
    "content": ". | Analog vs discrete | Converting to and from the analog world | Sampling theorem | References | . ",
    "url": "/docs/binary-representation/discrete-quantities.html#table-of-contents",
    
    "relUrl": "/docs/binary-representation/discrete-quantities.html#table-of-contents"
  },"109": {
    "doc": "Discrete quantities",
    "title": "Analog vs discrete",
    "content": ". | Section 1.1 “Analog and Discrete Variables” in [1] | Section “Analogue and digital data” (Chapter 1) in [2] | Secion “Digital and analogue signals” (Chapter 1) in [3] | Chapter 1 “Introduction: Analog Versus Digital” in [4] | . ",
    "url": "/docs/binary-representation/discrete-quantities.html#analog-vs-discrete",
    
    "relUrl": "/docs/binary-representation/discrete-quantities.html#analog-vs-discrete"
  },"110": {
    "doc": "Discrete quantities",
    "title": "Converting to and from the analog world",
    "content": ". | Section “Interfacing the digital system to the real world” (Chapter 8) in [2] | Chapter 6 “Analogue to Digital and Digital to Analogue Conversion” in [3] | . ",
    "url": "/docs/binary-representation/discrete-quantities.html#converting-to-and-from-the-analog-world",
    
    "relUrl": "/docs/binary-representation/discrete-quantities.html#converting-to-and-from-the-analog-world"
  },"111": {
    "doc": "Discrete quantities",
    "title": "Sampling theorem",
    "content": "The Nyquist-Shannon theorem . ",
    "url": "/docs/binary-representation/discrete-quantities.html#sampling-theorem",
    
    "relUrl": "/docs/binary-representation/discrete-quantities.html#sampling-theorem"
  },"112": {
    "doc": "Discrete quantities",
    "title": "References",
    "content": ". | [1]G. Donzellini, L. Oneto, D. Ponta, and D. Anguita, Introduction to Digital Systems Design. Springer International Publishing, 2018 [Online]. Available at: https://books.google.cl/books?id=va1qDwAAQBAJ | [2]J. Stonham, Digital Logic Techniques. CRC Press, 2017 [Online]. Available at: https://books.google.cl/books?id=a-5HDwAAQBAJ | [3]J. Morris, Digital Electronics. CRC Press, 2013 [Online]. Available at: https://books.google.cl/books?id=MkAI6lrRrm4C | [4]B. J. LaMeres, Introduction to Logic Circuits &amp; Logic Design with Verilog. Springer International Publishing, 2019 [Online]. Available at: https://books.google.cl/books?id=1OORDwAAQBAJ | . ",
    "url": "/docs/binary-representation/discrete-quantities.html#references",
    
    "relUrl": "/docs/binary-representation/discrete-quantities.html#references"
  },"113": {
    "doc": "Division",
    "title": "Binary division",
    "content": " ",
    "url": "/docs/binary-algebra/division.html#binary-division",
    
    "relUrl": "/docs/binary-algebra/division.html#binary-division"
  },"114": {
    "doc": "Division",
    "title": "Table of contents",
    "content": ". | Division | . ",
    "url": "/docs/binary-algebra/division.html#table-of-contents",
    
    "relUrl": "/docs/binary-algebra/division.html#table-of-contents"
  },"115": {
    "doc": "Division",
    "title": "Division",
    "content": "The division in binary is achieved by binary subtraction. The sole motive of the Binary Division is to subtract the divisor from dividends until 0 is obtained or a number that cannot be further subtracted. The number of times you subtract is known as a quotient(this can be converted to binary) and the number which cannot be reduced or 0 is obtained after some step is known as Remainder. Another method which can achieve Division in binary is by using Binary Multiplication and subtraction. It is similar to Decimal Division. Multiply the divisor by 1 or 0 wherever needed and reduce the number further. 1 1 1 1 0 / 1 0 1 (Dividend/Divisor) - 1 0 1 1st ------------- 1 1 0 0 1 - 1 0 1 2nd ------------- 1 0 1 0 0 - 1 0 1 3rd ------------- 0 1 1 1 1 - 1 0 1 4th ------------- 1 0 1 0 - 1 0 1 5th ------------- 1 0 1 - 1 0 1 6th ------------- ------- 0 (Remainder) ans = 6 (110) (Quotient) ------------- ------- . | Perform division of the binary numbers: 1010101 by 101 = ? . | 010001 . | 110101 | 1111000 | 101 | . | . | Division of the binary numbers: 101001 by 1011 will give remainder as ? . | 1000 . | 1010 | 1101 | 0011 | . | . | Division of the binary numbers: 011010000 by 0101 will give quotient as ? . | 0101010 . | 0000010 | 0110010 | 0101110 | . | . | . ",
    "url": "/docs/binary-algebra/division.html",
    
    "relUrl": "/docs/binary-algebra/division.html"
  },"116": {
    "doc": "Encoders/Decoders",
    "title": "Encoders and Decoders",
    "content": " ",
    "url": "/docs/comb-msi/encoders-decoders.html#encoders-and-decoders",
    
    "relUrl": "/docs/comb-msi/encoders-decoders.html#encoders-and-decoders"
  },"117": {
    "doc": "Encoders/Decoders",
    "title": "Table of contents",
    "content": ". | Encoder | Introduction | Block diagram . | Examples of encoders :: | . | Priority encoder | Block diagram . | Truth table | Logic circuit | . | Decimal to BCD encoder | Octal to binary encoder | Hexadecimal to binary encoder | Decoder | Introduction | Block diagram . | Examples of decoders :: | . | 2-to-4 line decoder | Block diagram | Truth table | Logic circuit | . ",
    "url": "/docs/comb-msi/encoders-decoders.html#table-of-contents",
    
    "relUrl": "/docs/comb-msi/encoders-decoders.html#table-of-contents"
  },"118": {
    "doc": "Encoders/Decoders",
    "title": "Encoder",
    "content": " ",
    "url": "/docs/comb-msi/encoders-decoders.html#encoder",
    
    "relUrl": "/docs/comb-msi/encoders-decoders.html#encoder"
  },"119": {
    "doc": "Encoders/Decoders",
    "title": "Introduction",
    "content": "Encoder is a combinational circuit which is designed to perform the inverse operation of the decoder. An encoder has n number of input lines and m number of output lines. An encoder produces an m bit binary code corresponding to the digital input number. The encoder accepts an n input digital word and converts it into an m bit another digital word. ",
    "url": "/docs/comb-msi/encoders-decoders.html#introduction",
    
    "relUrl": "/docs/comb-msi/encoders-decoders.html#introduction"
  },"120": {
    "doc": "Encoders/Decoders",
    "title": "Block diagram",
    "content": "Examples of encoders :: . | Priority encoders | Decimal to BCD encoder | Octal to binary encoder | Hexadecimal to binary encoder | . ",
    "url": "/docs/comb-msi/encoders-decoders.html#block-diagram",
    
    "relUrl": "/docs/comb-msi/encoders-decoders.html#block-diagram"
  },"121": {
    "doc": "Encoders/Decoders",
    "title": "Priority encoder",
    "content": "This is a special type of encoder. Priority is given to the input lines. If two or more input line are 1 at the same time, then the input line with highest priority will be considered. There are four input D0, D1, D2, D3 and two output Y0, Y1. Out of the four input D3 has the highest priority and D0 has the lowest priority. That means if D3 = 1 then Y1 Y1 = 11 irrespective of the other inputs. Similarly if D3 = 0 and D2 = 1 then Y1 Y0 = 10 irrespective of the other inputs. ",
    "url": "/docs/comb-msi/encoders-decoders.html#priority-encoder",
    
    "relUrl": "/docs/comb-msi/encoders-decoders.html#priority-encoder"
  },"122": {
    "doc": "Encoders/Decoders",
    "title": "Block diagram",
    "content": "Truth table . Logic circuit . ",
    "url": "/docs/comb-msi/encoders-decoders.html#block-diagram-1",
    
    "relUrl": "/docs/comb-msi/encoders-decoders.html#block-diagram-1"
  },"123": {
    "doc": "Encoders/Decoders",
    "title": "Decimal to BCD encoder",
    "content": "The Decimal to Binary Encoder usually consists of 10 input lines and 4 output lines. The input is a number written in base 10 and the output is its corresponding equivalent binary coded decimal number (of 4 bits). ",
    "url": "/docs/comb-msi/encoders-decoders.html#decimal-to-bcd-encoder",
    
    "relUrl": "/docs/comb-msi/encoders-decoders.html#decimal-to-bcd-encoder"
  },"124": {
    "doc": "Encoders/Decoders",
    "title": "Octal to binary encoder",
    "content": "The Octal to Binary Encoder encoder usually consists of 8 inputs lines and 3 outputs lines. The input is a number written in base 8 and the output is its corresponding equivalent number in base 2. ",
    "url": "/docs/comb-msi/encoders-decoders.html#octal-to-binary-encoder",
    
    "relUrl": "/docs/comb-msi/encoders-decoders.html#octal-to-binary-encoder"
  },"125": {
    "doc": "Encoders/Decoders",
    "title": "Hexadecimal to binary encoder",
    "content": "The Hexadecimal to Binary Encoder encoder usually consists of 16 inputs lines and 3 outputs lines. The input is a number written in base 16 and the output is its corresponding equivalent number in base 2. ",
    "url": "/docs/comb-msi/encoders-decoders.html#hexadecimal-to-binary-encoder",
    
    "relUrl": "/docs/comb-msi/encoders-decoders.html#hexadecimal-to-binary-encoder"
  },"126": {
    "doc": "Encoders/Decoders",
    "title": "Decoder",
    "content": " ",
    "url": "/docs/comb-msi/encoders-decoders.html#decoder",
    
    "relUrl": "/docs/comb-msi/encoders-decoders.html#decoder"
  },"127": {
    "doc": "Encoders/Decoders",
    "title": "Introduction",
    "content": "A decoder is a combinational circuit. It has n input and to a maximum m = 2n outputs. Decoder is identical to a demultiplexer without any data input. It performs operations which are exactly opposite to those of an encoder. ",
    "url": "/docs/comb-msi/encoders-decoders.html#introduction-1",
    
    "relUrl": "/docs/comb-msi/encoders-decoders.html#introduction-1"
  },"128": {
    "doc": "Encoders/Decoders",
    "title": "Block diagram",
    "content": "Examples of decoders :: . | Code converters | BCD to seven segment decoders | Nixie tube decoders | Relay actuator | . ",
    "url": "/docs/comb-msi/encoders-decoders.html#block-diagram-2",
    
    "relUrl": "/docs/comb-msi/encoders-decoders.html#block-diagram-2"
  },"129": {
    "doc": "Encoders/Decoders",
    "title": "2-to-4 line decoder",
    "content": "The block diagram of 2 to 4 line decoder is shown in the fig. A and B are the two inputs where D through D are the four outputs. Truth table explains the operations of a decoder. It shows that each output is 1 for only a specific combination of inputs. ",
    "url": "/docs/comb-msi/encoders-decoders.html#2-to-4-line-decoder",
    
    "relUrl": "/docs/comb-msi/encoders-decoders.html#2-to-4-line-decoder"
  },"130": {
    "doc": "Encoders/Decoders",
    "title": "Block diagram",
    "content": " ",
    "url": "/docs/comb-msi/encoders-decoders.html#block-diagram-3",
    
    "relUrl": "/docs/comb-msi/encoders-decoders.html#block-diagram-3"
  },"131": {
    "doc": "Encoders/Decoders",
    "title": "Truth table",
    "content": " ",
    "url": "/docs/comb-msi/encoders-decoders.html#truth-table-1",
    
    "relUrl": "/docs/comb-msi/encoders-decoders.html#truth-table-1"
  },"132": {
    "doc": "Encoders/Decoders",
    "title": "Logic circuit",
    "content": ". | How many input lines exist in Decimal to BCD Encoder ? . | 4 . | 10 | . | 8 | 2 | . | How many output lines exist in Decimal to BCD Encoder ? . | 1 . | 4 | . | 3 | 2 | . | For conversion of BCD to seven segment display which of the following component will you use ? . | Encoder . | Decoder | . | Comparator | Multiplexer | . | Identify the decoder IC ? . | 7890 . | 8870 | . | 4047 | 4041 | . | By using only which of the gates decoder can be formed ? . | AND . | OR | . | NOT | . | . ",
    "url": "/docs/comb-msi/encoders-decoders.html#logic-circuit-1",
    
    "relUrl": "/docs/comb-msi/encoders-decoders.html#logic-circuit-1"
  },"133": {
    "doc": "Encoders/Decoders",
    "title": "Encoders/Decoders",
    "content": " ",
    "url": "/docs/comb-msi/encoders-decoders.html",
    
    "relUrl": "/docs/comb-msi/encoders-decoders.html"
  },"134": {
    "doc": "Encoding information",
    "title": "Encoding information",
    "content": " ",
    "url": "/docs/binary-representation/encoding-information.html",
    
    "relUrl": "/docs/binary-representation/encoding-information.html"
  },"135": {
    "doc": "Encoding information",
    "title": "Table of contents",
    "content": ". | Binary flags | Representing a character | . ",
    "url": "/docs/binary-representation/encoding-information.html#table-of-contents",
    
    "relUrl": "/docs/binary-representation/encoding-information.html#table-of-contents"
  },"136": {
    "doc": "Encoding information",
    "title": "Binary flags",
    "content": "The new Interactive Book for digital logic design requires you to study binary and its uses. In computing, a flag is a type of signal usually used to indicate whether something is true or false. To save time and make your program less complicated, you might want to combine these flags and send several pieces of information in one go. Imagine you wanted to send a message to your friend to indicate which subjects had set homework on a particular day. If it was only one subject, you can just send the name of the subect - e.g. English - but if there is more than one, it gets more complicated. One way to do it is to give each subject a number: . | Serial no. | Subject | . | 1 | English | . | 2 | Maths | . | 4 | Science | . | 8 | Computing | . | 16 | History | . | 32 | Geography | . | 64 | French | . | 128 | German | . You can send combinations of subjects by adding together the numbers and sending the total. Try it below: . Enter the homework code and click the button. Code: . This only works because of the numbers I’ve chosen - it’s a binary sequence, with each number being one of the binary column headings. This means that each total can only be made up from one combination of subjects. If they’d been numbered as 1 = English, 2 = Maths, 3 = Science, 4 = Computing, etc., then it wouldn’t work, because a code of 3 could represent English and Maths, or it could be Science on its own. To use this technique in your programming, you need to be familiar with bitwise logic . ",
    "url": "/docs/binary-representation/encoding-information.html#binary-flags",
    
    "relUrl": "/docs/binary-representation/encoding-information.html#binary-flags"
  },"137": {
    "doc": "Encoding information",
    "title": "Representing a character",
    "content": "The computer that you had when you were in the 80s - in common with a lot of personal computers at the time - allowed you to design your own text character. You could use this in a game - e.g. to make a “space invader” - or you could use the same technique to make your own font. I made my own font that looked like my handwriting! . Characters were designed on an 8 x 8 grid, and created using eight numbers from 0-255. Each number was converted to binary and the resulting pattern of 0s and 1s was used to make a pattern of black and white dots on a single row. You can design a character in the same way by entering numbers from 0-255 in the boxes to the left of the grid. Each number is converted to binary and used to create the pattern of dots. 128 64 32 16 8 4 2 1 You can design a character in the same way by entering numbers from 0-255 in the boxes to the left of the grid. Each number is converted to binary and used to create the pattern of dots. Fonts on a modern computer would be made up of a lot more than 64 pixels, but the principle is the same. If you can’t see how the numbers are converted into the patterns of black and white blocks, try looking at the page on binary. If you can see the link between the number and the pattern, then think about how the web page works . ",
    "url": "/docs/binary-representation/encoding-information.html#representing-a-character",
    
    "relUrl": "/docs/binary-representation/encoding-information.html#representing-a-character"
  },"138": {
    "doc": "Flip-flops",
    "title": "Flip-flops",
    "content": " ",
    "url": "/docs/seq-ssi/flip-flops.html",
    
    "relUrl": "/docs/seq-ssi/flip-flops.html"
  },"139": {
    "doc": "Flip-flops",
    "title": "Table of contents",
    "content": ". | Flip-flops | Introduction | Differences between latches and flip-flops | Sub-modules | SR flip-flop | Introduction | State table | Characteristic table | D flip-flop | Introduction | State table | JK flip-flop | Introduction | State table | Characteristic table | T flip-flop | Introduction | State table | Characteristic table | Master-slave JK flip-Flop | Introduction | Master-slave JK flip-flop constructed by using NAND gates | State table | Characteristic table | Excitation table | Characteristic equation | Flip-flops interaction | . ",
    "url": "/docs/seq-ssi/flip-flops.html#table-of-contents",
    
    "relUrl": "/docs/seq-ssi/flip-flops.html#table-of-contents"
  },"140": {
    "doc": "Flip-flops",
    "title": "Flip-flops",
    "content": " ",
    "url": "/docs/seq-ssi/flip-flops.html",
    
    "relUrl": "/docs/seq-ssi/flip-flops.html"
  },"141": {
    "doc": "Flip-flops",
    "title": "Introduction",
    "content": "You covered about latches in the previous modules. Those are the basic building blocks of flip-flops. You can implement flip-flops in two methods. In first method, cascade two latches in such a way that the first latch is enabled for every positive clock pulse and second latch is enabled for every negative clock pulse. So that the combination of these two latches become a flip-flop. In second module, you can directly implement the flip-flop, which is edge sensitive. In this module, let us discuss the following flip-flops using second method. ",
    "url": "/docs/seq-ssi/flip-flops.html#introduction",
    
    "relUrl": "/docs/seq-ssi/flip-flops.html#introduction"
  },"142": {
    "doc": "Flip-flops",
    "title": "Differences between latches and flip-flops",
    "content": "| Latches | Flip-flops | . | Level triggered | Edge triggered | . | Asynchronous device | Synchronous device | . | Doesn’t contain clock signal | Contains a clock signal | . | It will change its state as long as it is enabled | It will change its state only during a given clock cycle | . | Consumes less power | Consumes more power | . | Faster | Slower | . | Examples: D-Latch, T-Latch | Examples: D-Flip flop, T-Flop flop | . ",
    "url": "/docs/seq-ssi/flip-flops.html#differences-between-latches-and-flip-flops",
    
    "relUrl": "/docs/seq-ssi/flip-flops.html#differences-between-latches-and-flip-flops"
  },"143": {
    "doc": "Flip-flops",
    "title": "Sub-modules",
    "content": "Now let us implement various flip-flops by providing the cross coupling between NOR gates. You can also implement these flip-flops by using NAND gates, as well. | SR flip-flop | D flip-flop | JK flip-flop | T flip-flop | Master-slave JK flip-flop | . ",
    "url": "/docs/seq-ssi/flip-flops.html#sub-modules",
    
    "relUrl": "/docs/seq-ssi/flip-flops.html#sub-modules"
  },"144": {
    "doc": "Flip-flops",
    "title": "SR flip-flop",
    "content": " ",
    "url": "/docs/seq-ssi/flip-flops.html#sr-flip-flop",
    
    "relUrl": "/docs/seq-ssi/flip-flops.html#sr-flip-flop"
  },"145": {
    "doc": "Flip-flops",
    "title": "Introduction",
    "content": "SR flip-flop operates with only positive clock transitions or negative clock transitions. Whereas, SR latch operates with enable signal. The circuit diagram of SR flip-flop is shown in the following figure. his circuit has two inputs S &amp; R and two outputs Q(t) &amp; Q(t)’. The operation of SR flipflop is similar to SR Latch. But, this flip-flop affects the outputs only when positive transition of the clock signal is applied instead of active enable. ",
    "url": "/docs/seq-ssi/flip-flops.html#introduction-1",
    
    "relUrl": "/docs/seq-ssi/flip-flops.html#introduction-1"
  },"146": {
    "doc": "Flip-flops",
    "title": "State table",
    "content": "| S | R | Q(t+1) | . | 0 | 0 | Q(t) | . | 0 | 1 | 0 | . | 1 | 0 | 1 | . | 1 | 1 | - | . Here, Q(t) &amp; Q(t + 1) are present state &amp; next state respectively. So, SR flip-flop can be used for one of these three functions such as Hold, Reset &amp; Set based on the input conditions, when positive transition of clock signal is applied. ",
    "url": "/docs/seq-ssi/flip-flops.html#state-table",
    
    "relUrl": "/docs/seq-ssi/flip-flops.html#state-table"
  },"147": {
    "doc": "Flip-flops",
    "title": "Characteristic table",
    "content": "Therefore, SR Latch performs three types of functions such as Hold, Set &amp; Reset based on the input conditions. | S | R | Q(t) | Q(t+1) | . | 0 | 0 | 0 | 0 | . | 0 | 0 | 1 | 1 | . | 0 | 1 | 0 | 0 | . | 0 | 1 | 1 | 0 | . | 1 | 0 | 0 | 1 | . | 1 | 0 | 1 | 1 | . | 1 | 1 | 0 | x | . | 1 | 1 | 1 | x | . By using three variable K-Map, you can get the simplified expression for next state, Q(t + 1). The three variable K-Map for next state, Q(t + 1) is shown in the following figure. The maximum possible groupings of adjacent ones are already shown in the figure. Therefore, the simplified expression for next state Q(t + 1) is . Q(t + 1) = S + R'.Q(t) . ",
    "url": "/docs/seq-ssi/flip-flops.html#characteristic-table",
    
    "relUrl": "/docs/seq-ssi/flip-flops.html#characteristic-table"
  },"148": {
    "doc": "Flip-flops",
    "title": "D flip-flop",
    "content": " ",
    "url": "/docs/seq-ssi/flip-flops.html#d-flip-flop",
    
    "relUrl": "/docs/seq-ssi/flip-flops.html#d-flip-flop"
  },"149": {
    "doc": "Flip-flops",
    "title": "Introduction",
    "content": "D flip-flop operates with only positive clock transitions or negative clock transitions. Whereas, D latch operates with enable signal. That means, the output of D flip-flop is insensitive to the changes in the input, D except for active transition of the clock signal. The circuit diagram of D flip-flop is shown in the following figure. This circuit has single input D and two outputs Q(t) &amp; Q(t)’. The operation of D flip-flop is similar to D Latch. But, this flip-flop affects the outputs only when positive transition of the clock signal is applied instead of active enable. ",
    "url": "/docs/seq-ssi/flip-flops.html#introduction-2",
    
    "relUrl": "/docs/seq-ssi/flip-flops.html#introduction-2"
  },"150": {
    "doc": "Flip-flops",
    "title": "State table",
    "content": "| D | Q(t+1) | . | 0 | 0 | . | 1 | 1 | . Therefore, D flip-flop always Hold the information, which is available on data input, D of earlier positive transition of clock signal. From the above state table, the next state equation can be directly written as . Q(t + 1) = D . Next state of D flip-flop is always equal to data input, D for every positive transition of the clock signal. Hence, D flip-flops can be used in registers, shift registers and some of the counters. ",
    "url": "/docs/seq-ssi/flip-flops.html#state-table-1",
    
    "relUrl": "/docs/seq-ssi/flip-flops.html#state-table-1"
  },"151": {
    "doc": "Flip-flops",
    "title": "JK flip-flop",
    "content": " ",
    "url": "/docs/seq-ssi/flip-flops.html#jk-flip-flop",
    
    "relUrl": "/docs/seq-ssi/flip-flops.html#jk-flip-flop"
  },"152": {
    "doc": "Flip-flops",
    "title": "Introduction",
    "content": "JK flip-flop is the modified version of SR flip-flop. It operates with only positive clock transitions or negative clock transitions. The circuit diagram of JK flip-flop is shown in the following figure. This circuit has two inputs J &amp; K and two outputs Q(t) &amp; Q(t)’. The operation of JK flip-flop is similar to SR flip-flop. Here, the inputs of SR flip-flop are considered as S = J Q(t)’ and R = KQ(t) in order to utilize the modified SR flip-flop for 4 combinations of inputs. ",
    "url": "/docs/seq-ssi/flip-flops.html#introduction-3",
    
    "relUrl": "/docs/seq-ssi/flip-flops.html#introduction-3"
  },"153": {
    "doc": "Flip-flops",
    "title": "State table",
    "content": "| J | K | Q(t+1) | . | 0 | 0 | Q(t) | . | 0 | 1 | 0 | . | 1 | 0 | 1 | . | 1 | 1 | Q(t)’ | . Here, Q(t) &amp; Q(t + 1) are present state &amp; next state respectively. So, JK flip-flop can be used for one of these four functions such as Hold, Reset, Set &amp; Complement of present state based on the input conditions, when positive transition of clock signal is applied. ",
    "url": "/docs/seq-ssi/flip-flops.html#state-table-2",
    
    "relUrl": "/docs/seq-ssi/flip-flops.html#state-table-2"
  },"154": {
    "doc": "Flip-flops",
    "title": "Characteristic table",
    "content": "| J | K | Q(t) | Q(t+1) | . | 0 | 0 | 0 | 0 | . | 0 | 0 | 1 | 1 | . | 0 | 1 | 0 | 0 | . | 0 | 1 | 1 | 0 | . | 1 | 0 | 0 | 1 | . | 1 | 0 | 1 | 1 | . | 1 | 1 | 0 | 1 | . | 1 | 1 | 1 | 0 | . By using three variable K-Map, you can get the simplified expression for next state, Q(t + 1). The three variable K-Map for next state, Q(t + 1) is shown in the following figure. The maximum possible groupings of adjacent ones are already shown in the figure. Therefore, the simplified expression for next state Q(t+1) is . Q(t + 1) = J.Q(t)' + K'.Q(t) . ",
    "url": "/docs/seq-ssi/flip-flops.html#characteristic-table-1",
    
    "relUrl": "/docs/seq-ssi/flip-flops.html#characteristic-table-1"
  },"155": {
    "doc": "Flip-flops",
    "title": "T flip-flop",
    "content": " ",
    "url": "/docs/seq-ssi/flip-flops.html#t-flip-flop",
    
    "relUrl": "/docs/seq-ssi/flip-flops.html#t-flip-flop"
  },"156": {
    "doc": "Flip-flops",
    "title": "Introduction",
    "content": "T flip-flop is the simplified version of JK flip-flop. It is obtained by connecting the same input ‘T’ to both inputs of JK flip-flop. It operates with only positive clock transitions or negative clock transitions. The circuit diagram of T flip-flop is shown in the following figure. This circuit has single input T and two outputs Q(t) &amp; Q(t)’. The operation of T flip-flop is same as that of JK flip-flop. Here, the inputs of JK flip-flop are considered as J = T and K = T in order to utilize the modified JK flip-flop for 2 combinations of inputs. So, the other two combinations of J &amp; K are eliminated, for which those two values are complement to each other in T flip-flop. ",
    "url": "/docs/seq-ssi/flip-flops.html#introduction-4",
    
    "relUrl": "/docs/seq-ssi/flip-flops.html#introduction-4"
  },"157": {
    "doc": "Flip-flops",
    "title": "State table",
    "content": "| D | Q(t+1) | . | 0 | Q(t) | . | 1 | Q(t)’ | . Here, Q(t) &amp; Q(t + 1) are present state &amp; next state respectively. So, T flip-flop can be used for one of these two functions such as Hold, &amp; Complement of present state based on the input conditions, when positive transition of clock signal is applied. ",
    "url": "/docs/seq-ssi/flip-flops.html#state-table-3",
    
    "relUrl": "/docs/seq-ssi/flip-flops.html#state-table-3"
  },"158": {
    "doc": "Flip-flops",
    "title": "Characteristic table",
    "content": "| T | Q(t) | Q(t + 1) | . | 0 | 0 | 0 | . | 0 | 1 | 1 | . | 1 | 0 | 1 | . | 1 | 1 | 0 | . From the above characteristic table, the next state equation can be directly written as: . Q(t + 1) = T'.Q(t) + T.Q(t)' =&gt; Q(t + 1) = T ⊕ Q(t) . The output of T flip-flop always toggles for every positive transition of the clock signal, when input T remains at logic High (1). Hence, T flip-flop can be used in counters. ",
    "url": "/docs/seq-ssi/flip-flops.html#characteristic-table-2",
    
    "relUrl": "/docs/seq-ssi/flip-flops.html#characteristic-table-2"
  },"159": {
    "doc": "Flip-flops",
    "title": "Master-slave JK flip-Flop",
    "content": " ",
    "url": "/docs/seq-ssi/flip-flops.html#master-slave-jk-flip-flop",
    
    "relUrl": "/docs/seq-ssi/flip-flops.html#master-slave-jk-flip-flop"
  },"160": {
    "doc": "Flip-flops",
    "title": "Introduction",
    "content": "Master-slave JK flip-flop is designed to eliminate the race around condition in JK flip-flop and it is constructed by using two JK flip-flops as shown in the circuit diagram below. The first flip-flop is called the master, and it is driven by the positive clock cycle. The second flip-flop is called the slave, and it is driven by the negative clock cycle. During the positive clock cycle, master flip-flop gives the intermediate output but slave flip-flop will not give the final output. During the negative clock cycle, slave flip-flop gets activated and copies the previous output of the master flip-flop and produces the final output. ",
    "url": "/docs/seq-ssi/flip-flops.html#introduction-5",
    
    "relUrl": "/docs/seq-ssi/flip-flops.html#introduction-5"
  },"161": {
    "doc": "Flip-flops",
    "title": "Master-slave JK flip-flop constructed by using NAND gates",
    "content": " ",
    "url": "/docs/seq-ssi/flip-flops.html#master-slave-jk-flip-flop-constructed-by-using-nand-gates",
    
    "relUrl": "/docs/seq-ssi/flip-flops.html#master-slave-jk-flip-flop-constructed-by-using-nand-gates"
  },"162": {
    "doc": "Flip-flops",
    "title": "State table",
    "content": "| Clock | J | K | Q(n+1) | Comments | . | 0 | X | X | Q(n) | No change | . | 1 | 0 | 0 | Q(n) | No change | . | 1 | 0 | 1 | 0 | Reset | . | 1 | 1 | 0 | 1 | Set | . | 1 | 1 | 1 | Q(n)’ | Toggle | . Here, Q(n) is the present state and Q(n+1) is the next state. ",
    "url": "/docs/seq-ssi/flip-flops.html#state-table-4",
    
    "relUrl": "/docs/seq-ssi/flip-flops.html#state-table-4"
  },"163": {
    "doc": "Flip-flops",
    "title": "Characteristic table",
    "content": "| Q(n) | J | K | Q(n+1) | . | 0 | 0 | 0 | 0 | . | 0 | 0 | 1 | 0 | . | 0 | 1 | 0 | 1 | . | 0 | 1 | 1 | 1 | . | 1 | 0 | 0 | 1 | . | 1 | 0 | 1 | 0 | . | 1 | 1 | 0 | 1 | . | 1 | 1 | 1 | 0 | . ",
    "url": "/docs/seq-ssi/flip-flops.html#characteristic-table-3",
    
    "relUrl": "/docs/seq-ssi/flip-flops.html#characteristic-table-3"
  },"164": {
    "doc": "Flip-flops",
    "title": "Excitation table",
    "content": "| Q(n) | Q(n+1) | J | K | . | 0 | 0 | 0 | X | . | 0 | 1 | 1 | X | . | 1 | 0 | X | 1 | . | 1 | 1 | X | 0 | . ",
    "url": "/docs/seq-ssi/flip-flops.html#excitation-table",
    
    "relUrl": "/docs/seq-ssi/flip-flops.html#excitation-table"
  },"165": {
    "doc": "Flip-flops",
    "title": "Characteristic equation",
    "content": "Q(n+1) = Q(n)'J + Q(n)K' . ",
    "url": "/docs/seq-ssi/flip-flops.html#characteristic-equation",
    
    "relUrl": "/docs/seq-ssi/flip-flops.html#characteristic-equation"
  },"166": {
    "doc": "Flip-flops",
    "title": "Flip-flops interaction",
    "content": ". ",
    "url": "/docs/seq-ssi/flip-flops.html#flip-flops-interaction",
    
    "relUrl": "/docs/seq-ssi/flip-flops.html#flip-flops-interaction"
  },"167": {
    "doc": "Flip-flops",
    "title": "State Table Generator",
    "content": "\"A State Table is a tabular representation of the time sequence of inputs, outputs, and flip-flop states. The table consists of four sections marked as present table, next state, and the output. The present-state section shows the states of flip-flops at any given time t. The input section gives a value for each possible present state. The next-state section lists the state of flip-flops one clock period later at time t + 1. Lastly, the output section gives the value for each present state.\" . Let's Begin STEP 1. Provide the following. FLIP-FLOP TYPE JK RS D T FLIP-FLOP COUNT 1 2 INPUT COUNT 1 2 OUTPUT YES NO Back Next STEP 2. Input the required flip-flop input/output functions. Back Next Feel free to review your input before generating your state table. Back Confirm Generate Another . ",
    "url": "/docs/seq-ssi/flip-flops.html",
    
    "relUrl": "/docs/seq-ssi/flip-flops.html"
  },"168": {
    "doc": "Flowchart diagrams",
    "title": "Flow diagrams",
    "content": " ",
    "url": "/docs/seq-design/flow-diagrams.html#flow-diagrams",
    
    "relUrl": "/docs/seq-design/flow-diagrams.html#flow-diagrams"
  },"169": {
    "doc": "Flowchart diagrams",
    "title": "Table of contents",
    "content": ". | Introduction | Example | Algorithmic State Machines | References | . ",
    "url": "/docs/seq-design/flow-diagrams.html#table-of-contents",
    
    "relUrl": "/docs/seq-design/flow-diagrams.html#table-of-contents"
  },"170": {
    "doc": "Flowchart diagrams",
    "title": "Introduction",
    "content": "Finite State Machines can also be represented graphically by means of Flowchart diagrams. Therefore a direct conversion from Flowchart diagrams to State Diagrams is possible. Several resources about Flowcharts can be found in the References and Further reading sections of the Wikipedia entry about Flowcharts . ",
    "url": "/docs/seq-design/flow-diagrams.html#introduction",
    
    "relUrl": "/docs/seq-design/flow-diagrams.html#introduction"
  },"171": {
    "doc": "Flowchart diagrams",
    "title": "Example",
    "content": "Equivalence between state diagram and flowchart diagram ",
    "url": "/docs/seq-design/flow-diagrams.html#example",
    
    "relUrl": "/docs/seq-design/flow-diagrams.html#example"
  },"172": {
    "doc": "Flowchart diagrams",
    "title": "Algorithmic State Machines",
    "content": "An extension to the flowchart diagram which includes timing information is known as the Algorithmic State Machine (ASM) chart. More information about ASM charts can be found in: . | Section 7.2 “ASM Diagrams” in [1] | Section “Algoritmic state machines” (Chapter 5) in [2] | ASM++ Project webpage at the Universidad de Valladolid ASM++: a modern Algorithmic State Machine methodology for RTL designs | . ",
    "url": "/docs/seq-design/flow-diagrams.html#algorithmic-state-machines",
    
    "relUrl": "/docs/seq-design/flow-diagrams.html#algorithmic-state-machines"
  },"173": {
    "doc": "Flowchart diagrams",
    "title": "References",
    "content": ". | [1]G. Donzellini, L. Oneto, D. Ponta, and D. Anguita, Introduction to Digital Systems Design. Springer International Publishing, 2018 [Online]. Available at: https://books.google.cl/books?id=va1qDwAAQBAJ | [2]J. Stonham, Digital Logic Techniques. CRC Press, 2017 [Online]. Available at: https://books.google.cl/books?id=a-5HDwAAQBAJ | . | A processing step is denoted by a ? . | Rectangular box . | Diamond | Arrow head | . | . | Flowchart helps to identify ? . | All of these . | Flow of algorithms | Flaws | Bottlenecks | . | . | What does a terminator symbol represents ? . | Starting or ending point . | Document or a report | Direction of a process | Document or a report | . | . | . ",
    "url": "/docs/seq-design/flow-diagrams.html#references",
    
    "relUrl": "/docs/seq-design/flow-diagrams.html#references"
  },"174": {
    "doc": "Flowchart diagrams",
    "title": "Flowchart diagrams",
    "content": " ",
    "url": "/docs/seq-design/flow-diagrams.html",
    
    "relUrl": "/docs/seq-design/flow-diagrams.html"
  },"175": {
    "doc": "FPGA",
    "title": "Field-Programmable Gate Arrays",
    "content": " ",
    "url": "/docs/seq-lsi/fpga.html#field-programmable-gate-arrays",
    
    "relUrl": "/docs/seq-lsi/fpga.html#field-programmable-gate-arrays"
  },"176": {
    "doc": "FPGA",
    "title": "Table of contents",
    "content": ". | Introduction | Interactive FPGA example | . ",
    "url": "/docs/seq-lsi/fpga.html#table-of-contents",
    
    "relUrl": "/docs/seq-lsi/fpga.html#table-of-contents"
  },"177": {
    "doc": "FPGA",
    "title": "Introduction",
    "content": "In 1985, a new programmable hardware architecture evolved from the PLDs , the Field Programmable Gate Array (FPGA) developed by Xilix Inc. See the IEEE Chip Hall of Fame entry on the Xilinx XC2064 FPGA for some history about it. An FPGA chip contains several logic cells which can be arbitrarily interconnected according to the programmed configuration. Each logic cell holds a combinational element called Look-Up Table (LUT) and a D Flip-flop sequential element whose input is the LUT’s output. The output of the logic cell can be either the LUT output or the D Flip-Flop output, which can be selected by means of a MUX. By selecting the direct LUT output the cell acts as a “pure” combinational element. Otherwise, the cell acts as a synchronous sequential element. The LUT usually has a few input bits (3 to 6 bits) and 1 bit output. It is usually implemented using a MUX to select the programmed output for a specific input combination. FPGA also implement input-output cells (IO-cell) which also have a D Flip-flop which help synchronisation from . Check the interactive circuit below for examples of the logic-cell, the LUT and the IO-cell. FPGAs allow a complex circuit design to be programmed and re-programmed on a single integrated circuit, much like programming a microprocessor, but provides a similar performance as if the circuit had been implemented with actual discrete components, unlike microprocessors which are several orders of magnitude slower than the equivalent FSM implemented using digital logic discrete components. In general, FSM designs implemented in FPGA are faster and use less power than the same FSM implemented in a microprocessor. However, the design process might be a bit harder since it requires the skills to design logic circuits and not just software programming skills. The hardware configuration or programming is usually described using standardised languages known as hardware description languages or HDL. Two of the most common languages are Verilog and VHDL. More information about FPGA can be found in the website fpga4fun.com by Jean P. Nicolle. FPGA are so versatile than even full microprocessors can be implemented in them, although it might not be as cost effective as using microprocessor integrated circuits. ",
    "url": "/docs/seq-lsi/fpga.html#introduction",
    
    "relUrl": "/docs/seq-lsi/fpga.html#introduction"
  },"178": {
    "doc": "FPGA",
    "title": "Interactive FPGA example",
    "content": ". | Configurable Logic Blocks are surrounded by a system of programmable interconnects is known as . | fabric . | chips | flip-flop | finite | . | . | What is the function of D flip flop in FPGA ? . | Store output . | Store input | Display output | None | . | . | FPGA was invented by __________ ? . | Xilinx . | Altera | Actel | Lattice | . | . | FPGAs are __________ devices. | Fine-grain . | Coarse-grain | Rely-grain | None | . | . | . ",
    "url": "/docs/seq-lsi/fpga.html#interactive-fpga-example",
    
    "relUrl": "/docs/seq-lsi/fpga.html#interactive-fpga-example"
  },"179": {
    "doc": "FPGA",
    "title": "FPGA",
    "content": " ",
    "url": "/docs/seq-lsi/fpga.html",
    
    "relUrl": "/docs/seq-lsi/fpga.html"
  },"180": {
    "doc": "FSM",
    "title": "Finite State Machines",
    "content": " ",
    "url": "/docs/seq-design/fsm.html#finite-state-machines",
    
    "relUrl": "/docs/seq-design/fsm.html#finite-state-machines"
  },"181": {
    "doc": "FSM",
    "title": "Table of contents",
    "content": ". | Introduction | Mealy state machine | Moore state machine | Interactive FSM | Problem | Rules | Understanding the possibilities | FSM diagram | . ",
    "url": "/docs/seq-design/fsm.html#table-of-contents",
    
    "relUrl": "/docs/seq-design/fsm.html#table-of-contents"
  },"182": {
    "doc": "FSM",
    "title": "Introduction",
    "content": "You know that synchronous sequential circuits change (affect) their states for every positive (or negative) transition of the clock signal based on the input. So, this behavior of synchronous sequential circuits can be represented in the graphical form and it is known as state diagram. A synchronous sequential circuit is also called as Finite state machine (FSM) if it has a finite number of states. There are two types of FSMs. | Mealy State Machine | Moore State Machine | . Now, let us discuss these two state machines one by one. ",
    "url": "/docs/seq-design/fsm.html#introduction",
    
    "relUrl": "/docs/seq-design/fsm.html#introduction"
  },"183": {
    "doc": "FSM",
    "title": "Mealy state machine",
    "content": "A Finite State Machine is said to be Mealy state machine, if outputs depend on both present inputs &amp; present states. The block diagram of Mealy state machine is shown in the following figure. As shown in the figure, there are two parts present in Mealy state machine. Those are combinational logic and memory. Memory is useful to provide some or part of previous outputs (present states) as inputs of combinational logic. So, based on the present inputs and present states, the Mealy state machine produces outputs. Therefore, the outputs will be valid only at the positive (or negative) transition of the clock signal. The state diagram of Mealy state machine is shown in the following figure. In the above figure, there are three states, namely A, B &amp; C. These states are labelled inside the circles &amp; each circle corresponds to one state. Transitions between these states are represented with directed lines. Here, 0 / 0, 1 / 0 &amp; 1 / 1 denotes input / output. In the above figure, there are two transitions from each state based on the value of an input, x. In general, the number of states required in Mealy state machine is less than or equal to the number of states required in the Moore state machine. There is an equivalent Moore state machine for each Mealy state machine. ",
    "url": "/docs/seq-design/fsm.html#mealy-state-machine",
    
    "relUrl": "/docs/seq-design/fsm.html#mealy-state-machine"
  },"184": {
    "doc": "FSM",
    "title": "Moore state machine",
    "content": "A Finite State Machine is said to be Moore state machine, if outputs depend only on present states. The block diagram of the Moore state machine is shown in the following figure. As shown in the figure, there are two parts present in Moore state machine. Those are combinational logic and memory. In this case, the present inputs and present states determine the next states. So, based on the next states, Moore state machine produces the outputs. Therefore, the outputs will be valid only after the transition of the state. The state diagram of the Moore state machine is shown in the following figure. In the above figure, there are four states, namely A, B, C &amp; D. These states and the respective outputs are labelled inside the circles. Here, only the input value is labelled on each transition. In the above figure, there are two transitions from each state based on the value of the input, x. In general, the number of states required in Moore state machine is more than or equal to the number of states required in Mealy state machine. There is an equivalent Mealy state machine for each Moore state machine. So, based on the requirement you can use only one of them. ",
    "url": "/docs/seq-design/fsm.html#moore-state-machine",
    
    "relUrl": "/docs/seq-design/fsm.html#moore-state-machine"
  },"185": {
    "doc": "FSM",
    "title": "Interactive FSM",
    "content": "In this module, you will learn how to use a Final-State-Machine(FSM) which describes the working of a Soda vending machine: . ",
    "url": "/docs/seq-design/fsm.html#interactive-fsm",
    
    "relUrl": "/docs/seq-design/fsm.html#interactive-fsm"
  },"186": {
    "doc": "FSM",
    "title": "Problem",
    "content": "Assume, you have a soda vending machine which sells soda cans of cost 15¢ each, and you have only 2 types of coins: 10¢ and 5¢. In this problem, our goal is to make a state machine which can determine, how much change should be returned, and when a can is dispenced. Note: In this design, ignore the capacity of the stock, which means, we’ll assume that there will always be can in the vending machine. Also, you can assume that only one action could be made in every “clock cycle” or state. ",
    "url": "/docs/seq-design/fsm.html#problem",
    
    "relUrl": "/docs/seq-design/fsm.html#problem"
  },"187": {
    "doc": "FSM",
    "title": "Rules",
    "content": ". | First, give the change. | Then dispense the can. | . ",
    "url": "/docs/seq-design/fsm.html#rules",
    
    "relUrl": "/docs/seq-design/fsm.html#rules"
  },"188": {
    "doc": "FSM",
    "title": "Understanding the possibilities",
    "content": "There are quite some options like: . | entering no money. | putting 5¢ followed by another 10¢ =&gt; getting the can. | putting 10¢ followed by 10¢ =&gt; receiving change =&gt; getting a can. | putting 5¢ followed by 5¢ followed by 10¢=&gt; receiving change =&gt; getting a can. | putting 10¢ followed by 5¢ and getting the can. | putting 5$ followed by 5¢ followed by 5¢ =&gt; getting a can. | . ",
    "url": "/docs/seq-design/fsm.html#understanding-the-possibilities",
    
    "relUrl": "/docs/seq-design/fsm.html#understanding-the-possibilities"
  },"189": {
    "doc": "FSM",
    "title": "FSM diagram",
    "content": "Now translate the options which are listed above into an FSM diagram/flow-chart: . Finite State Machines . The 'idle' state will be the first state, the machine will be, when its has been 'turned on', and in this the state we also 'Reset' the machine into. Note: The FSM is the Moore machine, because the current state related to the output. ",
    "url": "/docs/seq-design/fsm.html#fsm-diagram",
    
    "relUrl": "/docs/seq-design/fsm.html#fsm-diagram"
  },"190": {
    "doc": "FSM",
    "title": " Experiment",
    "content": ". Lets try the soda can vending machine and look for the corresponding state changes FSM diagram in each of the above mentioned possibilities. ",
    "url": "/docs/seq-design/fsm.html",
    
    "relUrl": "/docs/seq-design/fsm.html"
  },"191": {
    "doc": "FSM",
    "title": "FSM",
    "content": " ",
    "url": "/docs/seq-design/fsm.html",
    
    "relUrl": "/docs/seq-design/fsm.html"
  },"192": {
    "doc": "Functional description",
    "title": "Functional description",
    "content": " ",
    "url": "/docs/logic-design/functional-description.html",
    
    "relUrl": "/docs/logic-design/functional-description.html"
  },"193": {
    "doc": "Functional description",
    "title": "Table of contents",
    "content": ". | Introduction | Design procedure of combinational circuits | . ",
    "url": "/docs/logic-design/functional-description.html#table-of-contents",
    
    "relUrl": "/docs/logic-design/functional-description.html#table-of-contents"
  },"194": {
    "doc": "Functional description",
    "title": "Introduction",
    "content": "Combinational circuits consist of Logic gates. These circuits operate with binary values. The output(s) of combinational circuit depends on the combination of present inputs. The following figure shows the block diagram of combinational circuit. Combinational Circuit This combinational circuit has ‘n’ input variables and ‘m’ outputs. Each combination of input variables will affect the output(s). ",
    "url": "/docs/logic-design/functional-description.html#introduction",
    
    "relUrl": "/docs/logic-design/functional-description.html#introduction"
  },"195": {
    "doc": "Functional description",
    "title": "Design procedure of combinational circuits",
    "content": ". | Find the required number of input variables and outputs from given specifications. | Formulate the Truth table. If there are ‘n’ input variables, then there will be 2n possible combinations. For each combination of input, find the output values. | Find the Boolean expressions for each output. If necessary, simplify those expressions. | Implement the above Boolean expressions corresponding to each output by using Logic gates. | . ",
    "url": "/docs/logic-design/functional-description.html#design-procedure-of-combinational-circuits",
    
    "relUrl": "/docs/logic-design/functional-description.html#design-procedure-of-combinational-circuits"
  },"196": {
    "doc": "IEEE Std 754",
    "title": "IEEE Standard 754",
    "content": " ",
    "url": "/docs/binary-algebra/ieee-std-754.html#ieee-standard-754",
    
    "relUrl": "/docs/binary-algebra/ieee-std-754.html#ieee-standard-754"
  },"197": {
    "doc": "IEEE Std 754",
    "title": "Table of contents",
    "content": ". | Representing real numbers . | Fixed point | Floating point | . | The IEEE 754 Standard | References | . ",
    "url": "/docs/binary-algebra/ieee-std-754.html#table-of-contents",
    
    "relUrl": "/docs/binary-algebra/ieee-std-754.html#table-of-contents"
  },"198": {
    "doc": "IEEE Std 754",
    "title": "Representing real numbers",
    "content": "While the representation of integer quantities using binary numbers is straightforward, representation of real numbers and its arithmetics require special care. See Section 3.11 in [1] . Fixed point . One a approach is to a use fixed point representation, in which a certain number of bits are used to encode the integer part, and the remaining bits are used to encode the fractional part. For instance, if our binary numbers are 8 bits wide, and the four most signigicant bits are used for the integer part and the four least significant bits for the fractional part, then the number 12.09 would be encoded as $\\underbrace{1_7 1_6 0_5 0_4}_{\\text{integer part}}\\, \\overbrace{1_3 0_2 0_1 1_0}^{\\text{fractional part}}$. Floating point . Another approach is the floating point method. It represents a number using a mantissa or significand $s$ and an exponent $e$ considering a fixed base $b$ such that the number can be expressed by $(s\\times b^e)$ . A part of the binary number is used to store the significand (including a sign bit) and the other part to store the exponent (also with a sign bit). ",
    "url": "/docs/binary-algebra/ieee-std-754.html#representing-real-numbers",
    
    "relUrl": "/docs/binary-algebra/ieee-std-754.html#representing-real-numbers"
  },"199": {
    "doc": "IEEE Std 754",
    "title": "The IEEE 754 Standard",
    "content": "There are multiple ways of implementenig floating point numbers and arithmetics. However, since 1985 the IEEE Standard for Floating-Point Arithmetic (IEEE 754) has been available addressing many issues and providing a reliable and portable definition. The latest version of the standard was published in 2019 [2] and the latest ISO version (identical to the IEEE Std 754) was published in 2020 [3] . ",
    "url": "/docs/binary-algebra/ieee-std-754.html#the-ieee-754-standard",
    
    "relUrl": "/docs/binary-algebra/ieee-std-754.html#the-ieee-754-standard"
  },"200": {
    "doc": "IEEE Std 754",
    "title": "References",
    "content": ". | [1]G. Donzellini, L. Oneto, D. Ponta, and D. Anguita, Introduction to Digital Systems Design. Springer International Publishing, 2018 [Online]. Available at: https://books.google.cl/books?id=va1qDwAAQBAJ | [2]“IEEE Standard for Floating-Point Arithmetic,” IEEE Std 754-2019 (Revision of IEEE 754-2008), pp. 1–84, 2019, doi: 10.1109/IEEESTD.2019.8766229. | [3]ISO Central Secretary, “Information technology– Microprocessor Systems – Floating-Point arithmetic,” International Organization for Standardization, Geneva, CH, Standard ISO/IEC TR 60559:2020, 2020 [Online]. Available at: https://www.iso.org/standard/80985.html | . ",
    "url": "/docs/binary-algebra/ieee-std-754.html#references",
    
    "relUrl": "/docs/binary-algebra/ieee-std-754.html#references"
  },"201": {
    "doc": "IEEE Std 754",
    "title": "IEEE Std 754",
    "content": " ",
    "url": "/docs/binary-algebra/ieee-std-754.html",
    
    "relUrl": "/docs/binary-algebra/ieee-std-754.html"
  },"202": {
    "doc": "Implementation",
    "title": "Implementation",
    "content": " ",
    "url": "/docs/logic-design/implementation.html",
    
    "relUrl": "/docs/logic-design/implementation.html"
  },"203": {
    "doc": "Implementation",
    "title": "Table of contents",
    "content": ". | From Boolean function to a logic circuit . | Example | . | Optimizing a circuit | . ",
    "url": "/docs/logic-design/implementation.html#table-of-contents",
    
    "relUrl": "/docs/logic-design/implementation.html#table-of-contents"
  },"204": {
    "doc": "Implementation",
    "title": "From Boolean function to a logic circuit",
    "content": "The easiest path to go from a logic design to an actual logic circuit is to obtain its Boolean function and replace the logical addition, multiplication and negation operators by the logical OR, AND and NOT gates. If the design is expressed as a truth table or a map (such as the ones described in K-Maps) it is better to transform them to the equivalent Boolean function. Another representation presented in the section Map-entered Variables can be directly implemented with multiplexers, a medium scale integration (MSI) component described in section MUX/DEMUX. Example . The logic system defined by the truth table in Table 1: . | : Table 1: Truth table of function $F(x,y,z)$ {: .tblcap } :|||| |   |   |   |   | . | $i$ | $x$ | $y$ | $z$ | $F$ | . | 0 | 0 | 0 | 0 | 0 | . | 1 | 0 | 0 | 1 | 1 | . | 2 | 0 | 1 | 0 | 0 | . | 3 | 0 | 1 | 1 | 0 | . | 4 | 1 | 0 | 0 | 0 | . | 5 | 1 | 0 | 1 | 0 | . | 6 | 1 | 1 | 0 | 1 | . | 7 | 1 | 1 | 1 | 1 | . can be represented by the function: . $F(x,y,z) = \\overline{x}\\overline{y}z + xy\\overline{z} + xyz$ . using Boolean algebra’s rules and laws the function can be re-arranged as . $\\begin{align*} F(x,y,z) &amp;= \\overline{x}\\overline{y}z + xy\\underbrace{(\\overline{z} + z)}_{=1}\\\\ F(x,y,z) &amp;= \\overline{x}\\overline{y}z + xy \\end{align*}$ . By replacing the negations by NOT gates, the sum by an OR gate and the products by AND gates, the following circuit is implemented: . ",
    "url": "/docs/logic-design/implementation.html#from-boolean-function-to-a-logic-circuit",
    
    "relUrl": "/docs/logic-design/implementation.html#from-boolean-function-to-a-logic-circuit"
  },"205": {
    "doc": "Implementation",
    "title": "Optimizing a circuit",
    "content": "As it was shown in the example above, in general, a Boolean function is reduced before its implementation. The reduced expression leads to a more optimal circuit, with fewer gates and connections. In turn, this makes the circuit less complex and easier to implement, debug and repair. It may also reduce the total cost and energy requirements due to the reduced number of components. Additionally, if the circuit is being implemented with discrete components, it will be more compact in size. There are several methods to minimise a logic function: . | Use the Boolean algebra’s laws and rules. This process is complex and difficult but it works for any function, independent of the number of variables. | A graphical, visual inspection method based on the representation using Karnaugh Maps as described in section K-Maps or the extension using Map-entered Variables shown in section Map-entered variables or the | A tabular recursive algorithm known as Quine-McCluskey method which is explained in section Quine McCluskey. | Even other optimisation methods can be used (for instance, heuristic based, or evolutionary computation), specially with extremely large circuits or when additional restrictions need to be satisfied. | . ",
    "url": "/docs/logic-design/implementation.html#optimizing-a-circuit",
    
    "relUrl": "/docs/logic-design/implementation.html#optimizing-a-circuit"
  },"206": {
    "doc": "Combinational SSI",
    "title": "Combinational SSI components",
    "content": "Small scale integration combinational components (i.e. logic gates) and some of their features are presented in this chapter. ",
    "url": "/docs/comb-ssi/#combinational-ssi-components",
    
    "relUrl": "/docs/comb-ssi/#combinational-ssi-components"
  },"207": {
    "doc": "Combinational SSI",
    "title": "Chapter contents",
    "content": ". | Basic level . | Logic gates | . | Medium level . | Logic families | Universal gates | . | . ",
    "url": "/docs/comb-ssi/#chapter-contents",
    
    "relUrl": "/docs/comb-ssi/#chapter-contents"
  },"208": {
    "doc": "Combinational SSI",
    "title": "Combinational SSI",
    "content": " ",
    "url": "/docs/comb-ssi/",
    
    "relUrl": "/docs/comb-ssi/"
  },"209": {
    "doc": "Binary algebra",
    "title": "Mathematical operations with binary numbers",
    "content": "This chapter introduce the basic arithmetic operations using binary numbers as well as the Boolean algebra. ",
    "url": "/docs/binary-algebra/#mathematical-operations-with-binary-numbers",
    
    "relUrl": "/docs/binary-algebra/#mathematical-operations-with-binary-numbers"
  },"210": {
    "doc": "Binary algebra",
    "title": "Chapter contents",
    "content": ". | Basic level . | Addition | Division | Multiplication | Subtraction | . | Medium level . | Boolean algebra | Boolean functions | . | Advanced level . | IEEE Std 754 | Shannon decomposition | . | . ",
    "url": "/docs/binary-algebra/#chapter-contents",
    
    "relUrl": "/docs/binary-algebra/#chapter-contents"
  },"211": {
    "doc": "Binary algebra",
    "title": "Binary algebra",
    "content": " ",
    "url": "/docs/binary-algebra/",
    
    "relUrl": "/docs/binary-algebra/"
  },"212": {
    "doc": "Logic Design",
    "title": "Combinational logic design",
    "content": "This chapter explains how to obtain a circuit from a functional definition. It also describes some optimisation methods to reduce the design before implementing it and explains the concepts which are required to understand those procedures. ",
    "url": "/docs/logic-design/#combinational-logic-design",
    
    "relUrl": "/docs/logic-design/#combinational-logic-design"
  },"213": {
    "doc": "Logic Design",
    "title": "Table of contents",
    "content": ". | Basic level . | Functional description | Implementation | . | Medium level . | Canonical functions | K-Maps | . | Advanced level . | Binary cubes | Map-entered variables | Quine McCluskey | . | . ",
    "url": "/docs/logic-design/#table-of-contents",
    
    "relUrl": "/docs/logic-design/#table-of-contents"
  },"214": {
    "doc": "Logic Design",
    "title": "Logic Design",
    "content": " ",
    "url": "/docs/logic-design/",
    
    "relUrl": "/docs/logic-design/"
  },"215": {
    "doc": "Sequential SSI",
    "title": "Sequential SSI components",
    "content": " ",
    "url": "/docs/seq-ssi/#sequential-ssi-components",
    
    "relUrl": "/docs/seq-ssi/#sequential-ssi-components"
  },"216": {
    "doc": "Sequential SSI",
    "title": "Introduction",
    "content": "Unlike Combinational Circuits, most systems that one will encounter in practice will include Memory element thus being described in terms of sequential logic. The memory elements are devices capable of storing binary information within them. The binary information stored in the memory elements at a given time defines the state of the circuit. Thus a sequential circuit is specified by time sequence of inputs, outputs and internal states. | This sequential circuit contains a set of inputs and output(s). | The output(s) of sequential circuit depends not only on the combination of present inputs but also on the previous output(s). | Previous output is nothing but the present state. | Therefore, sequential circuits contain combinational circuits along with memory (storage) elements. | Some sequential circuits may not contain combinational circuits, but only memory elements. | . Following table shows the differences between combinational circuits and sequential circuits. | Combinational Circuits | Sequential Circuits | . | Outputs depend only on present inputs. | Outputs depend on both present inputs and present state. | . | Feedback path is not present. | Feedback path is present. | . | Memory elements are not required. | Memory elements are required. | . | Clock signal is not required. | Clock signal is required. | . | Easy to design. | Difficult to design. | . ",
    "url": "/docs/seq-ssi/#introduction",
    
    "relUrl": "/docs/seq-ssi/#introduction"
  },"217": {
    "doc": "Sequential SSI",
    "title": "Types of sequential circuits",
    "content": "Following are the two types of sequential circuits − . | Asynchronous sequential circuits | Synchronous sequential circuits | . Asynchronous sequential circuits . If some or all the outputs of a sequential circuit do not change (affect) with respect to active transition of clock signal, then that sequential circuit is called as Asynchronous sequential circuit. That means, all the outputs of asynchronous sequential circuits do not change (affect) at the same time. Therefore, most of the outputs of asynchronous sequential circuits are not in synchronous with either only positive edges or only negative edges of clock signal. Synchronous sequential circuits . If all the outputs of a sequential circuit change (affect) with respect to active transition of clock signal, then that sequential circuit is called as Synchronous sequential circuit. That means, all the outputs of synchronous sequential circuits change (affect) at the same time. Therefore, the outputs of synchronous sequential circuits are in synchronous with either only positive edges or only negative edges of clock signal. ",
    "url": "/docs/seq-ssi/#types-of-sequential-circuits",
    
    "relUrl": "/docs/seq-ssi/#types-of-sequential-circuits"
  },"218": {
    "doc": "Sequential SSI",
    "title": "Chapter contents",
    "content": ". | Basic level . | Clock signals | Flip-flops | Latches | . | . ",
    "url": "/docs/seq-ssi/#chapter-contents",
    
    "relUrl": "/docs/seq-ssi/#chapter-contents"
  },"219": {
    "doc": "Sequential SSI",
    "title": "Sequential SSI",
    "content": " ",
    "url": "/docs/seq-ssi/",
    
    "relUrl": "/docs/seq-ssi/"
  },"220": {
    "doc": "Sequential LSI",
    "title": "Sequential LSI components",
    "content": "Large scale integration (LSI) technology can also be used to implement sequential systems. One approach consists in using ROM circuits for the combinational logic block and latches or a counter as memory elements. This simple ROM-based µcontrollers, later evolved into what we know today as µprocessors, by integrating different complementary circuits. Another approach, derived from programmable logic devices (PLDs), is based on Field Programmable Gate Arrays (FPGA). These LSI circuits include several logic cells with each cell containing simple combinational and sequential elements the cells can be interconnected in different ways to implement very complex designs in a single chip, which can also be reconfigured at any time. ",
    "url": "/docs/seq-lsi/#sequential-lsi-components",
    
    "relUrl": "/docs/seq-lsi/#sequential-lsi-components"
  },"221": {
    "doc": "Sequential LSI",
    "title": "Chapter contents",
    "content": ". | Basic level . | FPGA | Microprocessors | ROM-based µcontrollers | . | . ",
    "url": "/docs/seq-lsi/#chapter-contents",
    
    "relUrl": "/docs/seq-lsi/#chapter-contents"
  },"222": {
    "doc": "Sequential LSI",
    "title": "Sequential LSI",
    "content": " ",
    "url": "/docs/seq-lsi/",
    
    "relUrl": "/docs/seq-lsi/"
  },"223": {
    "doc": "Combinational LSI",
    "title": "Combinational LSI components",
    "content": "Large scale integration combinational components such as Read-only Memories (ROMs), Arithmetic Logic Units (ALUs) and Programmable Logic Devices (PLDs) are described in chapter. ",
    "url": "/docs/comb-lsi/#combinational-lsi-components",
    
    "relUrl": "/docs/comb-lsi/#combinational-lsi-components"
  },"224": {
    "doc": "Combinational LSI",
    "title": "Chapter contents",
    "content": ". | Basic level . | ALU | ROM | . | . ",
    "url": "/docs/comb-lsi/#chapter-contents",
    
    "relUrl": "/docs/comb-lsi/#chapter-contents"
  },"225": {
    "doc": "Combinational LSI",
    "title": "Combinational LSI",
    "content": " ",
    "url": "/docs/comb-lsi/",
    
    "relUrl": "/docs/comb-lsi/"
  },"226": {
    "doc": "Sequential MSI",
    "title": "Sequential MSI components",
    "content": "This chapter presents medium scale integration (MSI) sequential components as well as design methods based on these components. ",
    "url": "/docs/seq-msi/#sequential-msi-components",
    
    "relUrl": "/docs/seq-msi/#sequential-msi-components"
  },"227": {
    "doc": "Sequential MSI",
    "title": "Chapter contents",
    "content": ". | Basic level . | Counters | Registers | . | Medium level . | MSI based design | Multipliers/Dividers | . | . ",
    "url": "/docs/seq-msi/#chapter-contents",
    
    "relUrl": "/docs/seq-msi/#chapter-contents"
  },"228": {
    "doc": "Sequential MSI",
    "title": "Sequential MSI",
    "content": " ",
    "url": "/docs/seq-msi/",
    
    "relUrl": "/docs/seq-msi/"
  },"229": {
    "doc": "Binary representation",
    "title": "Representation using binary numbers",
    "content": "This chapter explain the basics of representing quantities and information using binary numbers. ",
    "url": "/docs/binary-representation/#representation-using-binary-numbers",
    
    "relUrl": "/docs/binary-representation/#representation-using-binary-numbers"
  },"230": {
    "doc": "Binary representation",
    "title": "Chapter contents",
    "content": ". | Basic level . | Binary numbers | Encoding information | Negative quantities | Number bases | . | Medium level . | Discrete quantities | . | . ",
    "url": "/docs/binary-representation/#chapter-contents",
    
    "relUrl": "/docs/binary-representation/#chapter-contents"
  },"231": {
    "doc": "Binary representation",
    "title": "Binary representation",
    "content": " ",
    "url": "/docs/binary-representation/",
    
    "relUrl": "/docs/binary-representation/"
  },"232": {
    "doc": "Sequential Design",
    "title": "Sequential Design",
    "content": "The previous chapter about SSI sequential components presented application examples using basic sequential building blocks such as latches and flip-flops. This chapter will describe tools and methods to design and synthesise optimal sequential circuits. ",
    "url": "/docs/seq-design/",
    
    "relUrl": "/docs/seq-design/"
  },"233": {
    "doc": "Sequential Design",
    "title": "Chapter contents",
    "content": ". | Basic level . | FSM | Sequential synthesis | . | Medium level . | Race conditions | . | Advanced level . | Flowchart diagrams | MDS Diagrams | . | . ",
    "url": "/docs/seq-design/#chapter-contents",
    
    "relUrl": "/docs/seq-design/#chapter-contents"
  },"234": {
    "doc": "Combinational MSI",
    "title": "Combinational MSI components",
    "content": " ",
    "url": "/docs/comb-msi/#combinational-msi-components",
    
    "relUrl": "/docs/comb-msi/#combinational-msi-components"
  },"235": {
    "doc": "Combinational MSI",
    "title": "Introduction",
    "content": "MSI or Medium scale integrated circuits are a set of basic, elementary logic circuits. They are available as ICs (integrated chips) and implement specific,commonly used digital functions such as: . | Multiplexing and Demultiplexing | Encoding and Decoding | . MSIs can be used as a stand-alone IC or in combination with other ICs in order to implement combinational circuits in various applications. In this module, you will study many of the common types of MSI devices. For each type, you will start with a brief discussion of its basic operating principle and then introduce specific ICs. Now let’s see how they can be used alone or in combination with other ICs in various applications. ",
    "url": "/docs/comb-msi/#introduction",
    
    "relUrl": "/docs/comb-msi/#introduction"
  },"236": {
    "doc": "Combinational MSI",
    "title": "Chapter contents",
    "content": ". | Basic level . | Adders | Encoders/Decoders | MUX/DEMUX | . | Medium level . | MUX-based functions | . | . ",
    "url": "/docs/comb-msi/#chapter-contents",
    
    "relUrl": "/docs/comb-msi/#chapter-contents"
  },"237": {
    "doc": "Combinational MSI",
    "title": "Combinational MSI",
    "content": " ",
    "url": "/docs/comb-msi/",
    
    "relUrl": "/docs/comb-msi/"
  },"238": {
    "doc": "Home",
    "title": "Interactive-Book",
    "content": "Learn Digital Logic Design easily. The Computer Logical Organization is basically the abstraction which is below the operating system and above the digital logic level. Now at this point, the important points are the functional units/subsystems that refer to some hardware which is made up of lower level building blocks. This interactive book gives a complete understanding on Computer Logical Organization starting from basic computer overview till the advanced level. This book is aimed to provide the knowledge to the reader on how to analyze the combinational and sequential circuits and implement them. You can use the combinational circuit/sequential circuit/combination of both the circuits, as per the requirement. After completing this book, you will be able to implement the type of digital circuit, which is suitable for specific application. ",
    "url": "/#interactive-book",
    
    "relUrl": "/#interactive-book"
  },"239": {
    "doc": "Home",
    "title": "Audience",
    "content": "This book is mainly prepared for the students who are interested in the concepts of digital circuits and Computer Logical Organization. Digital circuits contain a set of Logic gates and these can be operated with binary values, 0 and 1. Prerequisites . Before you start learning from this Book, I hope that you have some basic knowledge about computers and how they work. A basic idea regarding the initial concepts of Digital Electronics is enough to understand the topics covered in this tutorial. ",
    "url": "/#audience",
    
    "relUrl": "/#audience"
  },"240": {
    "doc": "Home",
    "title": "Home",
    "content": " ",
    "url": "/",
    
    "relUrl": "/"
  },"241": {
    "doc": "K-Maps",
    "title": "K-Maps",
    "content": " ",
    "url": "/docs/logic-design/kmaps.html",
    
    "relUrl": "/docs/logic-design/kmaps.html"
  },"242": {
    "doc": "K-Maps",
    "title": "Table of contents",
    "content": ". | Introduction | Enumeration and gray codes | Simple groupings | Two dimension groupings | Disjoint groupings | Overlapping groupings | Minimizing group count | . ",
    "url": "/docs/logic-design/kmaps.html#table-of-contents",
    
    "relUrl": "/docs/logic-design/kmaps.html#table-of-contents"
  },"243": {
    "doc": "K-Maps",
    "title": "Introduction",
    "content": "Karnaugh Maps are a way to visually display a boolean expression onto a 2D grid. Take the variables and bind them to an axis, and then enumerate through the possible combinations of input values that could occur for all those variables bounded to an axis (either horizontally or vertically). For example, display the following 2 variable Karnaugh Map: . You have bounded to the vertical axis, the variable A, and enumerate through the possible values for A (being {0, 1}). Similarly, perform a similar operation for the B variable. Since you are using a 2 variable expression, you can bound one variable to each axis and the visualization works fine in a 2x2 matrix. Let’s instead look at a more involved example with 4 variables: . You have now bounded the A and B variables to the vertical axis, and C and D variables to the horizontal axis. Now enumerate through different combinations of the bounded variables for each axis in reflected binary code order (more on this in the following section). Lastly, indicate on the matrix each true value by augmenting a 1 value. ",
    "url": "/docs/logic-design/kmaps.html#introduction",
    
    "relUrl": "/docs/logic-design/kmaps.html#introduction"
  },"244": {
    "doc": "K-Maps",
    "title": "Enumeration and gray codes",
    "content": "When enumerating through the variable input combinations for the bound axis, we take advantage of reflected binary code order, otherwise known as grey codes. If we observe, we can notice that from one combination to another, we only vary by one bit. That is: ... 00 01 11 10 00 01 11 10 00 ... ^ ^ ^ ^ ^ ^ ^ ^ ^ . Thus, you get this wrapping that allows us to switch by only one bit. This provides us with the core of how Karnaugh Maps work. ",
    "url": "/docs/logic-design/kmaps.html#enumeration-and-gray-codes",
    
    "relUrl": "/docs/logic-design/kmaps.html#enumeration-and-gray-codes"
  },"245": {
    "doc": "K-Maps",
    "title": "Simple groupings",
    "content": "The main idea for how Karnaugh Maps can be used to simplify expressions is to group pairs of 1 values that are adjacent and exploit the fact that each one has only a bit different from another. For this example, let F(ABCD) = CELL. start with the expression F(0000) = 1 and F(0001) = 1. However, notice that regardless of the value of the last bit, you still get 1. Hence, let’s take a look at the SOP expressions: . F(ABCD) = A'B'C'D' + A'B'C'D F(0000) = 1 F(0001) = 1 Since the last bit is the same, you can ignore the D value, thus: F(ABCD) = A'B'C' You can confirm by simplifying algebraically: F(ABCD) = A'B'C'D' + A'B'C'D = A'B'C'(D' + D) = A'B'C' Therefore, the simplification is true. You can then extend this rule to work for rectangles and more! . ",
    "url": "/docs/logic-design/kmaps.html#simple-groupings",
    
    "relUrl": "/docs/logic-design/kmaps.html#simple-groupings"
  },"246": {
    "doc": "K-Maps",
    "title": "Two dimension groupings",
    "content": "Extending the idea of isolating changing bits that retain a consistent value, we can then generalize this to work in a higher dimension. Consider the following example: . Letting F(ABCD) = CELL: . F(0000) = 1 F(0001) = 1 F(0100) = 1 F(0101) = 1 . Observe that the bits do not change by one for all pairs of numbers, for example, {0000, 0101} differ by two bits. However, you can take advantage of the fact that for any bit change horizontally or vertically, it’s irrelevant what that bit is. More concretely, take a look at the following example. 0000 0001 0100 0101 =&gt; A'B'C'D' + A'B'C'D + A'BC'D' + A'BC'D Regardless of the B variable, you still get true for all products in the SOP expression. This is bounded vertically: =&gt; A'C'D' + A'C'D + A'C'D' + A'C'D Regardless of the D variable, you still get true for all products in the SOP expression. This is bounded horizontally: =&gt; A'C' + A'C' + A'C' + A'C' =&gt; A'C' (1 + 1 + 1 + 1) =&gt; A'C' (1) =&gt; A'C' . Since the differences in bits need to generalize throughout a binding of an axis, you can only have a binding of size 2^n for a given axis. For example, 1x1, 1x2, 1x4, 2x2, 2x4, 4x4. ",
    "url": "/docs/logic-design/kmaps.html#two-dimension-groupings",
    
    "relUrl": "/docs/logic-design/kmaps.html#two-dimension-groupings"
  },"247": {
    "doc": "K-Maps",
    "title": "Disjoint groupings",
    "content": "Consider the following example: . The algorithm follows precisely as it did before, except that now the two groups are joined in the SOP expression. Letting F(ABCD) = CELL: . F(0000) = 1 F(0001) = 1 F(1111) = 1 F(1011) = 1 . This yields the following: . A'B'C'D' + A'B'C'D + ABCD + AB'CD Breaking down the expression: (A'B'C'D' + A'B'C'D) + (ABCD + AB'CD) =&gt; (A'B'C'(D + D')) + (ACD(B + B')) =&gt; (A'B'C') + (ACD) =&gt; A'B'C' + ACD . Clearly this is the exact same process as before, but iterated throughout all the disjoint sets. ",
    "url": "/docs/logic-design/kmaps.html#disjoint-groupings",
    
    "relUrl": "/docs/logic-design/kmaps.html#disjoint-groupings"
  },"248": {
    "doc": "K-Maps",
    "title": "Overlapping groupings",
    "content": "Overlapping groupings become more complex because there exist ambiguous cases and sometimes what may appear to be a locally optimal solution is not a globally optimal solution. The general technique for evaluating for overlapping groups follows a greedy algorithm. Define an unvisited cell as a cell that has a value of 1 however it is currently not matched with a grouping yet. Iterate through all the cells, and once you find a cell with 1, if it is unvisited then find the largest possible square or rectangle such that each side length is a power of 2, where all the cells are 1 in its enclosed area. If there is a tie for size (ie, 1x4 vs 2x2), assign the one that is a square (this is by convention). Repeat this process for all remaining unvisited cells. Note: You can overlap the groupings with already visited nodes, but you never instantiate a new grouping unless the current node is unvisited. In this example, at F(0000), you can create a grouping of size 2 (because 2 is the largest possible grouping, 3 is not a power of 2). Then iterate through to F(0001), however F(0001) was already resolved to a grouping. For the latest active cell, F(0011) is not resolved to a grouping thus it’s unvisited. The largest possible grouping is also of size 2, thus you create another group. To resolve the groupings into an SOP expression, iterate through the groups and identify changing bits: . Group 1: F(ABCD) = [0000, 0001] Group 2: F(ABCD) = [0001, 0011] For Group 1: 0000 0001 ^ ^ F(ABCD) = A'B'C'D' + A'B'C'D =&gt; A'B'C'(D + D') =&gt; A'B'C' For Group 2: 0001 0011 ^ ^ F(ABCD) = A'B'C'D + A'B'CD =&gt; A'B'D(C' + C) =&gt; A'B'D Now add the two results: F(ABCD) = A'B'C' + A'B'D =&gt; F(ABCD) = A'B'D + A'B'C' (by commutative property) . ",
    "url": "/docs/logic-design/kmaps.html#overlapping-groupings",
    
    "relUrl": "/docs/logic-design/kmaps.html#overlapping-groupings"
  },"249": {
    "doc": "K-Maps",
    "title": "Minimizing group count",
    "content": "The following example will illustrate how the greedy approach may occasionally produce too many groups. Consider the following example: . This grouping state is optimal. However, consider adding a 1 to F(1111). Following the previous algorithm, iterating top-bottom and left-right, when getting to F(0110), the algorithm can choose to make the largest grouping. However, there are two possible groupings: . Candidate 1: F(ABCD) = [0011, 0010, 0111, 0110] Candidate 2: F(ABCD) = [0111, 0110, 1111, 1110] . Both groupings have the same size and are the same dimension. However, upon reaching F(1110), another grouping needs to be instantiated, in which case if the first candidate grouping was created then you made a group that did not necessarily increase the size of our SOP expression. This illustrates the idea that this is a greedy algorithm, and does not always return the most simplified SOP expression. In later sections, algorithms illustrating a globally optimal algorithm will be discussed. This Interactive Karnaugh-Map represents the function- Y&nbsp;=&nbsp;f(xn,...,x1, x0). This function can manually be edited by a click on different cells in the K-map, or by pressing the button:'Random example' a random function can be generated. Random example Reset Number of input variables: 1 2 3 4 5 6 7 8 &nbsp;&nbsp;&nbsp;&nbsp; Allow Don’t-Care: no Yes &nbsp;&nbsp;&nbsp;&nbsp; Hide result: no Yes . | ___ are known as diagonal mapping ? . | POS | SOP . | Entries | . | Latches | . | . | K-map can be used to minimize functions of up to ___ variables ? . | 5 | 2 . | 6 | . | 3 | . | In which K-map 16 cells are there ? * 2-variable . | 3-variable . | 4-variable | . | 5-variable | . | . ",
    "url": "/docs/logic-design/kmaps.html#minimizing-group-count",
    
    "relUrl": "/docs/logic-design/kmaps.html#minimizing-group-count"
  },"250": {
    "doc": "Latches",
    "title": "Latches",
    "content": " ",
    "url": "/docs/seq-ssi/latches.html",
    
    "relUrl": "/docs/seq-ssi/latches.html"
  },"251": {
    "doc": "Latches",
    "title": "Table of contents",
    "content": ". | Latches | Introduction | Differences between latches and flip-flops | Sub-modules | SR latch | Introduction | State table | D latch | Introduction | State table | JK latch | Introduction | State table | T latch | Introduction | State table | . ",
    "url": "/docs/seq-ssi/latches.html#table-of-contents",
    
    "relUrl": "/docs/seq-ssi/latches.html#table-of-contents"
  },"252": {
    "doc": "Latches",
    "title": "Latches",
    "content": " ",
    "url": "/docs/seq-ssi/latches.html",
    
    "relUrl": "/docs/seq-ssi/latches.html"
  },"253": {
    "doc": "Latches",
    "title": "Introduction",
    "content": "There are two types of memory elements based on the type of triggering that is suitable to operate it. | Latches | Flip-flops | . Latches operate with enable signal, which is level sensitive. Whereas, flip-flops are edge sensitive. Let’s discuss about flip-flops in next module. Latches are basic storage elements that operate with signal levels (rather than signal transitions). They are level-sensitive devices, that are useful for the design of the asynchronous sequential circuits. They, generally, have 2 inputs and 1 output pins. And the process where the output of the circuit depends on the previous state and the present input value(s) supplied, with the output value being constant (changing only for a particular condition in the input(s)), is referred to as latching. ",
    "url": "/docs/seq-ssi/latches.html#introduction",
    
    "relUrl": "/docs/seq-ssi/latches.html#introduction"
  },"254": {
    "doc": "Latches",
    "title": "Differences between latches and flip-flops",
    "content": "| Latches | Flip-flops | . | Level triggered | Edge triggered | . | Asynchronous device | Synchronous device | . | Doesn’t contain clock signal | Contains a clock signal | . | It will change its state as long as it is enabled | It will change its state only during a given clock cycle | . | Consumes less power | Consumes more power | . | Faster | Slower | . | Examples: D-Latch, T-Latch | Examples: D-Flip flop, T-Flop flop | . ",
    "url": "/docs/seq-ssi/latches.html#differences-between-latches-and-flip-flops",
    
    "relUrl": "/docs/seq-ssi/latches.html#differences-between-latches-and-flip-flops"
  },"255": {
    "doc": "Latches",
    "title": "Sub-modules",
    "content": "Now, let us discuss about SR Latch, D Latch, JK Latch &amp; T Latch one by one. | SR latch | D latch | JK latch | T latch | . ",
    "url": "/docs/seq-ssi/latches.html#sub-modules",
    
    "relUrl": "/docs/seq-ssi/latches.html#sub-modules"
  },"256": {
    "doc": "Latches",
    "title": "SR latch",
    "content": " ",
    "url": "/docs/seq-ssi/latches.html#sr-latch",
    
    "relUrl": "/docs/seq-ssi/latches.html#sr-latch"
  },"257": {
    "doc": "Latches",
    "title": "Introduction",
    "content": "SR Latch is also called as Set Reset Latch. This latch affects the outputs as long as the enable, E is maintained at ‘1’. The circuit diagram of SR Latch is shown in the following figure. This circuit has two inputs S &amp; R and two outputs Q(t) &amp; Q(t)’. The upper NOR gate has two inputs R &amp; complement of present state, Q(t)’ and produces next state, Q(t+1) when enable, E is ‘1’. Similarly, the lower NOR gate has two inputs S &amp; present state, Q(t) and produces complement of next state, Q(t+1)’ when enable, E is ‘1’. A 2-input NOR gate produces an output, which is the complement of another input when one of the input is ‘0’. Similarly, it produces ‘0’ output, when one of the input is ‘1’. | If S = 1, then next state Q(t + 1) will be equal to ‘1’ irrespective of present state, Q(t) values. | If R = 1, then next state Q(t + 1) will be equal to ‘0’ irrespective of present state, Q(t) values. | . At any time, only of those two inputs should be ‘1’. If both inputs are ‘1’, then the next state Q(t + 1) value is undefined. ",
    "url": "/docs/seq-ssi/latches.html#introduction-1",
    
    "relUrl": "/docs/seq-ssi/latches.html#introduction-1"
  },"258": {
    "doc": "Latches",
    "title": "State table",
    "content": "| S | R | Q(t+1) | . | 0 | 0 | Q(t) | . | 0 | 1 | 0 | . | 1 | 0 | 1 | . | 1 | 1 | - | . Therefore, SR latch performs three types of functions such as Hold, Set &amp; Reset based on the input conditions. ",
    "url": "/docs/seq-ssi/latches.html#state-table",
    
    "relUrl": "/docs/seq-ssi/latches.html#state-table"
  },"259": {
    "doc": "Latches",
    "title": "D latch",
    "content": " ",
    "url": "/docs/seq-ssi/latches.html#d-latch",
    
    "relUrl": "/docs/seq-ssi/latches.html#d-latch"
  },"260": {
    "doc": "Latches",
    "title": "Introduction",
    "content": "There is one drawback of SR Latch. That is the next state value can’t be predicted when both the inputs S &amp; R are one. So, you can overcome this difficulty by D Latch. It is also called as Data Latch. The circuit diagram of D Latch is shown in the following figure. This circuit has single input D and two outputs Q(t) &amp; Q(t)’. D Latch is obtained from SR Latch by placing an inverter between S amp;&amp; R inputs and connect D input to S. That means the combinations, having same values, of S &amp; R are eliminated. | If D = 0 → S = 0 &amp; R = 1, then next state Q(t + 1) will be equal to ‘0’ irrespective of present state, Q(t) values. This is corresponding to the second row of SR Latch state table. | If D = 1 → S = 1 &amp; R = 0, then next state Q(t + 1) will be equal to ‘1’ irrespective of present state, Q(t) values. This is corresponding to the third row of SR Latch state table. | . ",
    "url": "/docs/seq-ssi/latches.html#introduction-2",
    
    "relUrl": "/docs/seq-ssi/latches.html#introduction-2"
  },"261": {
    "doc": "Latches",
    "title": "State table",
    "content": "| D | Q(t + 1) | . | 0 | 0 | . | 1 | 1 | . Therefore, D Latch Hold the information that is available on data input, D. That means the output of D Latch is sensitive to the changes in the input, D as long as the enable is High. In this module, you implemented various Latches by providing the cross coupling between NOR gates. Similarly, you can implement these Latches using NAND gates. ",
    "url": "/docs/seq-ssi/latches.html#state-table-1",
    
    "relUrl": "/docs/seq-ssi/latches.html#state-table-1"
  },"262": {
    "doc": "Latches",
    "title": "JK latch",
    "content": " ",
    "url": "/docs/seq-ssi/latches.html#jk-latch",
    
    "relUrl": "/docs/seq-ssi/latches.html#jk-latch"
  },"263": {
    "doc": "Latches",
    "title": "Introduction",
    "content": "JK latch is similar to RS latch. This latch consists of 2 inputs J and K as shown in the below figure. The ambiguous state has been eliminated here: when the inputs of Jk latch are high, then output toggles. The output feedback to inputs is the only difference that can be seen here, which is not there in the RS latch. ",
    "url": "/docs/seq-ssi/latches.html#introduction-3",
    
    "relUrl": "/docs/seq-ssi/latches.html#introduction-3"
  },"264": {
    "doc": "Latches",
    "title": "State table",
    "content": "| J | K | Q(t+1) | . | 0 | 0 | Q(t) | . | 0 | 1 | 0 | . | 1 | 0 | 1 | . | 1 | 1 | Q(t)’ | . ",
    "url": "/docs/seq-ssi/latches.html#state-table-2",
    
    "relUrl": "/docs/seq-ssi/latches.html#state-table-2"
  },"265": {
    "doc": "Latches",
    "title": "T latch",
    "content": " ",
    "url": "/docs/seq-ssi/latches.html#t-latch",
    
    "relUrl": "/docs/seq-ssi/latches.html#t-latch"
  },"266": {
    "doc": "Latches",
    "title": "Introduction",
    "content": "T latch is formed when the inputs of the JK latch are shorted. When the input is high, then the output toggles. ",
    "url": "/docs/seq-ssi/latches.html#introduction-4",
    
    "relUrl": "/docs/seq-ssi/latches.html#introduction-4"
  },"267": {
    "doc": "Latches",
    "title": "State table",
    "content": "| T | Q(t) | Q(t+1) | . | 0 | 0 | 0 | . | 0 | 1 | 1 | . | 1 | 0 | 1 | . | 1 | 1 | 0 | . | The inputs of an SR latch includes ? . | 1 input &amp; 3 outputs | 4 inputs only | 3 inputs &amp; 1 output . | 2 inputs &amp; 2 outputs | . | . | From which latch does D latch is obtained ? . | JK latch | T latch . | SR latch | . | None of the above | . | JK latch is similar to ? . | T latch | D latch . | RS latch | . | None of the above | . | When the T latch output will toggle ? . | Input is low . | Input is high | . | Output is high | Output is low | . | . ",
    "url": "/docs/seq-ssi/latches.html#state-table-3",
    
    "relUrl": "/docs/seq-ssi/latches.html#state-table-3"
  },"268": {
    "doc": "Logic families",
    "title": "Logic families",
    "content": " ",
    "url": "/docs/comb-ssi/logic-families.html",
    
    "relUrl": "/docs/comb-ssi/logic-families.html"
  },"269": {
    "doc": "Logic families",
    "title": "Table of contents",
    "content": ". | Technologies behind logic integrated circuits | References | . ",
    "url": "/docs/comb-ssi/logic-families.html#table-of-contents",
    
    "relUrl": "/docs/comb-ssi/logic-families.html#table-of-contents"
  },"270": {
    "doc": "Logic families",
    "title": "Technologies behind logic integrated circuits",
    "content": "There are many technologies available to implement digital logic components which work according to the Boolean algebra’s laws and rules. The most common technologies are known as TTL and CMOS logic families, however many variations exist. Each technology presents unique features such as propagation time, power requirements, logic levels, heat dissipation among others. Also, its packaging requires careful consideration when implementing an actual circuit. A full description of logic families can be found in the following resources: . | Chapter 2 “Logic Gates” in [1] | Section 3.3 “Logic Families” in [2] | Chapter 8 “Practical digital circuits” in [3] | Chapter 5 “Integrated Logic” in [4] | . Also, logic component manufacturers also publishes information about their current logic families technologies. As an example, check [5]. ",
    "url": "/docs/comb-ssi/logic-families.html#technologies-behind-logic-integrated-circuits",
    
    "relUrl": "/docs/comb-ssi/logic-families.html#technologies-behind-logic-integrated-circuits"
  },"271": {
    "doc": "Logic families",
    "title": "References",
    "content": ". | [1]J. Morris, Digital Electronics. CRC Press, 2013 [Online]. Available at: https://books.google.cl/books?id=MkAI6lrRrm4C | [2]B. J. LaMeres, Introduction to Logic Circuits &amp; Logic Design with Verilog. Springer International Publishing, 2019 [Online]. Available at: https://books.google.cl/books?id=1OORDwAAQBAJ | [3]J. Stonham, Digital Logic Techniques. CRC Press, 2017 [Online]. Available at: https://books.google.cl/books?id=a-5HDwAAQBAJ | [4]M. Ferdjallah, Introduction to Digital Systems: Modeling, Synthesis, and Simulation Using VHDL. Wiley, 2011 [Online]. Available at: https://books.google.cl/books?id=kJRoR8AAu1AC | [5]“Logic Guide.” https://www.ti.com/lit/SDYU001, 2017. | . ",
    "url": "/docs/comb-ssi/logic-families.html#references",
    
    "relUrl": "/docs/comb-ssi/logic-families.html#references"
  },"272": {
    "doc": "Logic gates",
    "title": "Logic gates",
    "content": " ",
    "url": "/docs/comb-ssi/logic-gates.html",
    
    "relUrl": "/docs/comb-ssi/logic-gates.html"
  },"273": {
    "doc": "Logic gates",
    "title": "Table of contents",
    "content": ". | Introduction | Truth Table | NOT gate . | Verilog code for NOT gate | . | AND gate . | Verilog code for AND gate | . | OR gate . | Verilog code for OR gate | . | NAND gate . | Verilog code for NAND gate | . | NOR gate . | Verilog code for NOR gate | . | XOR gate . | Verilog code for XOR gate | . | XNOR gate . | Verilog code for XNOR gate | . | . ",
    "url": "/docs/comb-ssi/logic-gates.html#table-of-contents",
    
    "relUrl": "/docs/comb-ssi/logic-gates.html#table-of-contents"
  },"274": {
    "doc": "Logic gates",
    "title": "Introduction",
    "content": "Logic Gates are devices which perform logical operations on one or more inputs and produces a single output. Logic gates can be categorized into 3 groups: . | Basic Gates: NOT, AND, OR | Universal Gates: NAND, NOR | Arithmetic Gates: X-OR, X-NOR | . ",
    "url": "/docs/comb-ssi/logic-gates.html#introduction",
    
    "relUrl": "/docs/comb-ssi/logic-gates.html#introduction"
  },"275": {
    "doc": "Logic gates",
    "title": "Truth Table",
    "content": "The Table which contains all logical possibilities is known as truth table. ",
    "url": "/docs/comb-ssi/logic-gates.html#truth-table",
    
    "relUrl": "/docs/comb-ssi/logic-gates.html#truth-table"
  },"276": {
    "doc": "Logic gates",
    "title": "NOT gate",
    "content": "The NOT gate is also known as an inverter because it produces the exact opposite of the input as output. It has one input and one output. The Truth table for NOT gate is given below . | Input | Output | . | 0 | 1 | . | 1 | 0 | . Not Gate Verilog code for NOT gate . module not_gate( input a, output c ); assign c=~a; endmodule . ",
    "url": "/docs/comb-ssi/logic-gates.html#not-gate",
    
    "relUrl": "/docs/comb-ssi/logic-gates.html#not-gate"
  },"277": {
    "doc": "Logic gates",
    "title": "AND gate",
    "content": "The AND gate’s operation is similar to that of multiplication. It has two inputs and one output. The output is high (1) if both inputs are 1, and for all other cases, the output is low (0). The Truth table for AND gate which consists of two inputs is given below . | Input 1 | Input 2 | Output | . | 0 | 0 | 0 | . | 0 | 1 | 0 | . | 1 | 0 | 0 | . | 1 | 1 | 1 | . AND Gate Verilog code for AND gate . module and_gate( input a, input b, output c ); assign c=a &amp; b; endmodule . ",
    "url": "/docs/comb-ssi/logic-gates.html#and-gate",
    
    "relUrl": "/docs/comb-ssi/logic-gates.html#and-gate"
  },"278": {
    "doc": "Logic gates",
    "title": "OR gate",
    "content": "The OR gate has two inputs and one output. If at least one of the inputs is 1, then the output will be high (1). If neither of the inputs is 1, then the output will be low (0). The Truth table of OR gate which consists of two inputs is given below . | Input 1 | Input 2 | Output | . | 0 | 0 | 0 | . | 0 | 1 | 1 | . | 1 | 0 | 1 | . | 1 | 1 | 1 | . AND Gate Verilog code for OR gate . module or_gate( input a, input b, output c ); assign c=a | b; endmodule . ",
    "url": "/docs/comb-ssi/logic-gates.html#or-gate",
    
    "relUrl": "/docs/comb-ssi/logic-gates.html#or-gate"
  },"279": {
    "doc": "Logic gates",
    "title": "NAND gate",
    "content": "The NAND gate is the complement of the AND gate. You can think of it as an AND gate followed immediately by a NOT gate. Its output is low (0) when both the inputs are 1, and for all other cases, its output is high (1). The symbol of NAND gate consists of AND gate followed by a small circle. The Truth table of NAND gate which consists of two inputs is given below . | Input 1 | Input 2 | Output | . | 0 | 0 | 1 | . | 0 | 1 | 1 | . | 1 | 0 | 1 | . | 1 | 1 | 0 | . NAND Gate Verilog code for NAND gate . module nand_gate( input a, input b, output c ); assign c=~(a &amp; b); endmodule . ",
    "url": "/docs/comb-ssi/logic-gates.html#nand-gate",
    
    "relUrl": "/docs/comb-ssi/logic-gates.html#nand-gate"
  },"280": {
    "doc": "Logic gates",
    "title": "NOR gate",
    "content": "The NOR gate is the complement of the OR gate. You can think of it as an OR gate followed immediately by a NOT gate. Its output is low (0) when one or both of the inputs are 1, and for all other cases, its output is high (1). The symbol of NOR gate consists of OR gate followed by a small circle. The Truth table of NOR gate which consists of two inputs is given below . | Input 1 | Input 2 | Output | . | 0 | 0 | 1 | . | 0 | 1 | 0 | . | 1 | 0 | 0 | . | 1 | 1 | 0 | . NOR Gate Verilog code for NOR gate . module nor_gate( input a, input b, output c ); assign c=~(a | b); endmodule . ",
    "url": "/docs/comb-ssi/logic-gates.html#nor-gate",
    
    "relUrl": "/docs/comb-ssi/logic-gates.html#nor-gate"
  },"281": {
    "doc": "Logic gates",
    "title": "XOR gate",
    "content": "The XOR (or) Exclusive-OR is a digital Logic gate that gives the output as high (1) if and only if one of the input is 1. The Truth table of XOR gate which consists of two inputs is given below . | Input 1 | Input 2 | Output | . | 0 | 0 | 0 | . | 0 | 1 | 1 | . | 1 | 0 | 1 | . | 1 | 1 | 0 | . XOR Gate Verilog code for XOR gate . module xor_gate( input a, input b, output c ); assign c=a ^ b; endmodule . ",
    "url": "/docs/comb-ssi/logic-gates.html#xor-gate",
    
    "relUrl": "/docs/comb-ssi/logic-gates.html#xor-gate"
  },"282": {
    "doc": "Logic gates",
    "title": "XNOR gate",
    "content": "The XNOR (or) Exclusive-NOR is a digital Logic gate that gives the output as high (1) when both the inputs are same. The Truth table of XNOR gate which consists of two inputs is given below . | Input 1 | Input 2 | Output | . | 0 | 0 | 1 | . | 0 | 1 | 0 | . | 1 | 0 | 0 | . | 1 | 1 | 1 | . XNOR Gate Verilog code for XNOR gate . module xnor_gate( input a, input b, output c ); assign c=~(a ^ b); endmodule . You can also click/tap a symbol to copy it and then click/tap to paste it into the box. ",
    "url": "/docs/comb-ssi/logic-gates.html#xnor-gate",
    
    "relUrl": "/docs/comb-ssi/logic-gates.html#xnor-gate"
  },"283": {
    "doc": "Logic gates",
    "title": "Two-Way Light Switch",
    "content": "In your house you probabably have a light with more than one switch - e.g. landing lights often have switches upstairs and downstairs. Add the correct logic gate to the circuit and see if you can get this light work to work in the same way. You can click on Upstairs and Downstairs switches to change them. Upstairs Downstairs ",
    "url": "/docs/comb-ssi/logic-gates.html",
    
    "relUrl": "/docs/comb-ssi/logic-gates.html"
  },"284": {
    "doc": "Logic gates",
    "title": "Security Light",
    "content": "You can buy security lights that come on only when it's dark and they sense some movement. Add the correct logic gate to the circuit and see if you can get it to work (you can click on Darkness and Movement to change them). Darkness Movement Unfortunately your screen is too small to display this page correctly. If you are using a tablet or phone you could try turning it round to landscape orientation. ",
    "url": "/docs/comb-ssi/logic-gates.html",
    
    "relUrl": "/docs/comb-ssi/logic-gates.html"
  },"285": {
    "doc": "MDS Diagrams",
    "title": "Mnemonic Documented State Diagrams",
    "content": " ",
    "url": "/docs/seq-design/mds.html#mnemonic-documented-state-diagrams",
    
    "relUrl": "/docs/seq-design/mds.html#mnemonic-documented-state-diagrams"
  },"286": {
    "doc": "MDS Diagrams",
    "title": "Table of contents",
    "content": ". | Introduction | Large scale digital system design | . ",
    "url": "/docs/seq-design/mds.html#table-of-contents",
    
    "relUrl": "/docs/seq-design/mds.html#table-of-contents"
  },"287": {
    "doc": "MDS Diagrams",
    "title": "Introduction",
    "content": "For very complex systems the state diagram might not be well suited. In this case a tool called the Mnemonic Documented State Diagram or MDS Diagram can incorporate in a more compact way all the complexities of a large system controller. More information about MDS diagrams can be found in the book An Engineering Approach to Digital Design by William I. Fletcher. ",
    "url": "/docs/seq-design/mds.html#introduction",
    
    "relUrl": "/docs/seq-design/mds.html#introduction"
  },"288": {
    "doc": "MDS Diagrams",
    "title": "Large scale digital system design",
    "content": "For complex digital logic system with a large number of inputs, the following design methodology, from the point of view of a system controller, can be used: . | State main definitions and specifications of the problem/system | Define basic operations, limits and restrictions. | Draw a basic (simplified) block diagram | Draw a simplified (general) flowchart diagram | . | Define the system timing requirement . | Draw a general time diagram | . | Detail the controller’s sequential behaviour . | Draw detailed time diagram | Draw detailed flowchart diagram | Draw detailed block diagram | . | Draw MDS diagram | Choose the controller architecture: SSI (logic gates and flip-flops), MSI (based on MUXs, …) or LSI (ROM based, …) | Asign state codes | Implement the circuit based on the design | . ",
    "url": "/docs/seq-design/mds.html#large-scale-digital-system-design",
    
    "relUrl": "/docs/seq-design/mds.html#large-scale-digital-system-design"
  },"289": {
    "doc": "MDS Diagrams",
    "title": "MDS Diagrams",
    "content": " ",
    "url": "/docs/seq-design/mds.html",
    
    "relUrl": "/docs/seq-design/mds.html"
  },"290": {
    "doc": "Map-entered variables",
    "title": "Map-entered variables",
    "content": " ",
    "url": "/docs/logic-design/mev.html",
    
    "relUrl": "/docs/logic-design/mev.html"
  },"291": {
    "doc": "Map-entered variables",
    "title": "Table of contents",
    "content": ". | Introduction | MEV and MUXs | Minimization method . | Phase 1: Coverage | Phase 2: Transformation | . | . ",
    "url": "/docs/logic-design/mev.html#table-of-contents",
    
    "relUrl": "/docs/logic-design/mev.html#table-of-contents"
  },"292": {
    "doc": "Map-entered variables",
    "title": "Introduction",
    "content": "Maps with entered variables are Karnaugh Maps which can have Boolean expression in its cells, not just ones and zeros. These maps are also referred to as Variable-Entered Maps. However, in most literature the MEV acronym is used. These maps are useful to represent functions with large number of variables in a map of lower order. They are also used to describe flip-flop’s excitation functions. For instance, given the three-variables Boolean function $f(x,y,z)$ described by the following truth-table: . | : Table 1: Simple MEV example {: .tblcap} :|||| |   |   |   |   | . | $x$ | $y$ | $z$ | $f(x,y,z)$ | MEV | . | 0 | 0 | 0 | 0 | $z$ | . | 0 | 0 | 1 | 1 | ^^ | . | 0 | 1 | 0 | 1 | $\\overline{z}$ | . | 0 | 1 | 1 | 0 | ^^ | . | 1 | 0 | 0 | 0 | $z$ | . | 1 | 0 | 1 | 1 | ^^ | . | 1 | 1 | 0 | 0 | 0 | . | 1 | 1 | 1 | 0 | ^^ | . The column labelled MEV shows the Boolean relation between $f(x,y,z)$ and $z$ for each of the four possible combinations of $(x,y)$. This function is represented by the map: . | : Table 2: MEV for function defined by Table 1 :|| |   |   | . |   | $\\boldsymbol{y}$ | |   | . | $\\boldsymbol{x}$ | 0 | 1 | . | **0** | $z$ | $\\overline{z}$ | . | **1** | $z$ | 0 | . The MEV can be optimized directly, just like a Karnaugh Map but the process is more complex. ",
    "url": "/docs/logic-design/mev.html#introduction",
    
    "relUrl": "/docs/logic-design/mev.html#introduction"
  },"293": {
    "doc": "Map-entered variables",
    "title": "MEV and MUXs",
    "content": "A MEV can be directly implemented in a MUX, where the function of each cell must be connected to the corresponding data line of the MUX, while the map’s variables are connected to the selection lines. For instance, the example from Table 2 is implemented in the interactive circuit below: . ",
    "url": "/docs/logic-design/mev.html#mev-and-muxs",
    
    "relUrl": "/docs/logic-design/mev.html#mev-and-muxs"
  },"294": {
    "doc": "Map-entered variables",
    "title": "Minimization method",
    "content": "A method of MEV minimization based on partial variables is described in: . | Section “Variable-Entered Maps” in [1] | Section “Minimizing MEV maps” in [2] | Section “Map-entered variables” in [3] | . Another recursive method which can be used when the MEV only has expessions of one variable (or its complement) is described next. The expressions found in the map’s cells can have these forms: . | 0s or 1s | $z$ or $\\overline{z}$ | $\\phi$ (don’t care) | $z\\phi$ or $\\overline{z}\\phi$ | $z+\\overline{z}\\phi$ or $\\overline{z}+z\\phi$ | . The process has two phases . Phase 1: Coverage . Let $D$ and $\\overline{D}$ (its complement) be the MEV variable, then ones correspond to $1\\rightarrow D+\\overline{D}$. In this phase, the goal is to obtain the largest grouping or coverage for both the variable and its complement, independently. | Start by covering the variables alone. | Expand the coverage to identical adjacent variables. | Expand the coverage by incorporating ones (1s). | Expand the coverage by incorporating cells containing don’t cares. | Repeat from step 2 to extend the coverage as much as possible | . The Boolean product expressions of the groups will be part of the final sum. Phase 2: Transformation . The goal of this phase is to discard the MEV variables, since they have already been covered in Phase 1: . | MEV variables $D$ and $\\overline{D}$ are replaced by 0. | Cells with 0s and $\\phi$ remain the same. | Cells with 1s become $\\phi$ if both parts $D$ and $\\overline{D}$ were covered. Otherwise they remain as 1s | Cells containing $z\\phi$ or $\\overline{z}\\phi$ become 0s. | Cells with the expressions $z+\\overline{z}\\phi$ and $\\overline{z}+z\\phi$ become $\\phi$ if the term not multiplied by $\\phi$ has been covered. Otherwise they become 1s. | . The new map is a normal Karnaugh Map with 1s and 0s, and can be minimised accordingly. The new product terms are added to those found in Phase 1. ",
    "url": "/docs/logic-design/mev.html#minimization-method",
    
    "relUrl": "/docs/logic-design/mev.html#minimization-method"
  },"295": {
    "doc": "Microprocessors",
    "title": "Microprocessors",
    "content": " ",
    "url": "/docs/seq-lsi/microprocessors.html",
    
    "relUrl": "/docs/seq-lsi/microprocessors.html"
  },"296": {
    "doc": "Microprocessors",
    "title": "Table of contents",
    "content": ". | Introduction | . ",
    "url": "/docs/seq-lsi/microprocessors.html#table-of-contents",
    
    "relUrl": "/docs/seq-lsi/microprocessors.html#table-of-contents"
  },"297": {
    "doc": "Microprocessors",
    "title": "Introduction",
    "content": "Microprocessors are general purpose rom-based sequential circuits with a fixed architecture. This means the digital logic hardware has previously been designed and optimised. Usually a generic FSM has already been implemented in the ROM. The circuit is designed to control an Arithmetic-Logic Unit (ALU) for data processing and to access external memories where data and software is stored. The internal FSM executes sequences of instructions as indicated by the software in the program memory. The particular FSM that the user wants to implement in the circuit is programmed in the software. Other combinational and sequential components, such as MUXs, registers and counters are also part of the microprocessor to provide the functionality required by the software, to optimise its execution and to connect to other external components. One of the first “single-chip” microprocessors is the Intel 4004. Read more about it and other interesting microprocessors and their history in the IEEE Chip Hall of Fame and the website Great Microprocessors of the Past and Present at the CPUSHACK museum. | Which of the following is single-clip microprocessors ? . | Intel 4004 . | Intel 4408 | Intel 2004 | Intel 4002 | . | . | Which of the following is/are benefits of microprocessor ? . | All of mentioned . | Inexpensive | Portable | Versatile | . | . | Microprocessor fetches ______ instructions from the memory to decode and execute. | Sequential . | Pipeline | Combinational | Arithmetic | . | . | . ",
    "url": "/docs/seq-lsi/microprocessors.html#introduction",
    
    "relUrl": "/docs/seq-lsi/microprocessors.html#introduction"
  },"298": {
    "doc": "MSI based design",
    "title": "MSI based design",
    "content": " ",
    "url": "/docs/seq-msi/msi-seq-design.html",
    
    "relUrl": "/docs/seq-msi/msi-seq-design.html"
  },"299": {
    "doc": "MSI based design",
    "title": "Table of contents",
    "content": ". | Introduction | Mux based design . | Previous states for the same input word | No previous state for a given input word | Output bit set by multiple states | . | . ",
    "url": "/docs/seq-msi/msi-seq-design.html#table-of-contents",
    
    "relUrl": "/docs/seq-msi/msi-seq-design.html#table-of-contents"
  },"300": {
    "doc": "MSI based design",
    "title": "Introduction",
    "content": "It is possible, specially for large systems, to use Medium Scale Integration components (counters, MUXs, DeMUXs, etc.) to design sequential systems . For systems with a large number of inputs, the state diagram looses its purpose and there is no standard method to design with a greater scale of integration. The main idea is to use fixed architectures as building blocks and adapt the problem to these architectures. ",
    "url": "/docs/seq-msi/msi-seq-design.html#introduction",
    
    "relUrl": "/docs/seq-msi/msi-seq-design.html#introduction"
  },"301": {
    "doc": "MSI based design",
    "title": "Mux based design",
    "content": "In this architecture, each state is represented by the output of a MUX. A memory element (D type flip-flop) is added to the MUX output. The basic building block of this architecture is depicted in Fig. 1. Fig. 1: MUX + D flip-flop building block. The selection lines $x_1,\\ldots,x_n$ are connected to the system’s inputs. The multiplexed inputs $C_0,\\ldots,C_{2^n-1}$ are connected to the previous states (MUXs), and the output $F$ is connected to the next states (MUXs). During operation there will be only one MUX with its output activated, the one representing the current state. When an input combination triggers the transition to the next state the output of the MUX representing that next state will become active and the previously active MUX output will deactivate. For simplicity, we will consider a Moore FSM, however the system can be also configured for Mealy state machines adding the input conditions to the output decoder. The following transition cases can be combined to form any Finite State Machine: . | Multiple previous states transitioning to a common next state for the same input word. | No previous state for input combination $k$. | Output bit associated to multiple states (Moore style machine). | . The following are examples for each of these cases. Previous states for the same input word . States B and C will transit to next state A if the input $x=I_j$. Previous states for the same input word. No previous state for a given input word . State D has no previous state for input combination $x=I_k$. No previous state for a given input word. Output bit set by multiple states . If output function $z$ is active for states A, B or C, then the output decoder is simply: . Output associated to multiple states. ",
    "url": "/docs/seq-msi/msi-seq-design.html#mux-based-design",
    
    "relUrl": "/docs/seq-msi/msi-seq-design.html#mux-based-design"
  },"302": {
    "doc": "Multipliers/Dividers",
    "title": "Multipliers and Dividers",
    "content": " ",
    "url": "/docs/seq-msi/mult-div.html#multipliers-and-dividers",
    
    "relUrl": "/docs/seq-msi/mult-div.html#multipliers-and-dividers"
  },"303": {
    "doc": "Multipliers/Dividers",
    "title": "Table of contents",
    "content": ". | Binary multiplier | Binary divider | . ",
    "url": "/docs/seq-msi/mult-div.html#table-of-contents",
    
    "relUrl": "/docs/seq-msi/mult-div.html#table-of-contents"
  },"304": {
    "doc": "Multipliers/Dividers",
    "title": "Binary multiplier",
    "content": "A simple circuit to multiply 2 binary numbers (3-bits each) can be tested below: . ",
    "url": "/docs/seq-msi/mult-div.html#binary-multiplier",
    
    "relUrl": "/docs/seq-msi/mult-div.html#binary-multiplier"
  },"305": {
    "doc": "Multipliers/Dividers",
    "title": "Binary divider",
    "content": "Likewise, a binary divider interactive circuit is presented next: . ",
    "url": "/docs/seq-msi/mult-div.html#binary-divider",
    
    "relUrl": "/docs/seq-msi/mult-div.html#binary-divider"
  },"306": {
    "doc": "Multipliers/Dividers",
    "title": "Multipliers/Dividers",
    "content": " ",
    "url": "/docs/seq-msi/mult-div.html",
    
    "relUrl": "/docs/seq-msi/mult-div.html"
  },"307": {
    "doc": "Multiplication",
    "title": "Binary multiplication",
    "content": " ",
    "url": "/docs/binary-algebra/multiplication.html#binary-multiplication",
    
    "relUrl": "/docs/binary-algebra/multiplication.html#binary-multiplication"
  },"308": {
    "doc": "Multiplication",
    "title": "Table of contents",
    "content": ". | Multiplication | . ",
    "url": "/docs/binary-algebra/multiplication.html#table-of-contents",
    
    "relUrl": "/docs/binary-algebra/multiplication.html#table-of-contents"
  },"309": {
    "doc": "Multiplication",
    "title": "Multiplication",
    "content": "Binary multiplication requires two concepts i.e., binary addition and decimal multiplication. You can refer to the example below which describes how multiplication occurs in binary. It is similar to decimal multiplication. Important points to be noted are as follows : . 1 x 1 = 1 . 1 x 0 = 0 . 1 1 0 (6) x 1 0 1 (5) ------------ 1 1 0 0 0 0 x 1 1 0 x x -------------- 1 1 1 1 0 (30) -------------- . | Perform multiplication of the binary numbers: 01001×01011= ? . | 010000010 . | 010110010 | 010100010 | 010010010 | . | . | Perform multiplication of the binary numbers: 001101×1111= ? . | 011000011 . | 011001111 | 010011001 | 011010101 | . | . | . ",
    "url": "/docs/binary-algebra/multiplication.html",
    
    "relUrl": "/docs/binary-algebra/multiplication.html"
  },"310": {
    "doc": "MUX/DEMUX",
    "title": "Multiplexers and Demultiplexers",
    "content": " ",
    "url": "/docs/comb-msi/mux-demux.html#multiplexers-and-demultiplexers",
    
    "relUrl": "/docs/comb-msi/mux-demux.html#multiplexers-and-demultiplexers"
  },"311": {
    "doc": "MUX/DEMUX",
    "title": "Table of contents",
    "content": ". | Multiplexers | Introduction | Block diagram | Multiplexers come in multiple variations . | 2 : 1 multiplexer | 4 : 1 multiplexer | 8 : 1 multiplexer | 16 : 1 multiplexer | . | Applications of Multiplexers | Demultiplexers | Introduction | Demultiplexers in multiple variations. | 1 : 2 demultiplexer . | Block diagram | Truth table | . | 1 : 4 demultiplexer | 1 : 8 demultiplexer | 1 : 16 demultiplexer | . | Applications of Demultiplexers | . ",
    "url": "/docs/comb-msi/mux-demux.html#table-of-contents",
    
    "relUrl": "/docs/comb-msi/mux-demux.html#table-of-contents"
  },"312": {
    "doc": "MUX/DEMUX",
    "title": "Multiplexers",
    "content": " ",
    "url": "/docs/comb-msi/mux-demux.html#multiplexers",
    
    "relUrl": "/docs/comb-msi/mux-demux.html#multiplexers"
  },"313": {
    "doc": "MUX/DEMUX",
    "title": "Introduction",
    "content": "Multiplexer is a special type of combinational circuit. There are n-data inputs, one output and m select inputs with 2m = n. It is a digital circuit which selects one of the n data inputs and routes it to the output. The selection of one of the n inputs is done by the selected inputs. Depending on the digital code applied at the selected inputs, one out of n data sources is selected and transmitted to the single output Y. E is called the strobe or enable input which is useful for the cascading. It is generally an active low terminal that means it will perform the required operation when it is low. ",
    "url": "/docs/comb-msi/mux-demux.html#introduction",
    
    "relUrl": "/docs/comb-msi/mux-demux.html#introduction"
  },"314": {
    "doc": "MUX/DEMUX",
    "title": "Block diagram",
    "content": "n : 1 Multiplexer ",
    "url": "/docs/comb-msi/mux-demux.html#block-diagram",
    
    "relUrl": "/docs/comb-msi/mux-demux.html#block-diagram"
  },"315": {
    "doc": "MUX/DEMUX",
    "title": "Multiplexers come in multiple variations",
    "content": "2 : 1 multiplexer . Truth Table . Enable(E) = 1 . | S1 | Y(Output) | . | 0 | T1 | . | 1 | T2 | . 4 : 1 multiplexer . The 4 : 1 multiplexer has 4 inputs and 2 control signals. Truth Table . Enable(E) = 1 . | S1 | S2 | Y(Output) | . | 0 | 0 | T1 | . | 0 | 1 | T2 | . | 1 | 0 | T3 | . | 1 | 1 | T4 | . 8 : 1 multiplexer . The 8 : 1 multiplexer has 8 inputs and 3 control signals. Truth Table . Enable(E) = 1 . | S1 | S2 | S3 | Y(Output) | . | 0 | 0 | 1 | T1 | . | 0 | 1 | 0 | T2 | . | 0 | 1 | 1 | T3 | . | 0 | 1 | 1 | T4 | . | 1 | 0 | 1 | T5 | . | 1 | 1 | 0 | T6 | . | 1 | 1 | 1 | T7 | . | 1 | 1 | 1 | T8 | . You can implement a 8 : 1 multiplexer by chaining two 4 : 1 multiplexers, like this: . 16 : 1 multiplexer . The 16 : 1 multiplexer has 16 inputs and 4 control signals. It can be implemented with two 8 : 1 multiplexers: . Truth Table . Enable(E) = 1 . | A | B | C | D | Y(Output) | . | 0 | 0 | 0 | 0 | T1 | . | 0 | 0 | 0 | 1 | T2 | . | 0 | 0 | 1 | 0 | T3 | . | 0 | 0 | 1 | 1 | T4 | . | 0 | 1 | 0 | 0 | T5 | . | 0 | 1 | 0 | 1 | T6 | . | 0 | 1 | 1 | 0 | T7 | . | 0 | 1 | 1 | 1 | T8 | . | 1 | 0 | 0 | 0 | T9 | . | 1 | 0 | 0 | 1 | T10 | . | 1 | 0 | 1 | 0 | T11 | . | 1 | 0 | 1 | 1 | T12 | . | 1 | 1 | 0 | 0 | T13 | . | 1 | 1 | 0 | 1 | T14 | . | 1 | 1 | 1 | 0 | T15 | . | 1 | 1 | 1 | 1 | T16 | . It can also be implemented with five 4 : 1 multiplexers: . ",
    "url": "/docs/comb-msi/mux-demux.html#multiplexers-come-in-multiple-variations",
    
    "relUrl": "/docs/comb-msi/mux-demux.html#multiplexers-come-in-multiple-variations"
  },"316": {
    "doc": "MUX/DEMUX",
    "title": "Applications of Multiplexers",
    "content": ". | Transmission from the Computer System of a Satellite - Multiplexer is used to transmit the data signals from the computer system of a spacecraft or a satellite to the ground system by using a GSM satellite. | Computer Memory - Multiplexers are used in computer memory to maintain a huge amount of memory in the computers, and also to reduce the number of copper lines required to connect the memory to other parts of the computer. | Telephone Network - In telephone networks, multiple audio signals are integrated on a single line of transmission with the help of a multiplexer. | . ",
    "url": "/docs/comb-msi/mux-demux.html#applications-of-multiplexers",
    
    "relUrl": "/docs/comb-msi/mux-demux.html#applications-of-multiplexers"
  },"317": {
    "doc": "MUX/DEMUX",
    "title": "Demultiplexers",
    "content": " ",
    "url": "/docs/comb-msi/mux-demux.html#demultiplexers",
    
    "relUrl": "/docs/comb-msi/mux-demux.html#demultiplexers"
  },"318": {
    "doc": "MUX/DEMUX",
    "title": "Introduction",
    "content": "A demultiplexer performs the reverse operation of a multiplexer i.e. it receives one input and distributes it over several outputs. It has only one input, n outputs, m select input. At a time only one output line is selected by the select lines and the input is transmitted to the selected output line. A de-multiplexer is equivalent to a single pole multiple way switch as shown in fig. ",
    "url": "/docs/comb-msi/mux-demux.html#introduction-1",
    
    "relUrl": "/docs/comb-msi/mux-demux.html#introduction-1"
  },"319": {
    "doc": "MUX/DEMUX",
    "title": "Demultiplexers in multiple variations.",
    "content": "1 : 2 demultiplexer . Block diagram . 1:2 Demultiplexer Truth table . 1:2 Demultiplexer Truth Table 1 : 4 demultiplexer . 1 : 8 demultiplexer . 1 : 16 demultiplexer . A 1 : 16 demultiplexer can be implemented using two 1 : 8 demultiplexers. ",
    "url": "/docs/comb-msi/mux-demux.html#demultiplexers-in-multiple-variations",
    
    "relUrl": "/docs/comb-msi/mux-demux.html#demultiplexers-in-multiple-variations"
  },"320": {
    "doc": "MUX/DEMUX",
    "title": "Applications of Demultiplexers",
    "content": ". | Arithmetic Logic Unit - The output of the ALU is fed as an input to the De-multiplexer, and the output of the demultiplexer is connected to a multiple register. The output of the ALU can be stored in multiple registers. | Serial to Parallel Converter - In this technique, serial data is given as an input to the De-multiplexer at a regular interval, and a counter is attached to the demultiplexer at the control input to detect the data signal at the output of the demultiplexer. When all data signals are stored, the output of the demux can be read out in parallel. | . | Which of the following directs data from input to a selected output line ? . | Demultiplexer . | Multiplexer | Coder | Both MUX &amp; DEMUX | . | . | Which of the following logic block has a number of input lines and one signle output line ? . | Decoder . | Multiplexer | . | Demultiplexer | Encoder | . | How many selection line will be there if a multiplexer has 8 input lines ? . | 1 | 2 . | 3 | . | 4 | . | How many output lines will be there in a demultiplexer if it has 3 selection lines ? . | 1 . | 2 | 3 | 4 | . | . | . ",
    "url": "/docs/comb-msi/mux-demux.html#applications-of-demultiplexers",
    
    "relUrl": "/docs/comb-msi/mux-demux.html#applications-of-demultiplexers"
  },"321": {
    "doc": "MUX/DEMUX",
    "title": "MUX/DEMUX",
    "content": " ",
    "url": "/docs/comb-msi/mux-demux.html",
    
    "relUrl": "/docs/comb-msi/mux-demux.html"
  },"322": {
    "doc": "MUX-based functions",
    "title": "MUX-based functions",
    "content": " ",
    "url": "/docs/comb-msi/mux-functions.html",
    
    "relUrl": "/docs/comb-msi/mux-functions.html"
  },"323": {
    "doc": "MUX-based functions",
    "title": "Table of contents",
    "content": ". | Mathematical formulation of the Multiplexer | Shannon theorem with MUX | Interactive MUX based logic gates | References | . ",
    "url": "/docs/comb-msi/mux-functions.html#table-of-contents",
    
    "relUrl": "/docs/comb-msi/mux-functions.html#table-of-contents"
  },"324": {
    "doc": "MUX-based functions",
    "title": "Mathematical formulation of the Multiplexer",
    "content": "An MUX of order $p$, $M(p)$ is formulated as: . $ \\begin{equation}F(\\underbrace{x_1,\\ldots,x_p}_{\\text{inputs}}, \\underbrace{y_0,\\ldots,y_k}_{\\text{control}})= \\sum_{i=0}^{2^p-1}\\underbrace{\\left(\\dot{x_1}\\dot{x_2}\\cdots\\dot{x_p}\\right)_i}_{i^{th}\\text{ Miniterm of }F}\\cdot y_i \\end{equation}$ . where $k=2^p-1$ and $\\dot{x_j} \\in \\{x_j, \\overline{x_j}\\}$ . More examples can be found in [1] (Section on Data Selectors). ",
    "url": "/docs/comb-msi/mux-functions.html#mathematical-formulation-of-the-multiplexer",
    
    "relUrl": "/docs/comb-msi/mux-functions.html#mathematical-formulation-of-the-multiplexer"
  },"325": {
    "doc": "MUX-based functions",
    "title": "Shannon theorem with MUX",
    "content": "Shannon decomposition theorem can also be implemented using MUXs: . $ f(x_1,x_2,x_3,\\ldots, x_n) = x_1 \\cdot f_1(1,x_2,x_3,\\ldots,x_n) + \\overline{x_1} \\cdot f_0(0,x_2,x_3,\\ldots,x_n) $ . MUX based implementation of Shannon decomposition theorem. See [2] for a more general description. ",
    "url": "/docs/comb-msi/mux-functions.html#shannon-theorem-with-mux",
    
    "relUrl": "/docs/comb-msi/mux-functions.html#shannon-theorem-with-mux"
  },"326": {
    "doc": "MUX-based functions",
    "title": "Interactive MUX based logic gates",
    "content": "The set $\\{M(1),0,1\\}$ is functionally complete (See section Functionally Complete *Operation Sets in [3] or Wikipedia:Functional completeness). Therefore, any logic function can be implemented using multiplexers, check the interactive circuit below, which implements the basic logic gates using MUXs: . | MUX-based AND gate | MUX-based OR gate | MUX-based NAND gate | MUX-based NOR gate | MUX-based NOT gate | . ",
    "url": "/docs/comb-msi/mux-functions.html#interactive-mux-based-logic-gates",
    
    "relUrl": "/docs/comb-msi/mux-functions.html#interactive-mux-based-logic-gates"
  },"327": {
    "doc": "MUX-based functions",
    "title": "References",
    "content": ". | [1]Z. Kohavi and N. K. Jha, Switching and Finite Automata Theory. Cambridge University Press, 2010 [Online]. Available at: https://books.google.cl/books?id=jZIxam8Rb9AC | [2]Cerny, Mange, and Sanchez, “Synthesis of Minimal Binary Decision Trees,” IEEE Transactions on Computers, vol. C-28, no. 7, pp. 472–482, 1979, doi: 10.1109/TC.1979.1675391. | [3]B. J. LaMeres, Introduction to Logic Circuits &amp; Logic Design with Verilog. Springer International Publishing, 2019 [Online]. Available at: https://books.google.cl/books?id=1OORDwAAQBAJ | . | Can one MUX block be said an universal logic block ? . | Yes . | No | . | . | Can one DEMUX block be said an universal logic block ? . | Yes . | No | . | . | Select the MUX-based gates which is/are possible ? . | MUX-based XOR gate | MUX-based XNOR gate . | XOR and XNOR both gates | . | . | . ",
    "url": "/docs/comb-msi/mux-functions.html#references",
    
    "relUrl": "/docs/comb-msi/mux-functions.html#references"
  },"328": {
    "doc": "Negative quantities",
    "title": "Negative quantities",
    "content": " ",
    "url": "/docs/binary-representation/negative-quantities.html",
    
    "relUrl": "/docs/binary-representation/negative-quantities.html"
  },"329": {
    "doc": "Negative quantities",
    "title": "Table of contents",
    "content": ". | Signed and unsigned numbers | Complements in binary system . | 1’s complement | 2’s complement | . | . ",
    "url": "/docs/binary-representation/negative-quantities.html#table-of-contents",
    
    "relUrl": "/docs/binary-representation/negative-quantities.html#table-of-contents"
  },"330": {
    "doc": "Negative quantities",
    "title": "Signed and unsigned numbers",
    "content": "Currently, we have just looked at unsigned numbers - they can only be positive, as there is no sign. However, sometimes we need to work with negative numbers too. To do this, we add a sign bit on the far left of the binary number, which indicates whether the number is positive (0) or negative(1). For example, the number 10000011 would be 131 if the number is unsigned, but if the number is signed, the actual representation would be -3 . | The first bit 1 represents that the number is negative | The remaining bits 0000011 represent the actual number, 3 | . The downside to using a signed number is that it removes one bit from the actual number representation, halving the maximum value. | The minimum and maximum values for an unsigned 8-bit number would be 0 to 28-1 (0 to 255) | The minimum and maximum values for a signed 8-bit number would be -27-1 to 27-1 (-127 to 127) | . ",
    "url": "/docs/binary-representation/negative-quantities.html#signed-and-unsigned-numbers",
    
    "relUrl": "/docs/binary-representation/negative-quantities.html#signed-and-unsigned-numbers"
  },"331": {
    "doc": "Negative quantities",
    "title": "Complements in binary system",
    "content": "The Binary system has a base of r = 2. The base has r = 2 so the Binary system two types of complements. They are: . | 1’s complement | 2’s complement. | . 1’s complement . To find the 1’s complement of a given number, you should change all the 0’s to 1’s and then all the 1’s to 0’s. This process is called as 1’s complement. Simply negate each digit present in the binary number. An Example for 1’s complement is as follows: . Given number 1 0 1 0 1 1's complement 0 1 0 1 0 . 2’s complement . In order to find 2’s complement firstly, evaluate 1’s complement of the number, and further add 1 to it. 2’s complement = 1’s complement + 1. An Example of 2’s complement is as follows: . Given number 1 0 1 0 1 1's complement 0 1 0 1 0 add 1 + 1 --------------- 2's complement 0 1 0 1 1 --------------- . | Using signed two’s complement notation, what is the decimal value of 00010001 ? . | -47 | +37 | -149 . | +17 | . | . | The greatest negative number which can be stored in a 8-bit register using 2’s complement arithemtic is ? . | -256 | -255 . | -128 | . | -127 | . | The two’s complement of the signed decimal number -78 is ? . | 11001110 | 01001110 . | 10110010 | . | 10110001 | . | The range of positive numbers possible in an eight-bit two’s complement system is ? . | 0 to 64 . | 0 to 127 | . | 0 to 256 | 0 to 100. | . | . ",
    "url": "/docs/binary-representation/negative-quantities.html#complements-in-binary-system",
    
    "relUrl": "/docs/binary-representation/negative-quantities.html#complements-in-binary-system"
  },"332": {
    "doc": "Number bases",
    "title": "Other number bases",
    "content": " ",
    "url": "/docs/binary-representation/number-bases.html#other-number-bases",
    
    "relUrl": "/docs/binary-representation/number-bases.html#other-number-bases"
  },"333": {
    "doc": "Number bases",
    "title": "Table of contents",
    "content": ". | Introduction | Octal Number System | Hexadecimal Number System | Converting between bases . | Octal to Decimal conversion | Decimal to Octal conversion | Hexadecimal to Decimal conversion | Decimal to Hexadecimal conversion | . | . ",
    "url": "/docs/binary-representation/number-bases.html#table-of-contents",
    
    "relUrl": "/docs/binary-representation/number-bases.html#table-of-contents"
  },"334": {
    "doc": "Number bases",
    "title": "Introduction",
    "content": ". | Before, learning about other number bases let first understand what is Number Systems. It is a writing system used for expressing numbers. We can express number in various ways, but most commonly used systems are Binary Number System, Decimal Number System, Octal Number System and Hexadecimal Number System. | Now let’s have brief information about Number Bases. A number Base represents how many number of different digits or combination of digits and alphabets are used to represent a number in a particular Number System. | Positional number systems uses the position of a digit to know the contribution of that particular digit in the number. I guess it might look little difficult to understand, so let’s discuss it using an example of a most popular Positional Number System called as Decimal System. | . According to Decimal System 123 can be represented as 1*100 + 2*10 + 3*1. It shows that as 1 is on hundredth place so its contribution in the number will be 1*100=100 and so on. ",
    "url": "/docs/binary-representation/number-bases.html#introduction",
    
    "relUrl": "/docs/binary-representation/number-bases.html#introduction"
  },"335": {
    "doc": "Number bases",
    "title": "Octal Number System",
    "content": "Octal Number System has 8 as the base of the number. It uses digits from 0-7 . ",
    "url": "/docs/binary-representation/number-bases.html#octal-number-system",
    
    "relUrl": "/docs/binary-representation/number-bases.html#octal-number-system"
  },"336": {
    "doc": "Number bases",
    "title": "Hexadecimal Number System",
    "content": "Hexadecimal Number System has 16 as the base of the number. It uses digits 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E and F . ",
    "url": "/docs/binary-representation/number-bases.html#hexadecimal-number-system",
    
    "relUrl": "/docs/binary-representation/number-bases.html#hexadecimal-number-system"
  },"337": {
    "doc": "Number bases",
    "title": "Converting between bases",
    "content": "Octal to Decimal conversion . | STEP 1: Write the decimal value of each digit on top of them respectively. The value which you seek to write is 8(place value from right) beginning from 0 i.e., 80, 81, 88 …. continuing up to 87. | STEP 2: Now, multiply each digit of octal number with its value. | STEP 3: Add ‘em all. | STEP 4: Result is ready :) | . Decimal to Octal conversion . | STEP 1: Divide the decimal number by 8 | STEP 2: At each step store the value of remainder in reverse order. | STEP 3: Result is ready :) | . Hexadecimal to Decimal conversion . | STEP 1: Write the decimal value of each digit on top of them respectively. The value which you seek to write is 16(place value from right) beginning from 0 i.e., 160, 161, 168 …. continuing up to 167. | STEP 2: Now, multiply each digit of octal number with its value. | STEP 3: Add ‘em all. | STEP 4: Result is ready :) | . Decimal to Hexadecimal conversion . | STEP 1: Divide the decimal number by 16 | STEP 2: At each step store the value of remainder in reverse order (If the remainder is greater than 9 represent it using alphabet from the hex table For e.g., Use A if the remainder is 10). | STEP 3: Result is ready :) | . Note: Once you get the number in decimal form, you can convert decimal format into binary as shown before. ",
    "url": "/docs/binary-representation/number-bases.html#converting-between-bases",
    
    "relUrl": "/docs/binary-representation/number-bases.html#converting-between-bases"
  },"338": {
    "doc": "Number bases",
    "title": "Number bases",
    "content": " ",
    "url": "/docs/binary-representation/number-bases.html",
    
    "relUrl": "/docs/binary-representation/number-bases.html"
  },"339": {
    "doc": "Quine McCluskey",
    "title": "Quine McCluskey",
    "content": " ",
    "url": "/docs/logic-design/qmc.html",
    
    "relUrl": "/docs/logic-design/qmc.html"
  },"340": {
    "doc": "Quine McCluskey",
    "title": "Table of contents",
    "content": ". | Introduction | Further reading | References | . ",
    "url": "/docs/logic-design/qmc.html#table-of-contents",
    
    "relUrl": "/docs/logic-design/qmc.html#table-of-contents"
  },"341": {
    "doc": "Quine McCluskey",
    "title": "Introduction",
    "content": "Karnaugh Maps for functions with a large number of literals are difficult to minimise. Usually, a K-map is manageable up to 5 or 6 input literals. MEV can help for functions with a couple more variables. If we look at computer data buses, the information is 8, 16, 32, 64 bits wide or more. Additionally, to do a joint optimisation of functions with multiple output variables, the K-maps for all the combinations of the output variables must be analysed. Also, the visual minimisation using K-maps cannot be programmed to be performed by a computer program. The Quine-McCluskey method is a tabular recursive algorithm, which can be programmed in software. It has no limitations regarding the number of input or output literals. However, it will take longer and more recursions to process functions with more variables (the complexity grows exponentially). ",
    "url": "/docs/logic-design/qmc.html#introduction",
    
    "relUrl": "/docs/logic-design/qmc.html#introduction"
  },"342": {
    "doc": "Quine McCluskey",
    "title": "Further reading",
    "content": "Details of the Quine McCluskey Algorithm can be found in the following references: . | Chapter 4 “Complements in Combinational Network Design” in [1] | Section “Tabular method of minimization” in [2] | Section 4.4 “The tabulation procedure for the determination of prime implicants” in [3] | Section 6.10 “Quine–McCluskey Minimization” in [4] | Wikipedia:Quine–McCluskey algorithm | . ",
    "url": "/docs/logic-design/qmc.html#further-reading",
    
    "relUrl": "/docs/logic-design/qmc.html#further-reading"
  },"343": {
    "doc": "Quine McCluskey",
    "title": "References",
    "content": ". | [1]G. Donzellini, L. Oneto, D. Ponta, and D. Anguita, Introduction to Digital Systems Design. Springer International Publishing, 2018 [Online]. Available at: https://books.google.cl/books?id=va1qDwAAQBAJ | [2]J. Stonham, Digital Logic Techniques. CRC Press, 2017 [Online]. Available at: https://books.google.cl/books?id=a-5HDwAAQBAJ | [3]Z. Kohavi and N. K. Jha, Switching and Finite Automata Theory. Cambridge University Press, 2010 [Online]. Available at: https://books.google.cl/books?id=jZIxam8Rb9AC | [4]M. Ferdjallah, Introduction to Digital Systems: Modeling, Synthesis, and Simulation Using VHDL. Wiley, 2011 [Online]. Available at: https://books.google.cl/books?id=kJRoR8AAu1AC | . ",
    "url": "/docs/logic-design/qmc.html#references",
    
    "relUrl": "/docs/logic-design/qmc.html#references"
  },"344": {
    "doc": "Race conditions",
    "title": "Race conditions",
    "content": " ",
    "url": "/docs/seq-design/race-conditions.html",
    
    "relUrl": "/docs/seq-design/race-conditions.html"
  },"345": {
    "doc": "Race conditions",
    "title": "Table of contents",
    "content": ". | Introduction | Methods to eliminate race around condition . | Increasing the delay of flip-flop | Use of edge-triggered flip-flop | Use of master-slave JK flip-flop | . | . ",
    "url": "/docs/seq-design/race-conditions.html#table-of-contents",
    
    "relUrl": "/docs/seq-design/race-conditions.html#table-of-contents"
  },"346": {
    "doc": "Race conditions",
    "title": "Introduction",
    "content": "Before getting into the race around condition, let us have a look at the JK flip-flop’s truth table. | Clock Input | Inputs | | Outputs | | Comments |   |   | . |   | J | K | Q | Q’ |   | . | 0 | X | X | Same as previous | Same as previous | No change | . | 1 | 0 | 0 | Same as previous | Same as previous | No change | . | 1 | 0 | 1 | 0 | 1 | Reset | . | 1 | 1 | 0 | 1 | 0 | Set | . | 1 | 1 | 1 | Opposite of previous | Opposite of previous | Toggle | . Here, Q is the present state and Q’ is the next state. As you can see, when J, K and Clock are equal to 1, toggling takes place, i.e. The next state will be equal to the complement of the present state. Now, let us look at the timing diagram of JK flip-flop. Here, T is the time period of the clock whereas delta t is the propagation delay. The delay between input and output is called a propagation delay. This is what was expected, but the output may not be like this all the time. This is where Race around condition comes into the play. Let us look at the timing diagram of JK flip-flop when the race around condition is considered. As you already know, when J, K and Clock are equal to 1, toggling takes place. Here, propagation delay has also been reduced, so the output will be given out at the instant input is given. So there is a toggling again. Therefore, whenever Clock is equal to 1 there are consecutive toggling. This condition is called as Race around condition. To put it in words, “ For JK flip-flop if J, K and Clock are equal to 1 the state of flip-flop keeps on toggling which leads to uncertainty in determining the output of the flip-flop. This problem is called Race around the condition. “’ This condition also exists in T flip-flop since T flip-flop also has toggling options. ",
    "url": "/docs/seq-design/race-conditions.html#introduction",
    
    "relUrl": "/docs/seq-design/race-conditions.html#introduction"
  },"347": {
    "doc": "Race conditions",
    "title": "Methods to eliminate race around condition",
    "content": "There are three methods to eliminate race around condition as described below: . Increasing the delay of flip-flop . The propagation delay (delta t) should be made greater than the duration of the clock pulse (T). But it is not a good solution as increasing the delay will decrease the speed of the system. Use of edge-triggered flip-flop . If the clock is High for a time interval less than the propagation delay of the flip flop then racing around condition can be eliminated. This is done by using the edge-triggered flip flop rather than using the level-triggered flip-flop. Use of master-slave JK flip-flop . If the flip flop is made to toggle over one clock period then racing around condition can be eliminated. This is done by using Master-Slave JK flip-flop. | The delay between input and output is called ______. | Propagation delay . | Contamination delay | Rise time | Edge rate | . | . | What are the methods to eliminate race around condition ? . | All of these . | Edge-triggered flip-flop | Master-slave JK flip-flop | Increase flip-flop delay | . | . | Which among the following is the race around condition ? . | J=1,K=1,Clock=1 . | S=1,R=1,Clock=1 | J=0,K=0,Clock=0 | All of these | . | . | . ",
    "url": "/docs/seq-design/race-conditions.html#methods-to-eliminate-race-around-condition",
    
    "relUrl": "/docs/seq-design/race-conditions.html#methods-to-eliminate-race-around-condition"
  },"348": {
    "doc": "Registers",
    "title": "Registers",
    "content": " ",
    "url": "/docs/seq-msi/registers.html",
    
    "relUrl": "/docs/seq-msi/registers.html"
  },"349": {
    "doc": "Registers",
    "title": "Table of contents",
    "content": ". | Introduction | Serial-in serial-out . | Block diagram | Operation | Truth table | Waveforms | . | Serial-in parallel-out . | Block diagram | . | Parallel-in serial-out . | Load mode | Shift mode | Block diagram | . | Parallel-in parallel-out . | Block diagram | . | Applications of shift registers . | Overview | Ring counter | Johnson ring counter | . | . ",
    "url": "/docs/seq-msi/registers.html#table-of-contents",
    
    "relUrl": "/docs/seq-msi/registers.html#table-of-contents"
  },"350": {
    "doc": "Registers",
    "title": "Introduction",
    "content": "A Flip-flop is a 1 bit memory cell which can be used for storing the digital data. To increase the storage capacity in terms of number of bits, you can use a group of flip-flops. Such a group of flip-flops is known as a Register. The n-bit register will consist of n number of flip-flop(s) and it is capable of storing an n-bit word. The binary-data, in a register, can be transfered within itself from one flip-flop to another. A shift register is a type of register that allows such data transfers. Shift register has 4 modes of operations. Next, let us have a look at each register operation one by one. | Serial-in serial-out | Serial-in parallel-out | Parallel-in serial-out | Parallel-in parallel-out | . ",
    "url": "/docs/seq-msi/registers.html#introduction",
    
    "relUrl": "/docs/seq-msi/registers.html#introduction"
  },"351": {
    "doc": "Registers",
    "title": "Serial-in serial-out",
    "content": "Let all the flip-flops be initially in the reset condition i.e. Q3 = Q2 = Q1 = Q0 = 0. If an entry of a four-bit binary number 1 1 1 1 is made into the register, this number should be applied to Din bit with the LSB bit applied first. The D input of FF-3 i.e. D3 is connected to serial data input Din. The output of FF-3 i.e. Q3 is connected to the input of the next flip-flop i.e. D2, and so on. Block diagram . Operation . Before application of the clock signal, let Q3 Q2 Q1 Q0 = 0000 and apply the LSB bit of the number to Din. So Din = D3 = 1. Now, apply the clock. On the first falling edge of the clock, the FF-3 is set, and stored word in the register is Q3 Q2 Q1 Q0 = 1000. Apply the next bit to Din. So Din = 1. As soon as the next negative edge of the clock gets triggered, FF-2 will set and the stored word change to Q3 Q2 Q1 Q0 = 1100. Apply the next bit to be stored i.e. 1 to Din. Apply the clock pulse. As soon as the third negative clock edge gets triggered, FF-1 will be set and output will get modified to Q3 Q2 Q1 Q0 = 1110. Similarly with Din = 1 and with the fourth negative clock edge arriving, the stored word in the register is Q3 Q2 Q1 Q0 = 1111. Truth table . Waveforms . ",
    "url": "/docs/seq-msi/registers.html#serial-in-serial-out",
    
    "relUrl": "/docs/seq-msi/registers.html#serial-in-serial-out"
  },"352": {
    "doc": "Registers",
    "title": "Serial-in parallel-out",
    "content": ". | In such types of operations, the data is entered serially and taken out in parallel fashion. | Data is loaded bit-by-bit. The output(s) are disabled as long as the data is loading. | As soon as the data loading gets completed, all the flip-flops contain their required data. The output(s) are enabled so that all the loaded data is made available over all the output lines at the same time. | 4 clock cycles are required to load a four-bit word. Hence the speed of operation of SIPO mode is the same as that of the SISO mode. | . Block diagram . ",
    "url": "/docs/seq-msi/registers.html#serial-in-parallel-out",
    
    "relUrl": "/docs/seq-msi/registers.html#serial-in-parallel-out"
  },"353": {
    "doc": "Registers",
    "title": "Parallel-in serial-out",
    "content": ". | Data bits enter in a parallel fashion. | The circuit, shown below, is a four-bit parallel-in serial-out register. | Output of the previous flip Flop is connected to the input of the next one via a combinational circuit. | The binary input data bits B0, B1, B2, B3 are applied through the same combinational logic circuit. | There are two modes in which this circuit can work, namely - shift mode and load mode. | . Load mode . When the shift/load bar line is low (0), the AND gates 2, 4 and 6 become active, and they will pass B1, B2, B3 bits to the corresponding flip-flops. On the low going edge of the clock, the binary inputs B0, B1, B2, B3 will get loaded into the corresponding flip-flops. Thus, the parallel loading takes place. Shift mode . When the shift/load bar line is low (1), the AND gates 2, 4 and 6 become inactive. Hence, the parallel loading of the data becomes impossible. But the AND gates 1,3 and 5 become active. Therefore the shifting of data takes place from left-to-right bit-by-bit on the application of clock pulses. Thus, the parallel-in serial-out operation takes place. Block diagram . ",
    "url": "/docs/seq-msi/registers.html#parallel-in-serial-out",
    
    "relUrl": "/docs/seq-msi/registers.html#parallel-in-serial-out"
  },"354": {
    "doc": "Registers",
    "title": "Parallel-in parallel-out",
    "content": "Here, the 4-bit binary datda inputs B0, B1, B2, B3 are applied to the data inputs D0, D1, D2, D3, respectively, of the four flip-flops. When a negative edge of the clock is triggered, then the flip-flops get loaded with the input binary bits simultaneously. The loaded bits appear at the output side, simultaneously, as well. Only the clock pulse is essential to load all the binary bits. Block diagram . ",
    "url": "/docs/seq-msi/registers.html#parallel-in-parallel-out",
    
    "relUrl": "/docs/seq-msi/registers.html#parallel-in-parallel-out"
  },"355": {
    "doc": "Registers",
    "title": "Applications of shift registers",
    "content": "Overview . Shift registers are sequential circuits used primarily used for: . | Storage of Data | Data transfer through movement of binary data | Data manipulation | Counter implementation | . They are called shift registers as it moves or shifts binary input data to its output per clock cycle. Shift registers are commonly used to store data inside calculators. Even in computer systems, operations like addition, subtraction, division and multiplication are performed by registers. Shift registers can be applied in the following ways: . | Parallel to Serial conversion: Used in transmitters after analog to digital conversion in order to convert parallel input data into serial data . | Serial to Parallel conversion: Used in receivers before digital to anlogous conversion takes place in order to convert serial input data into parallel data . | Sequence Generator: Generate a sequence of 0s and 1s when combined with some additional gates . | Counters: Shift registers can be implemented as counters based on the output of the rightmost D flip-flop that is connected to the serial input, namely the Ring Counter and the Johnson Ring Counter . | Serial-in Serial-out registers are used for time delays . | . Ring counter . Similar to how the Serial-in Serial-out register requires ‘N’ clock pulses to shift N bit data, the ‘N’ Ring Counter produces a sequence of 0s and 1s, by having the rightmost D flip-flop as input to the leftmost D flip-flop as opposed to applying data externally. That is, the output of the last flip-flop is connected to the output of the first flip-flop in the ring. These patterns of states (0s and 1s) are repeated every ‘N’ clock cycles. The number of states in a Ring Counter are directly proportional to the number of flip-flops used. The block diagram of the 3-bit Ring counter is shown in the following figure. A 3-bit Ring Counter will contain only a 3-bit SIPO shift register. Assume, the initial status of the D flip-flops from leftmost to rightmost is Q2Q1Q0=001. Here, Q2 &amp; Q0 are MSB &amp; LSB respectively. You can understand the working of Ring counter from the following table. | No of positive edge of Clock | Serial Input = Q0 | Q2(MSB) | Q1 | Q0(LSB) | . | 0 | - | 0 | 0 | 1 | . | 1 | 1 | 1 | 0 | 0 | . | 2 | 0 | 0 | 1 | 0 | . | 3 | 0 | 0 | 0 | 1 | . Due to the absence of the clock signal, the initial status of the D flip-flops is Q2Q1Q0=001. This state will repeat every third positive edge transition of the clock signal. Similarly, the following operations take place every positive edge of the clock cycle: . | Serial input of the first D flip-flop gets the previous output of the third flip-flop. Thus, the present output of the first D flip-flop is equal to the previous output of the third flip-flop. | The previous outputs of first and second D flip-flops are right-shifted by one bit. That implies that the present outputs of second and third D flip-flops are equal to the previous outputs of first and second D flip-flops. | . Johnson ring counter . The Johnson ring counter functions similarly to the Ring counter. The difference being that the complemented output of rightmost D flip-flop is given as input of leftmost D flip-flop instead of normal output. Thus, ‘N’ bit Johnson Ring counter produces a sequence of states (pattern of zeros and ones) and it repeats for every ‘2N’ clock cycles. Johnson ring counter is also called the Twisted ring counter and Switch tail ring counter. The block diagram of 3-bit Johnson Ring counter is shown in the following figure. The 3-bit Johnson Ring counter also contains only a 3-bit SIPO shift register. Assume, initially, all the D flip-flops are cleared. So, Q2Q1Q0=000. Here, Q2 is the MSB &amp; Q0 is the LSB. | No of positive edge of Clock | Serial Input = Q0 | Q2(MSB) | Q1 | cQ0(LSB) | . | 0 | - | 0 | 0 | 0 | . | 1 | 1 | 1 | 0 | 0 | . | 2 | 1 | 1 | 1 | 0 | . | 3 | 1 | 1 | 1 | 1 | . | 4 | 0 | 0 | 1 | 1 | . | 5 | 0 | 0 | 0 | 1 | . | 6 | 0 | 0 | 0 | 0 | . The initial status of the D flip-flops in the absence of the clock signal is Q2Q1Q0=000. This status repeats for every six positive edge transitions of the clock signal. Similarly, the following operations take place for every positive edge of the clock signal. | Serial input of first D flip-flop gets the previous complemented output of the third flip-flop. So, the present output of the first D flip-flop is equal to the previous complemented output of the third flip-flop. | The previous outputs of first and second D flip-flops are right shifted by one bit. That means, the present outputs of second and third D flip-flops are equal to the previous outputs of first and second D flip-flops. | . ",
    "url": "/docs/seq-msi/registers.html#applications-of-shift-registers",
    
    "relUrl": "/docs/seq-msi/registers.html#applications-of-shift-registers"
  },"356": {
    "doc": "ROM-based µcontrollers",
    "title": "ROM-based µcontrollers",
    "content": " ",
    "url": "/docs/seq-lsi/rom-microcontrollers.html",
    
    "relUrl": "/docs/seq-lsi/rom-microcontrollers.html"
  },"357": {
    "doc": "ROM-based µcontrollers",
    "title": "Table of contents",
    "content": ". | Introduction | General purpose ROM-based µcontroller | Counter based µcontroller | Preset counter based µcontroller | MUX based µcontroller | . ",
    "url": "/docs/seq-lsi/rom-microcontrollers.html#table-of-contents",
    
    "relUrl": "/docs/seq-lsi/rom-microcontrollers.html#table-of-contents"
  },"358": {
    "doc": "ROM-based µcontrollers",
    "title": "Introduction",
    "content": "ROM-based µcontrollers take the simple approach of implementing the combinational logic block of any sequential circuit (both the next state decoder and the output decoder) in a ROM circuit, while latches and counters can be used to make a more efficient use of the ROM capacity. In some cases, additional combinational MUX components are used for the same reason. The following are examples of different ROM-based µcontrollers . ",
    "url": "/docs/seq-lsi/rom-microcontrollers.html#introduction",
    
    "relUrl": "/docs/seq-lsi/rom-microcontrollers.html#introduction"
  },"359": {
    "doc": "ROM-based µcontrollers",
    "title": "General purpose ROM-based µcontroller",
    "content": "A general purpose ROM-based µcontroller can be implemented as depicted in the block diagram below: . Both, the output decoder and the next-state decoder are implemented in the ROM. The number of address bits for the ROM must be greater than or equal to the sum of the number of input bits $M$ and the number of state variables $N$s. The size of the output word must be greater than or equal to the sum of the number of outputs html:(K)@@ and the number of state variables. ROM capacity: $2^{(M+N)}\\times (K+N)$ . ",
    "url": "/docs/seq-lsi/rom-microcontrollers.html#general-purpose-rom-based-%C2%B5controller",
    
    "relUrl": "/docs/seq-lsi/rom-microcontrollers.html#general-purpose-rom-based-µcontroller"
  },"360": {
    "doc": "ROM-based µcontrollers",
    "title": "Counter based µcontroller",
    "content": "When the FSM corresponds to a simple sequence of states (without branches), a counter can be used to represent the state. The counter output (or state code) selects the corresponding output word from the ROM (A in the figure below). At the same time, part of the bits stored in the ROM (B in the figure) are used to select (via the MUX) the input associated which can produce the state transition for the current state. ROM capacity: $2^N \\times (K+\\log_2 M)$ . ",
    "url": "/docs/seq-lsi/rom-microcontrollers.html#counter-based-%C2%B5controller",
    
    "relUrl": "/docs/seq-lsi/rom-microcontrollers.html#counter-based-µcontroller"
  },"361": {
    "doc": "ROM-based µcontrollers",
    "title": "Preset counter based µcontroller",
    "content": "If the FSM is mostly a simple sequence of state, but there are a few “jumps” to states out of the sequence, the previous circuit can be extended to store the address of the state which is out of the sequence and load it through the preset lines of the counter. ROM capacity: $2^N \\times (N+K+\\log_2 M)$ . ",
    "url": "/docs/seq-lsi/rom-microcontrollers.html#preset-counter-based-%C2%B5controller",
    
    "relUrl": "/docs/seq-lsi/rom-microcontrollers.html#preset-counter-based-µcontroller"
  },"362": {
    "doc": "ROM-based µcontrollers",
    "title": "MUX based µcontroller",
    "content": "For FSM which do not exhibit a simple sequence of states, the counter can be replaced by a MUX and the next state addresses must be stored in the ROM. ROM capacity: $2^N \\times (2N+K+\\log_2 M)$ . | What is the ROM capacity of Counter based µcontroller ? . | 2^N\\times(K+\\log_2 M) . | 2^N\\times(N+K+\\log_2 M) | 2^{(M+N)}\\times(K+N) | 2^M\\times(M+N) | . | . | Which among the following is not micro-controller ? . | DMUX based µcontroller . | MUX based µcontroller | ROM-based µcontroller | None | . | . | What is the ROM capacity of Preset counter based µcontroller ? . | 2^N\\times(N+K+\\log_2 M) . | 2^N\\times(K+\\log_2 M) | 2^{(M+N)}\\times(K+N) | 2^M\\times(M+N) | . | . | . ",
    "url": "/docs/seq-lsi/rom-microcontrollers.html#mux-based-%C2%B5controller",
    
    "relUrl": "/docs/seq-lsi/rom-microcontrollers.html#mux-based-µcontroller"
  },"363": {
    "doc": "ROM",
    "title": "Read-Only Memory",
    "content": " ",
    "url": "/docs/comb-lsi/rom.html#read-only-memory",
    
    "relUrl": "/docs/comb-lsi/rom.html#read-only-memory"
  },"364": {
    "doc": "ROM",
    "title": "Table of contents",
    "content": ". | Introduction | Types of ROM . | Mask ROM | PROM | Flash memory | . | Implementing a combinational circuit using a ROM . | Advantages and disadvantages | . | Interactive example | . ",
    "url": "/docs/comb-lsi/rom.html#table-of-contents",
    
    "relUrl": "/docs/comb-lsi/rom.html#table-of-contents"
  },"365": {
    "doc": "ROM",
    "title": "Introduction",
    "content": "A Read-Only-Memory (ROM) is a large scale integration (LSI) combinational circuit. ROM circuits can store binary words of a fixed length in each “cell”. Each cell has an associated binary number usually referred to as “address”. The number of cells is determined by the address’ number of bits. The storage is “non-volatile”, meaning that when the data remains in the circuit even when the power is removed. In contrast, “volatile” storage, such as most Random Access Memory (RAM) circuits, cannot retain the stored binary information when the circuit is disconnected from power. Let $m$ be the address’ number of bits and $n$ the number of bits in each cell (output bits), then the ROM’s size (in bits) can be calculated as $2^m\\times n$. In fact, ROM circuits can be seen as combinational circuits capable of storing large truth-tables whose inputs correspond to the address. ",
    "url": "/docs/comb-lsi/rom.html#introduction",
    
    "relUrl": "/docs/comb-lsi/rom.html#introduction"
  },"366": {
    "doc": "ROM",
    "title": "Types of ROM",
    "content": "The first ROM circuits produced had the data stored at the moment of fabrication and it was not possible to modify the contents afterwards. That is the main reason why they are called “Read-Only”. The process of storing data into a ROM chip is usually referred to as programming. Technological advances allowed the creation of ROM circuits which could be rewritten after fabrication with or without external. Usually, ROM circuits are classified based on their (re)programming technology. Mask ROM . This type of circuit is programmed at manufacturing time. It cannot be re-programmed afterwards. This process is usually the cheapest when manufacturing large quantities of identical ROM circuits. PROM . In Programmable read-only memory (PROM), the data can be stored after the manufacturing process or in the field. The method of programming as well as the number of times it can be programmed gives way to a number of subtypes. | OTP . One-time-programmable (OTP) ROM can only be programmed once. | EPROM . Erasable programmable read-only memory (EPROM) can be erased using ultraviolet (UV) light and then rewritten, a limited number of times. | EEPROM . Electrically erasable programmable read-only memory (EEPROM) can be erased electrically instead of using UV-light. | . Flash memory . Flash memory is a more modern version of the EEPROM. The erasing and rewriting phases are faster. ",
    "url": "/docs/comb-lsi/rom.html#types-of-rom",
    
    "relUrl": "/docs/comb-lsi/rom.html#types-of-rom"
  },"367": {
    "doc": "ROM",
    "title": "Implementing a combinational circuit using a ROM",
    "content": "The process of implementation of a binary function(s) using ROM circuits mainly consists in estimating the optimal size of the memory, restricted to the required number of inputs and outputs. Then, the equivalent truth-table has to be stored or “programmed” into the circuit. Advantages and disadvantages . | Single discrete component: . | Use less space than equivalent AND/OR network | Simple implementation (just copy the truth table into the memory. | . | If there are unused memory cells, then more functionality can be added to the same circuit. If the ROM is erasable/re-programmable the truth table can be rewritten into the memory, or the IC can be replaced if it is an OTP memory or Mask ROM. | Depending on the type of ROM the power consumption might be larger than the equivalent AND/OR network power consumption. | In general, ROM access takes a longer time than the propagation time of the equivalent AND/OR network. For instance, 150ns access time for the AT28C64B ROM vs 4.2ns (2×2.1ns) of a 74LVC quad gate. | For very simple or small logic functions, available COTS ROM might be too large, so choosing a ROM would be inefficient in terms of costs and power consumption, considering that most of the ROM circuit will never be used. | . ",
    "url": "/docs/comb-lsi/rom.html#implementing-a-combinational-circuit-using-a-rom",
    
    "relUrl": "/docs/comb-lsi/rom.html#implementing-a-combinational-circuit-using-a-rom"
  },"368": {
    "doc": "ROM",
    "title": "Interactive example",
    "content": "Let’s suppose we have a ROM circuit with 4 bit addresses and 8 bit words. The ROM capacity can be calculated as $2^4\\times 8 = 64 \\text{bits} = 16 \\text{bytes}$ . Such a ROM can be used to implement 8 single bit binary functions. Let’s say the binary functions have 3 input literals $A,B,C$ which will be connected to the 3 LSB of the ROM address inputs $x_1,x_2,x_3$, respectively. The MSB of the ROM address ($x_0$) will be used to either select the non-inverted value of the functions ($x_0=0$) or the inverted value of the functions ($x_0=1$). If the functions are . $$\\begin{align} z_0 &amp;= A+B+C z_1 &amp;= A+B z_2 &amp;= A+C z_3 &amp;= B+C z_4 &amp;= A\\cdot B\\cdot C z_5 &amp;= A\\cdot B z_6 &amp;= A\\cdot C z_7 &amp;= B\\cdot C \\end{align}$$ . then the corresponding truth table is . | : Input word : |||| | :Output word: |||||||| |   |   |   |   |   |   |   |   |   |   |   |   | . | Address ($i$) | $x_0$ | $x_1$ | $x_2$ | $x_3$ | $z_0$ | $z_1$ | $z_2$ | $z_3$ | $z_4$ | $z_5$ | $z_6$ | $z_7$ | (hex) | . | ^^ | Inverted output | $A$ | $B$ | $C$ | $A+B+C$ | $A+B$ | $A+C$ | $B+C$ | $ABC$ | $AB$ | $AC$ | $BC$ | ^^ | . | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 00 | . | 1 | 0 | 0 | 0 | 1 | 1 | 0 | 1 | 1 | 0 | 0 | 0 | 0 | B0 | . | 2 | 0 | 0 | 1 | 0 | 1 | 1 | 0 | 1 | 0 | 0 | 0 | 0 | D0 | . | 3 | 0 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 1 | F1 | . | 4 | 0 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | E0 | . | 5 | 0 | 1 | 0 | 1 | 1 | 1 | 1 | 1 | 0 | 0 | 1 | 0 | F2 | . | 6 | 0 | 1 | 1 | 0 | 1 | 1 | 1 | 1 | 0 | 1 | 0 | 0 | F4 | . | 7 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | FF | . | 8 | 1 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | FF | . | 9 | 1 | 0 | 0 | 1 | 0 | 1 | 0 | 0 | 1 | 1 | 1 | 1 | 4F | . | 10 | 1 | 0 | 1 | 0 | 0 | 0 | 1 | 0 | 1 | 1 | 1 | 1 | 2F | . | 11 | 1 | 0 | 1 | 1 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 0 | 0E | . | 12 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 1 | 1F | . | 13 | 1 | 1 | 0 | 1 | 0 | 0 | 0 | 0 | 1 | 1 | 0 | 1 | 0D | . | 14 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 1 | 0 | 1 | 1 | 0B | . | 15 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 00 | . The interactive circuit below implements the table: . ",
    "url": "/docs/comb-lsi/rom.html#interactive-example",
    
    "relUrl": "/docs/comb-lsi/rom.html#interactive-example"
  },"369": {
    "doc": "ROM",
    "title": "ROM",
    "content": " ",
    "url": "/docs/comb-lsi/rom.html",
    
    "relUrl": "/docs/comb-lsi/rom.html"
  },"370": {
    "doc": "Sequential synthesis",
    "title": "Sequential synthesis",
    "content": " ",
    "url": "/docs/seq-design/seq-synth.html",
    
    "relUrl": "/docs/seq-design/seq-synth.html"
  },"371": {
    "doc": "Sequential synthesis",
    "title": "Table of contents",
    "content": ". | Introduction | Sequential synthesis process | Interactive example . | Functional description | State assignment | Combinational synthesis | . | . ",
    "url": "/docs/seq-design/seq-synth.html#table-of-contents",
    
    "relUrl": "/docs/seq-design/seq-synth.html#table-of-contents"
  },"372": {
    "doc": "Sequential synthesis",
    "title": "Introduction",
    "content": "As presented in section FSM any sequential circuit can be modelled using Finite State Machines (FSM) or, viceversa, any FSM can be implemented in a sequential circuit. The process to obtain such a circuit from its functional description or model is referred to as sequential synthesis. ",
    "url": "/docs/seq-design/seq-synth.html#introduction",
    
    "relUrl": "/docs/seq-design/seq-synth.html#introduction"
  },"373": {
    "doc": "Sequential synthesis",
    "title": "Sequential synthesis process",
    "content": "Every sequential circuit can also be represented by the following general model: . The first step in the synthesis process is to state the functional description of the system in terms of a FSM. The state machine can be formally represented by state diagrams or state tables. The number of state variables $(r)$ is directly related to the number of states which can represented by those state variables $(2^r)$. Also, the number of components or their size is related to the number of state variables. On the other hand, the devised FSM might contain redundant states. Therefore, in order to obtain an optimal circuit (in terms of the number of components and number of feedback connections) it is desirable to reduce the number of states by eliminating unnecesary ones. This is the second step in the process. To represent the state with the binary state variables, a binary code must be assigned to each state. A careful selection of the state codes can help in a later stage to minimise the number of components in the combinational logic block. The memory block can be implemented using any of the basic sequential building blocks (latches or flip-flops) or even simple delay lines. Once the type of memory components is decided, it is possible to declare the truth table for the combinational logic block whose inputs are the (external) inputs of the system and the state variables (or internal inputs), while the outputs correspond to the (external) outputs as well as the excitation variables, which will produce the next state by means of the memory block. Finding the optimal combinational logic circuit is the final step in the process. ",
    "url": "/docs/seq-design/seq-synth.html#sequential-synthesis-process",
    
    "relUrl": "/docs/seq-design/seq-synth.html#sequential-synthesis-process"
  },"374": {
    "doc": "Sequential synthesis",
    "title": "Interactive example",
    "content": "A typical example of a complex synchronous sequential system is the system controller of a vending machine. Functional description . Let’s consider the following simplified block diagram representing the vending machine: . The digital system controller has to interact with the three devices: . | Coin Receiver | Coin Return | Pop Drop | . The coin receiver has four (4) output signals which will be inputs for the system controller and two (2) signals in the other direction: . | CP: (Coin Present) output signal becomes high (or true) when a coin is inserted and being processed and goes back to low value when it finishes processing the coin. | S&lt;: (Total amount is less than product’s price) output signal becomes high if the amount of deposited coins is less than the product’s price. | S=: (Total amount is equal to the product’s price) output signal becomes high if the deposited amount is equal to the product’s price. | S&gt;: (Total amount is greater than product’s price) output signal becomes high if the amount exceeds the product’s price. | DA: (Decrement Accumulator) signal from the controller instructs the coin receiver to subtract the amount returned by the coin return device from the total sum and update the Sx signals. | CA: (Clear Accumulator) signal from the controller tells the coin receiver to clear the total amount. | . The coin return device has two (2) signal connected to the system controller one on each direction: . | RN: (Return Nickel) signal to the device triggers the return of a change (as long as S&gt; is high). | CR: (Changer Ready) signal from the device indicates the controller that the it has finished returning a coin. | . The pop drop device has also two (2) signals connected to the system controller one on each direction: . | DP: (Drop Pop) signal from the controller instructs the device to start the process of delivering the product. | PDR: (Pop Drop Ready) signal to the controller informs when the product has been delivered. | . The Finite State Machine (FSM) which models the process can be described by the following state diagram (note that the state codes have already been assigned, see the explanation in State assignment: . The initial state (a) waits a for a coin to be inserted, when that happens the machine transitions to state (b) and waits until the coin is processed by the coin receiver and then moves to state (c). In state (c) the total amount is checked: if it is still not enough it goes back to state (a) to wait for more coins to be inserted. If it is equal to the price of the product the machine gets to state (d) which triggers signal DP to release the product and waits until de pop drop device informs the process is finished by asserting the PDR signal. At this moment, the machine state becomes (e) which sends the CA signal to clear the total sum in the coin receiver and then goes back to the initial state (a). On the other hand, while at state (c), if total amount is greater than the price then the machine enters state (f) which sets signal RN to high in order to tell the coin return to return a fixed amount. When it is done, the coin return responds by sending a true value back to the controller using signal CR. When this happens the machine moves on to state (g) which activates signal DA to the coin receiver to update the total amount and changes back to state (c) to check the new amount. State assignment . Given the FSM state diagram the following conditions regarding state codes should be considered: . | (a) should be adjacent to (b) | (b) should be adjacent to (c) | (d) should be adjacent to (e) | (f) should be adjacent to (g) | . The following state map takes all considerations into account: . |   | :AB: ||| |   |   |   | . | C | 00 | 01 | 11 | 10 | . | 0 | a | $\\phi$ | d | f | . | 1 | b | c | e | g | . Combinational synthesis . Given the state codes the output decoder can be represented by the following map: . |   | :AB: ||| |   |   |   | . | C | 00 | 01 | 11 | 10 | . | 0 |   |   | DP | RN | . | 1 |   |   | CA | DA | . By selecting JK Flip-flops as the memory elements the following maps represent the next state decoder: . | $J_A$ | :AB: ||| |   |   |   | . | C | 00 | 01 | 11 | 10 | . | 0 | 0 | $\\phi$ | $\\phi$ | $\\phi$ | . | 1 | 0 | S=+S&gt; | $\\phi$ | $\\phi$ | . $J_A = B(\\text{S= + S&gt;})$ . | $K_A$ | :AB: ||| |   |   |   | . | C | 00 | 01 | 11 | 10 | . | 0 | $\\phi$ | $\\phi$ | 0 | 0 | . | 1 | $\\phi$ | $\\phi$ | 1 | 1 | . $K_A = C$ . | $J_B$ | :AB: ||| |   |   |   | . | c | 00 | 01 | 11 | 10 | . | 0 | 0 | $\\phi$ | $\\phi$ | 0 | . | 1 | $\\overline{CP}$ | $\\phi$ | $\\phi$ | 1 | . $J_B = C(\\overline{CP})+ AC$ . | $K_B$ | :AB: ||| |   |   |   | . | C | 00 | 01 | 11 | 10 | . | 0 | $\\phi$ | $\\phi$ | 0 | $\\phi$ | . | 1 | $\\phi$ | $\\overline{\\text{S=}}$ | 1 | $\\phi$ | . $K_B = C(\\overline{\\text{S=}}) + AC$ . | $J_C$ | :AB: ||| |   |   |   | . | C | 00 | 01 | 11 | 10 | . | 0 | CP | $\\phi$ | PDR | CR | . | 1 | $\\phi$ | $\\phi$ | $\\phi$ | $\\phi$ | . $J_C = A(CP) + B(PDR) + A\\overline{B}(CR)$ . | $K_C$ | :AB: ||| |   |   |   | . | C | 00 | 01 | 11 | 10 | . | 0 | $\\phi$ | $\\phi$ | $\\phi$ | $\\phi$ | . | 1 | 0 | 1 | 1 | 0 | . $K_C = B$ . The circuit which implements such a machine is the following: . ",
    "url": "/docs/seq-design/seq-synth.html#interactive-example",
    
    "relUrl": "/docs/seq-design/seq-synth.html#interactive-example"
  },"375": {
    "doc": "Shannon decomposition",
    "title": "Shannon decomposition",
    "content": " ",
    "url": "/docs/binary-algebra/shannon.html",
    
    "relUrl": "/docs/binary-algebra/shannon.html"
  },"376": {
    "doc": "Shannon decomposition",
    "title": "Table of contents",
    "content": ". | Boole’s expansion theorem | References | . ",
    "url": "/docs/binary-algebra/shannon.html#table-of-contents",
    
    "relUrl": "/docs/binary-algebra/shannon.html#table-of-contents"
  },"377": {
    "doc": "Shannon decomposition",
    "title": "Boole’s expansion theorem",
    "content": "The Shannon expansion or decomposition theorem, also known as Boole’s expansion theorem is an identity which allow the expansion of any logic function to broken down in parts. One consequence of this theorem is the possibility to implement any logic function using multiplexers. The expansion can take any of these three variations: . $\\begin{aligned} f(x_1,x_2,\\ldots,x_n)&amp;= x_1 \\cdot f(1,x_2,\\ldots,x_n) + \\overline{x_1}\\cdot f(0,x_2,\\ldots,x_n) \\\\\\\\ &amp;= \\bigl(x_1+f(0,x_2,\\ldots,x_n)\\bigr)\\cdot \\bigl(\\overline{x_1}+f(1,x_2,\\ldots,x_n)\\bigr) \\\\\\\\ &amp;= x_1 \\cdot f(1,x_2,\\ldots,x_n) \\oplus \\overline{x_1}\\cdot f(0,x_2,\\ldots,x_n) \\end{aligned}$ . More details can be found in Section 1.9 “Shannon’s Expansion Theorem” in [1] and in Section 3.2 “Switching functions” in [2]. ",
    "url": "/docs/binary-algebra/shannon.html#booles-expansion-theorem",
    
    "relUrl": "/docs/binary-algebra/shannon.html#booles-expansion-theorem"
  },"378": {
    "doc": "Shannon decomposition",
    "title": "References",
    "content": ". | [1]G. Donzellini, L. Oneto, D. Ponta, and D. Anguita, Introduction to Digital Systems Design. Springer International Publishing, 2018 [Online]. Available at: https://books.google.cl/books?id=va1qDwAAQBAJ | [2]Z. Kohavi and N. K. Jha, Switching and Finite Automata Theory. Cambridge University Press, 2010 [Online]. Available at: https://books.google.cl/books?id=jZIxam8Rb9AC | . ",
    "url": "/docs/binary-algebra/shannon.html#references",
    
    "relUrl": "/docs/binary-algebra/shannon.html#references"
  },"379": {
    "doc": "Subtraction",
    "title": "Binary subtraction",
    "content": " ",
    "url": "/docs/binary-algebra/subtraction.html#binary-subtraction",
    
    "relUrl": "/docs/binary-algebra/subtraction.html#binary-subtraction"
  },"380": {
    "doc": "Subtraction",
    "title": "Table of contents",
    "content": ". | Subtraction | . ",
    "url": "/docs/binary-algebra/subtraction.html#table-of-contents",
    
    "relUrl": "/docs/binary-algebra/subtraction.html#table-of-contents"
  },"381": {
    "doc": "Subtraction",
    "title": "Subtraction",
    "content": "Binary subtraction is also a simple task. You just need to keep in mind i.e., whenever 0 takes borrow, it becomes 10 i.e., 2 in decimal. In case number to the left is zero then look for the number more left to that until you find 1. In case nothing is present to borrow then that number becomes negative. Also, the number which gives borrow is reduced by 1. Note: 10 becomes 1 after giving borrow. Examples : 0 - 0 = 0 1 - 0 = 1 1 - 1 = 0 1 0 (2)This is something which will always happen in binary subtraction. Keep in mind i.e., 10-1=1 - 0 1 (1)Reason being 10 is 2 in decimal which on subtraction with 1 gives 1. ----- Implies that 10 - 1 = 1 0 1 (1) ----- This 0 increases to 10 after taking the carry and reduces to 1 after giving the borrow. / 1 0 0 (4) - 0 0 1 (1) ------- 0 1 1 (3) ------- . | Binary subtraction of 10100111–00011000= ? . | 010001111 . | 110001111 | 010101111 | 011001111 | . | . | Binary subtraction of 101001–010110= ? . | 010011 . | 011011 | 110011 | 010111 | . | . | Binary subtraction of 101101–101011= ? . | 000010 . | 001010 | 101010 | 100000 | . | . | . ",
    "url": "/docs/binary-algebra/subtraction.html",
    
    "relUrl": "/docs/binary-algebra/subtraction.html"
  },"382": {
    "doc": "Universal gates",
    "title": "Universal gates",
    "content": " ",
    "url": "/docs/comb-ssi/universal-gates.html",
    
    "relUrl": "/docs/comb-ssi/universal-gates.html"
  },"383": {
    "doc": "Universal gates",
    "title": "Table of contents",
    "content": ". | Introduction | NOR gate . | Implementing NOT gate | Implementing OR gate | Implementing AND gate | . | NAND gate . | Implementing NOT gate | Implementing OR gate | Implementing AND gate | . | Introduction | Functional completeness | Simplification . | Step 1: Double negation | Step 2: Applying De Morgan’s law | Step 3: Construct the NAND circuit | . | Introduction | Functional completeness | Simplification . | Step 1: Double negation | Step 2: Applying De Morgan’s law | Step 3: Construct the NOR circuit | . | . ",
    "url": "/docs/comb-ssi/universal-gates.html#table-of-contents",
    
    "relUrl": "/docs/comb-ssi/universal-gates.html#table-of-contents"
  },"384": {
    "doc": "Universal gates",
    "title": "Introduction",
    "content": "Universal gates are gates which can be used to implement all other gates. This is useful as manufacturers only need to produce 1 type of universal gate to be able to use all other gates. The universal gates are NOR and NAND. This page will show you how to implement AND, OR and NOT gates using universal gates. The AND, OR and NOT gates are basic gates that are commonly used and are very important. ",
    "url": "/docs/comb-ssi/universal-gates.html#introduction",
    
    "relUrl": "/docs/comb-ssi/universal-gates.html#introduction"
  },"385": {
    "doc": "Universal gates",
    "title": "NOR gate",
    "content": "The NOR gate is the opposite of the OR gate. It is like an OR gate followed by a NOT gate. Implementing NOT gate . A NOT gate can be implemented by passing the same input into both inputs of the NOR gate. Implementing OR gate . An OR gate can be implemented by passing the output of NOR to the NOT gate implemented earlier. Implementing AND gate . Since the NOR gate outputs true only when both inputs are 0, an AND gate can be implemented by inverting the inputs to a NOR gate. ",
    "url": "/docs/comb-ssi/universal-gates.html#nor-gate",
    
    "relUrl": "/docs/comb-ssi/universal-gates.html#nor-gate"
  },"386": {
    "doc": "Universal gates",
    "title": "NAND gate",
    "content": "The NAND gate is the opposite of the AND gate. It is like an AND gate followed by a NOT gate. Implementing NOT gate . Similarly to NOR, a NOT gate can also be implemented by joining the inputs of a NAND gate. Implementing OR gate . The only time the NAND gate output is 0 is when both inputs are 1. Therefore, by inverting the inputs of a NAND gate, an OR gate can be implemented. Implementing AND gate . The AND gate is simply the output of a NAND gate inverted. ",
    "url": "/docs/comb-ssi/universal-gates.html#nand-gate",
    
    "relUrl": "/docs/comb-ssi/universal-gates.html#nand-gate"
  },"387": {
    "doc": "Universal gates",
    "title": "Introduction",
    "content": "NAND Gates are universal gates. By the virtue of functional completeness, NAND Gates can be used to fully represent a given boolean expression. This simplifies the expression such that only one standard gate is used throughout. ",
    "url": "/docs/comb-ssi/universal-gates.html#introduction-1",
    
    "relUrl": "/docs/comb-ssi/universal-gates.html#introduction-1"
  },"388": {
    "doc": "Universal gates",
    "title": "Functional completeness",
    "content": "Functional completeness is a property pertaining to boolean logic, which states that a functionally complete boolean operator can express all possible truth tables by representing itself in a boolean expression. That is, any given boolean expression can be completely represented by using the a functionally complete boolean operator. For example, NAND gates can be used to implement the NOT gate, the OR gate and the AND gate. ",
    "url": "/docs/comb-ssi/universal-gates.html#functional-completeness",
    
    "relUrl": "/docs/comb-ssi/universal-gates.html#functional-completeness"
  },"389": {
    "doc": "Universal gates",
    "title": "Simplification",
    "content": "To simplify any given boolean expression, first find the minimum number of NAND gates required. To do this, carry out the following steps. Let’s find the minimum number of NAND gates required to simplify the logical expression: . F(A, B, C, D) = AB' + C'D . Step 1: Double negation . Since the NAND gate is a combination of a NOT gate and an AND gate, we first apply a double negation to the entire expression so that we are able to standardize it later on. Adding a double negation does not alter the inherent value of the expression as a double negation always nullifies itself. F = (F')' = ((AB' + C'D)')' . Step 2: Applying De Morgan’s law . We first apply De Morgan’s Law to the innermost bracket, such that we preserve the outermost negation at the time of expressing the F as a NAND expression. Thus, by applying De Morgan’s Law: . F = ((AB' + C'D)')' = ((AB')' . (C'D)')' . The boolean expression is now standardized such that it can completely be represented by a NAND gate at every input level. Step 3: Construct the NAND circuit . Now that you have gotten the boolean expression to the required standard, you can implement it as a NAND circuit. F = (A NAND B') NAND (C' NAND D) F = (A NAND (B NAND B)) NAND ((C NAND C) NAND D) . Notice that there are input elements that are present in the negative form, namely B' and C'. You can represent them by using the NAND gate in order to realise the NOT gate. ",
    "url": "/docs/comb-ssi/universal-gates.html#simplification",
    
    "relUrl": "/docs/comb-ssi/universal-gates.html#simplification"
  },"390": {
    "doc": "Universal gates",
    "title": "Introduction",
    "content": "NOR Gates are universal gates. By the virtue of functional completeness, NOR Gates can be used to fully represent a given boolean expression. This simplifies the expression such that only one standard gate is used throughout. ",
    "url": "/docs/comb-ssi/universal-gates.html#introduction-2",
    
    "relUrl": "/docs/comb-ssi/universal-gates.html#introduction-2"
  },"391": {
    "doc": "Universal gates",
    "title": "Functional completeness",
    "content": "Functional completeness is a property pertaining to boolean logic, which states that a functionally complete boolean operator can express all possible truth tables by representing itself in a boolean expression. That is, any given boolean expression can be completely represented by using the a functionally complete boolean operator. For example, NOR gates can be used to implement the NOT gate, the OR gate and the AND gate. ",
    "url": "/docs/comb-ssi/universal-gates.html#functional-completeness-1",
    
    "relUrl": "/docs/comb-ssi/universal-gates.html#functional-completeness-1"
  },"392": {
    "doc": "Universal gates",
    "title": "Simplification",
    "content": "To simplify any given boolean expression, first find the minimum number of NOR gates required. To do this, carry out the following steps. Let’s find the minimum number of NOR gates required to simplify the logical expression: . F(A, B, C, D) = (A + B').(C' + D) . Step 1: Double negation . Since the NOR gate is a combination of a NOT gate and an OR gate, we first apply a double negation to the entire expression so that we are able to standardize it later on. Adding a double negation does not alter the inherent value of the expression as a double negation always nullifies itself. F = (F')' = (((A + B').(C' + D))')' . Step 2: Applying De Morgan’s law . We first apply De Morgan’s Law to the innermost bracket, such that we preserve the outermost negation at the time of expressing the F as a NOR expression. Thus, by applying De Morgan’s Law: . F = (((A + B').(C' + D))')' = ((A + B')' + (C' + D)')' . The boolean expression is now standardized such that it can completely be represented by a NOR gate at every input level. Step 3: Construct the NOR circuit . Now that you have gotten the boolean expression to the required standard, you can implement it as a NOR circuit. F = (A NOR B') NOR (C' NOR D) F = (A NOR (B NOR B)) NOR ((C NOR C) NOR D) . Notice that there are input elements that are present in the negative form, namely B' and C'. You can represent them by using the NOR gate in order to realise the NOT gate. ",
    "url": "/docs/comb-ssi/universal-gates.html#simplification-1",
    
    "relUrl": "/docs/comb-ssi/universal-gates.html#simplification-1"
  }
}
